<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>devkuma – Data Structure</title>
    <link>https://www.devkuma.com/tags/data-structure/</link>
    <image>
      <url>https://www.devkuma.com/tags/data-structure/logo/180x180.jpg</url>
      <title>Data Structure</title>
      <link>https://www.devkuma.com/tags/data-structure/</link>
    </image>
    <description>Recent content in Data Structure on devkuma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>redfreek2c@gmail.com (kimkc)</managingEditor>
    <webMaster>redfreek2c@gmail.com (kimkc)</webMaster>
    <copyright>The devkuma</copyright>
    
	  <atom:link href="https://www.devkuma.com/tags/data-structure/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>스택 (Stack) 데이터 구조에 대한 설명</title>
      <link>https://www.devkuma.com/docs/data-structure/stack/</link>
      <pubDate>Sun, 10 Apr 2022 01:49:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/data-structure/stack/</guid>
      <description>
        
        
        &lt;h2 id=&#34;스택stack의-개념&#34;&gt;스택(Stack)의 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스택(stack)은 쌓아놓은 더미를 말한다.&lt;/li&gt;
&lt;li&gt;한 쪽 끝에서만 자료를 넣고 뺄 수 있는 후입선출(LIFO:Last In First Out) 형식의 자료 구조이다.
&lt;ul&gt;
&lt;li&gt;가장 최근에 들어온 데이터가 가장 먼저 나간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;스택의-구조&#34;&gt;스택의 구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스택 상단: top&lt;/li&gt;
&lt;li&gt;스택 하단: 불필요&lt;/li&gt;
&lt;li&gt;요소, 항목&lt;/li&gt;
&lt;li&gt;삽입/삭제 연산&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/stack-1.png&#34; alt=&#34;Stack&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;스택stack의-연산&#34;&gt;스택(Stack)의 연산&lt;/h2&gt;
&lt;p&gt;스택(Stack)는 LIFO(Last In First Out) 를 따른다. 즉, 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x): 주어진 요소 x를 스택의 맨 위에 추가한다.&lt;/li&gt;
&lt;li&gt;pop(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하고 반환한다.&lt;/li&gt;
&lt;li&gt;isEmpty(): 스택이 비어있으면 참(true)을 아니면 거짓(false)을 반환한다.&lt;/li&gt;
&lt;li&gt;peek(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하지 않고 반환한다.&lt;/li&gt;
&lt;li&gt;isFull(): 스택이 가득 차 있으면 참(true)을 아니면 거짓(false)을 반환한다.&lt;/li&gt;
&lt;li&gt;size(): 스택내의 모든 요소들의 개수를 반환한다.&lt;/li&gt;
&lt;li&gt;display(): 스택내의 모든 요소들의 출력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;스택stack의-용도&#34;&gt;스택(Stack)의 용도&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;함수 호출&lt;/li&gt;
&lt;li&gt;재귀 알고리즘을 사용하는 경우 스택이 유용하다.
&lt;ul&gt;
&lt;li&gt;재귀 알고리즘
&lt;ul&gt;
&lt;li&gt;재귀적으로 함수를 호출해야 하는 경우에 임시 데이터를 스택에 넣어준다.&lt;/li&gt;
&lt;li&gt;재귀함수를 빠져 나와 퇴각 검색(backtrack)을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 줘야 한다.&lt;/li&gt;
&lt;li&gt;스택은 이런 일련의 행위를 직관적으로 가능하게 해 준다.&lt;/li&gt;
&lt;li&gt;또한 스택은 재귀 알고리즘을 반복적 형태(iterative)를 통해서 구현할 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;웹 브라우저 방문기록 (뒤로가기)&lt;/li&gt;
&lt;li&gt;실행 취소 (undo)&lt;/li&gt;
&lt;li&gt;역순 문자열 만들기&lt;/li&gt;
&lt;li&gt;수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
&lt;ul&gt;
&lt;li&gt;Ex) 올바른 괄호 문자열(VPS, Valid Parenthesis String) 판단하기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;계산기(후위 표기법 계산)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/stack-2.png&#34; alt=&#34;스택(Stack)의 사용 사례&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gmlwjd9405.github.io/2018/08/03/data-structure-stack.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;자료구조 | 스택(Stack)이란&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Data Structure</category>
      
      <category>Stack</category>
      
    </item>
    
    <item>
      <title>쉽게 설명하는 블룸필터(Bloom Filter) 데이터 스트럭처</title>
      <link>https://www.devkuma.com/docs/data-structure/bloom-filter/</link>
      <pubDate>Fri, 23 Jun 2023 14:14:30 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/data-structure/bloom-filter/</guid>
      <description>
        
        
        &lt;h2 id=&#34;블룸필터bloom-filter&#34;&gt;블룸필터(Bloom Filter)?&lt;/h2&gt;
&lt;p&gt;블룸필터(Bloom Filter)는 효율이 좋은 &lt;strong&gt;확률적인 데이터 스트럭처&lt;/strong&gt;이다. 요소가 집합의 요소인지 여부를 테스트하는 데 사용된다.
블룸필터는 바이너리트리나 해쉬맵처럼 자주 사용되는 데이터 스트럭처는 아니지만, 간혹 사용되곤 한다.&lt;/p&gt;
&lt;p&gt;기본적인 개념은 굉장히 간단하고, 다음과 같은 상황에 굉장이 유용하다.&lt;/p&gt;
&lt;p&gt;어떤 Set(즉, 집합)과 Element가 있을 때, 특정 Element가 그 Set에 존재 여부를 블룸필터를 사용하면 빠르게 알 수 있다. 특정 Element가 특정 Set에 존재하냐고 하였을 때, 블룸필터는 두가지 답을 할수 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;특정 Element가 특정 Set 안에 존재하지 않는다.&lt;/li&gt;
&lt;li&gt;특정 Element는 특정 Set 안에 존재 할 수 도 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 두가지 답은 Element가 필터에 존재하지 않을 때는 확실히 알려줄 수 있지만, 존재를 할 때는 확실하지 않다는 것을 뜻한다.&lt;/p&gt;
&lt;p&gt;정확하지 않은데도 사용하는 이유는 Bloom Filter는 공간 효율적인 데이터 구조이다. 이는 사용하는 메모리 영역을 처음부터 고정해도 좋다.
Bloom Filter의 요소 단위는 비트이다. 32bit 머신으로 integer형이라면 최대 32개의 요소가 넣는다.&lt;/p&gt;
&lt;h2 id=&#34;블룸필터-구성&#34;&gt;블룸필터 구성&lt;/h2&gt;
&lt;p&gt;그럼, 블룸 필터가 동작에 대해서 설명하도록 하겠다. 블룸필터는 블품 1개의 배열과 n개의 Hash 함수로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/bloom-filter-0.png&#34; alt=&#34;bloom-filter&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;n개의 Hash 함수&lt;/strong&gt;&lt;br&gt;
Bloom Filter는 여러 Hash 함수를 사용한다.
Hash 함수는 어떤 값을 전달하였을 때, 그 값은 배열의 인덱스 중에 하나의 숫자로 바꿔 주는 역할을 한다.
Hash 함수의 개수는 여러개로 정할 수 있고, 각 함수는 Hash를 하는 방식이 각자 다르다.&lt;/p&gt;
&lt;p&gt;이 함수의 기능은 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set에 새로운 Element를 추가한다.&lt;/li&gt;
&lt;li&gt;Set에 입력한 Element가 존재하는지 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;여러 값을 갖는 배열&lt;/strong&gt;&lt;br&gt;
블룸 필터는 여러 값을 같는 배열로 이뤄져 있고, 어떤 값을 Hash 함수를 통해서 나온 인덱스 중에 하나를 숫자를 바꿔주게 된다.
예제의 배열의 크기는 20의 Bloom Filter를 예로 한다.&lt;/p&gt;
&lt;h3 id=&#34;블룸필터에-새로운-element-추가&#34;&gt;블룸필터에 새로운 Element 추가&lt;/h3&gt;
&lt;p&gt;블룸 필터에 &amp;ldquo;Element 1&amp;quot;를 각 3개의 함수를 통해서 인덱스를 받아오고 해당 인덱스에 값을 0에서 1로 변경한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/bloom-filter-1.png&#34; alt=&#34;bloom-filter&#34;&gt;&lt;/p&gt;
&lt;p&gt;두번째 &amp;ldquo;Element 2&amp;quot;도 동일하게 각 3개의 함수를 통해서 인덱스를 받아오고 해당 인덱스에 값을 0에서 1로 변경한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/bloom-filter-2.png&#34; alt=&#34;bloom-filter&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;블룸필터에-새로운-element-확인&#34;&gt;블룸필터에 새로운 Element 확인&lt;/h3&gt;
&lt;p&gt;&amp;ldquo;Element 3&amp;quot;가 존재하는지 알아보기 위해 함수 3개 통과해 본다.
&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/bloom-filter-3.png&#34; alt=&#34;bloom-filter&#34;&gt;&lt;/p&gt;
&lt;p&gt;Hash 함수 A,B,C 에서 각각 0,1,0을 가르키게 되고, 1개라도 0을 포함하게 되면, 입력 받은 &amp;ldquo;Element 3&amp;quot;은 존재하지 않는다.&lt;/p&gt;
&lt;p&gt;이번에는 &amp;ldquo;Element 4&amp;quot;가 존재하는지 알아보기 위해 함수 3개 통과해 본다.
&lt;img src=&#34;https://www.devkuma.com/docs/data-structure/bloom-filter-4.png&#34; alt=&#34;bloom-filter&#34;&gt;&lt;/p&gt;
&lt;p&gt;함수 A,B,C가 모두 1을 값을 가르키고 있지만, 실제로는 &amp;ldquo;Element 1,2&amp;quot;만 존재하지, &amp;ldquo;Element 4&amp;quot;는 존재하지 않았다.&lt;/p&gt;
&lt;p&gt;이렇게 존재하지 않는 &amp;ldquo;Element&amp;quot;는 확실히 존재하지 않다는 것을 알려줄수 있지만, 확실히 존재하지 않았던 &amp;ldquo;Element&amp;quot;에 대해서는 확률적으로나 알려줄수 있지 정확하게 않다.&lt;/p&gt;
&lt;h2 id=&#34;블룸필터를-사용하는-예제&#34;&gt;블룸필터를 사용하는 예제&lt;/h2&gt;
&lt;p&gt;그럼 이렇게 확실하지 않은데 사용하는 이유는 무엇인가? 그 이유는 블룸 필터가 굉장히 메모리 효율적(Efficient)이고, 빠르기 때문이다.&lt;/p&gt;
&lt;p&gt;다음 블룸필터를 사용하는 2가지 경우를 살펴 보도록 하겠다.&lt;/p&gt;
&lt;h3 id=&#34;cdn&#34;&gt;CDN&lt;/h3&gt;
&lt;p&gt;CDN은 많은 사용자가 요청하는 데이터를 사용자들에 가까이 있는 CDN에 저장을 해서 다운로드 받기 쉽게 하기 위한 것이다.&lt;/p&gt;
&lt;p&gt;CDN에서는 요청에 대한 Caching을 하게 될 건데, 첫번째 요청이 있었을 때 바로 캐싱이 된다고 생각해 하자.
그렇게 되면 여러번 요청이 안되고, 한번만 요청이 되는 경우에도 다 캐싱을 하게 될것이다. 이는 효율성은 떨어지게 된다.&lt;/p&gt;
&lt;p&gt;CDN 사업하는 Akamai라는 회사에 따르면, 4분의 3정도가 한번 밖에 요청이 되지 않는 데이터라고 한다.
그래서 생각해낸 방안이, 첫번째 요청이 왔을 때는 블룸 필터에만 표시해 놓고, 리소스를 cdn에 캐시 안하고 사용자에 전달한다.
해당 리소스가 다시 요청이 들어왔을 때 블룸필터를 확인하여 전에 요청이 되었던건지 여부를 확인할 수 있게 된다.
그러므로써 해당 리소스가 여러번 요청이 되는 것을 알게 되고, 그때 부터 캐싱을 하게 했다고 한다.&lt;/p&gt;
&lt;h3 id=&#34;key-value-store&#34;&gt;Key Value Store&lt;/h3&gt;
&lt;p&gt;Key value Store 에서 Key 를 fetch 할 때, Row이 존재하는 여부를 확인하게 되게 된다.
이때, Key가 없는 경우에 모든 Row를 확인해야 하므로 최악의 경우로 가장 느려지는데, 왜냐하면 있는 Key는 인덱스 같은 곳을 확인하였을 때, 경우에 따라 확인하자마자 그 Key 바로 찾을 있을 수도 있고, 인덱스를 몇번을 보다가 찾을 수 있다.
그러나, 그 Key 없다면 최악의 경우로 존재하는 모든 인덱스, 데이터 셋을 다 조회해야 없다는 것을 확실 할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;이때, 최악의 경우는 없는 Key 를 요청시에 대비하여 블룸 필터를 사용할 수 있다. Bloom Filter 를 사용하면 빠르게 (약간의 에러가 있을 수 있지만) Key 존재하지 않는지 Key가 존재하는지 확인 할 수 있다.&lt;/p&gt;
&lt;p&gt;아래와 같은 데이터 저장소가 Bloom Filter 를 사용하고 있다고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Bigtable&lt;/li&gt;
&lt;li&gt;HBase&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;li&gt;Cassandra&lt;/li&gt;
&lt;li&gt;PostgreSQL&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Data Structure</category>
      
    </item>
    
    <item>
      <title>데이터 구조 (Data Structure)</title>
      <link>https://www.devkuma.com/docs/data-structure/</link>
      <pubDate>Sun, 10 Apr 2022 01:49:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/data-structure/</guid>
      <description>
        
        
        
      </description>
      
      <category>Data Structure</category>
      
    </item>
    
  </channel>
</rss>
