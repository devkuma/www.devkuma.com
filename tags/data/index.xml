<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>devkuma – Data</title>
    <link>https://www.devkuma.com/tags/data/</link>
    <image>
      <url>https://www.devkuma.com/tags/data/logo/180x180.jpg</url>
      <title>Data</title>
      <link>https://www.devkuma.com/tags/data/</link>
    </image>
    <description>Recent content in Data on devkuma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>kc@example.com (kc kim)</managingEditor>
    <webMaster>kc@example.com (kc kim)</webMaster>
    <copyright>The devkuma</copyright>
    
	  <atom:link href="https://www.devkuma.com/tags/data/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>데이터 중심 애플리케이션 설계</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/</link>
      <pubDate>Wed, 03 Aug 2022 15:06:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/</guid>
      <description>
        
        
        &lt;p&gt;신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 시스템을 지탱하는 핵심 아이디어&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/book.jpg&#34; alt=&#34;데이터 중심 애플리케이션&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://wikibook.co.kr/data-intensive-applications/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://wikibook.co.kr/data-intensive-applications/&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그룹 스터디 맴버 : 김경철, 김민규, 김정수, 김은택, 박수민, 박현도, 이승익, 이호준, 조성직, 황윤호&lt;/p&gt;
&lt;p&gt;&lt;em&gt;본 자료는 그룹 스터디를 하면서 발표한 자료이다.&lt;/em&gt;&lt;/p&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 02장. 데이터 모델과 질의 언어</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/02/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/02/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 김정수, 박수민&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.devkuma.com/docs/data-intensive-application/02_ppt.pptx&#34;&gt;발표자료&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;챕터의-목적&#34;&gt;챕터의 목적&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 데이터 모델의 대한 차이점과 특성을 이해한다.&lt;/li&gt;
&lt;li&gt;만들고자 하는 애플리케이션에 어떠한 데이터 모델이 적절한지 판단할 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdb-vs-nosql&#34;&gt;RDB vs NoSQL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2장에서는 데이터 모델의 차이점에만 집중한다.
&lt;ul&gt;
&lt;li&gt;그 외 것: 내결함성(5장), 동시성 처리(7장)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NoSQL
&lt;ul&gt;
&lt;li&gt;스키마 유연성, 지역성에 기인한 더 나은 성능&lt;/li&gt;
&lt;li&gt;일부 애플리케이션의 경우, 애플리케이션에서 사용하는 데이터 구조와 더 가깝다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RDB
&lt;ul&gt;
&lt;li&gt;조인, N:1, N:N 관계를 잘 지원함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nosql&#34;&gt;NoSQL&lt;/h2&gt;
&lt;p&gt;문서와 비슷한 구조를 여러 테이블로 분리하는 관계형 기법의 문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다루기 힘든 스키마&lt;/li&gt;
&lt;li&gt;불필요하고 복합한 애플리케이션 코드 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문서-모델의-제한&#34;&gt;문서 모델의 제한&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;문서 내 중첩(nested) 항목을 바로 참조할 수 없다. (관계형은 관련된 key만 있다면 바로 참조 가능, 그러나 key를 찾기 위한 불필요한 선회가 발생할 수 도 있다.)
&lt;ul&gt;
&lt;li&gt;예) 사용자의 상세 주소를 참조해야할 경우
&lt;ul&gt;
&lt;li&gt;user.address.road.detail&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;중첩이 너무 깊지 않다면 일반적으로 문제가 되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;미흡한 조인 지원
&lt;ul&gt;
&lt;li&gt;애플리케이션의 경우에 따라 문제가 될 수도 아닐 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;다대다 관계가 필요할 경우 비효율
&lt;ul&gt;
&lt;li&gt;애플리케이션의 복잡도가 증가&lt;/li&gt;
&lt;li&gt;애플리케이션에서 처리하는 것은 데이터베이스 내의 특화된 코드로 수행되는 것 보다 성능이 안 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


상호 연결이 많은 경우

그래프 모델 &gt; 관계형 모델 &gt;&gt;&gt; 문서 모델
&lt;/div&gt;

&lt;h3 id=&#34;스미카-유연성&#34;&gt;스미카 유연성&lt;/h3&gt;
&lt;p&gt;특정 스키마를 강요하지 않는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;임의의 키와 값을 문서에 추가할 수 있다.&lt;/li&gt;
&lt;li&gt;문서에 포함된 필드의 존애 여부를 보장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


스키마를 강요하지 않는 것이지 스키마가 없는 것이 아니다.

- 관계형 모델 = 쓰기 스키마(schema-on-write)
  - 데이터 구조는 명시적
  - 데이터베이스는 모든 데이터가 스키마를 따르고 있음을 보장한다.
- 문서형 모델 = 읽기 스키마(schema-on-read)
  - 데이터 구조는 암묵적
  - 데이터를 읽을 때만 해석된다. (쓰기에는 아무런 제약이 없다.)
&lt;/div&gt;

&lt;p&gt;접근 방식에 따른 처리 방법 차이&lt;/p&gt;
&lt;p&gt;예) user에 first_name을 추가할 경우&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 문서형 모델
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 애플리케이션에서 데이터를 읽는 경우를 처리하는 코드만 있으면 된다.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// (데이터베이스의 변경을 요구하지 않는 방법이지만 좋은 방법 같진 않다. 그냥 방법의 차이를 이해하는 정도로만 여기자.)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;if (user?.name &amp;amp;&amp;amp; user?.first_name == null) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    user.first_name = user.name.split(&amp;#34; &amp;#34;)[0]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 관계형 모델
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;// 별도의 스키마 변경 및 데이터 마이그레이션 작업 필요
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ALTER TABLE users ADD COLUMN first_name test;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;UPDATE users SET first_name = substring_index(name, &amp;#39; &amp;#39;, 2);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


스키마 변경은 느리고 중단시간을 요구한다.

- 예외적으로 MySQL의 경우 스키마 변경은 성능이 매우 안 좋다.
&lt;/div&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


컬럼 추가의 경우 기존의 모든 레코드에 데이터가 없으므로

1. 일단 nullable 속성으로 null 데이터를 가지게한 후
2. 데이터를 업데이트하고 (데이터베이스 크기가 큰 경우 업데이트 작업이 오래걸릴 수 있다.)
3. 다시 본래의 속성(nullable or non-null)로 변경해야 한다.
&lt;/div&gt;

&lt;h3 id=&#34;저장소-지역성&#34;&gt;저장소 지역성&lt;/h3&gt;
&lt;p&gt;지역성: 데이터, 프로그램 등에 대해서 특정 부분에 집중적으로 접근하는 성질&lt;/p&gt;
&lt;p&gt;자주 전체 문서에 접근해야 하는 경우 저장소 지역성 활용할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정규화된 관계형 모델의 구조보다 역정규화된 문서형 모델의 구조가 성능상 이점이 있다
&lt;ul&gt;
&lt;li&gt;관계형 모델은 검색을 위해 다중 색인 검색이 필요 → 더 많은 디스크 탐색 필요 → 더 많은 시간 소요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용
&lt;ul&gt;
&lt;li&gt;문서형 모델에서는 작은 부분에만 접근해야 하는 경우에도 전체 문서를 저장해야 하기 때문에 큰 문서에서는 낭비일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적으로 문서를 최대한 작게 유지하면서 문서 크기의 증가를 최소화할 것을 권장&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 성능 제한 때문에 문서형 모델이 유용한 상황이 많이 줄어든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


관계형 모델에서도 지역성이 적용된 개념이 존재한다.

- 스패너(구글의 데이터베이스): 인터리브 테이블 
  - https://cloud.google.com/spanner/docs/schema-and-data-model#creating-interleaved-tables
- 오라클: 다중 테이블 색인 클러스터 테이블
- 카산드라, HBase: 컬럼 패밀리
&lt;/div&gt;

&lt;h2 id=&#34;rdb와-nosql의-통합&#34;&gt;RDB와 NoSQL의 통합&lt;/h2&gt;
&lt;p&gt;(서로 비슷한 기능을 제공한다는 의미)&lt;/p&gt;
&lt;p&gt;RDB&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL을 제외한 대부분의 RDB는 XML을 지원하여 문서형 모델과 매우 비슷한 데이터 모델을 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;Postgre 9.3+, MySQL 5.7+, DB2 10.5+: JSON 문서에 대해 비슷한 기능을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리싱크DB: 쿼리에서 관계형 조인을 지원&lt;/li&gt;
&lt;li&gt;몽고DB: 드라이버가 자동으로 데이터베이스 참조를 확인 (클라이언트에서 조인 수행, 네트워크 왕복이 추가로 필요, 최적화가 덜 되어 있어서 조인 성능이 좋지 않다)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;질의-언어query-language&#34;&gt;질의 언어(Query Language)&lt;/h2&gt;
&lt;h2 id=&#34;선언형-vs-명령형&#34;&gt;선언형 vs 명령형&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SQL의 선언형&lt;/li&gt;
&lt;li&gt;IMS, 코다실의 명령형 (안 중요)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;선언형 질의 언어의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;알고자 하는 데이터의 패턴만 지정하면 된다. (어떤 색인과 조인 함수를 사용할지, 어떤 순서로 실행할 지는 데이터베이스의 질의 최적화가 할 일이다.)
&lt;ul&gt;
&lt;li&gt;충족해야 하는 조건&lt;/li&gt;
&lt;li&gt;데이터의 변환 (정렬, 그룹화, 집계 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일반적으로 명령형 질의 API보다 더 간결하고 쉽게 작업할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터베이스 엔진의 상세 구현이 추상화되어 있어서 쿼리를 변경하지 않고도 데이터베이스의 성능을 향상시킬 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;웹의 예제&lt;/p&gt;
&lt;p&gt;HTML에 style을 적용할 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS는 선언형&lt;/li&gt;
&lt;li&gt;JS로 DOM API를 사용하는 것은 명령형&lt;/li&gt;
&lt;li&gt;선언형이 명령형보다 가독성, 생산성, 유지보수성에서 우수하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


데이터베이스에서도 SQL같은 선언형 질의 언어가 명령형 질의 API보다 &#34;훨씬&#34; 좋다고 한다.
&lt;/div&gt;

&lt;h3 id=&#34;맵리듀스-질의&#34;&gt;맵리듀스 질의&lt;/h3&gt;
&lt;p&gt;(안 중요)&lt;/p&gt;
&lt;p&gt;함수형 프로그래밍에 있는 map, reduce 함수를 기반으로 한다.&lt;/p&gt;
&lt;p&gt;단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;질의를 작성하는 것 보다 어렵다&lt;/li&gt;
&lt;li&gt;선언형 질의 언어는 질의 최적화기가 질의 성능을 높일 수 있는 기회를 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;몽고DB 2.2에서 집계 파이프라인(aggregate pipeline)이라는 선언형 질의 언어 지원을 추가하였다.&lt;/p&gt;
&lt;h2 id=&#34;그래프형-데이터-모델&#34;&gt;그래프형 데이터 모델&lt;/h2&gt;
&lt;p&gt;애플리케이션의 데이터 모델이 주로 1:N(트리 구조 데이터)거나 엔티티간 관계가 없다면 문서형 모델이 적합하다.&lt;/p&gt;
&lt;p&gt;그러나 N:N 관계가 매우 일반적인 경우라면 그래프형 모델이 적합하다.&lt;/p&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


관계형 모델은 단순한 N:N 관계까지는 적합하나 그 이상의 복잡한 N:N 관계를 다루기에는 적합하지 않다. (복잡도가 상승)
&lt;/div&gt;

&lt;h3 id=&#34;그래프-구성-요소&#34;&gt;그래프 구성 요소&lt;/h3&gt;
&lt;p&gt;정점(Vertex, 혹은 노드나 엔티티)
SpringData에서는 노드엔티티라고 한다. (@NodeEntity)
간선(Edge 혹은 관계나 호(arc))&lt;/p&gt;
&lt;p&gt;예시)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소셜 그래프
&lt;ul&gt;
&lt;li&gt;정점 = 사람, 간선 = 친구관계&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;웹 그래프
&lt;ul&gt;
&lt;li&gt;정점 = 웹페이지, 간선 = 링크&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;도로 네트워크
&lt;ul&gt;
&lt;li&gt;정점 = 교차로, 간선 = 도로&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;페이스북
&lt;ul&gt;
&lt;li&gt;여러 유형의 정점과 간선을 단일 그래프로 유지&lt;/li&gt;
&lt;li&gt;정점 = 사람, 장소, 이벤트, 체크인, 코멘트 등&lt;/li&gt;
&lt;li&gt;간선 = 사람간 관계, 체크인이 발생한 위치, 누가 어떤 포스트에 코멘트 했는지, 누가 이벤트에 참석했는지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;만약 페이스북을 관계형 모델로 만든다면?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사람, 장소, 이벤트, 체크인, 코멘트 등등이 모두 테이블로 정의될 것이다.&lt;/li&gt;
&lt;li&gt;그리고 각 테이블 간의 엄청 복잡한 관계들이 필요할 것이다.&lt;/li&gt;
&lt;li&gt;그래프 모델을 적용하는 순간 이러한 복잡성들이 단순화된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;그래프-모델의-종류&#34;&gt;그래프 모델의 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;속성 그래프 모델&lt;/li&gt;
&lt;li&gt;트리플 저장소 모델 (안 중요)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;그래프용-선언형-질의-언어&#34;&gt;그래프용 선언형 질의 언어&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;사이퍼(Cypher)&lt;/li&gt;
&lt;li&gt;스파클&lt;/li&gt;
&lt;li&gt;데이터로그&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;속성-그래프&#34;&gt;속성 그래프&lt;/h3&gt;
&lt;p&gt;정점의 구성 요소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;유출(outgoing) 간선 집합&lt;/li&gt;
&lt;li&gt;유입(incoming) 간선 집합&lt;/li&gt;
&lt;li&gt;속성 컬렉션 (키-값 쌍)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간선의 구성 요소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;간선이 시작하는 정점(tail vertex)&lt;/li&gt;
&lt;li&gt;간선이 끝나는 정점(head vertex)&lt;/li&gt;
&lt;li&gt;두 정점 간 관계 유형을 설명하는 레이블&lt;/li&gt;
&lt;li&gt;속성 컬렉션 (키-값 쌍)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


간선의 방향은 tail -&gt; head 방향이다 (그래서 tail이 시작, head가 끝)
&lt;/div&gt;

&lt;p&gt;관계형 스키마를 사용해 속성 그래프 표현하기&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertices&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertex_id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;integer&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;KEY&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;properties&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;json&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edges&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edge_id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;integer&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;KEY&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;tail_vertex&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;integer&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;REFERENCES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertices&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertex_id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;head_vertex&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;integer&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;REFERENCES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertices&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vertex_id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;label&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;text&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;properties&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;json&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edges_tails&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edges&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;tail_vertex&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edges_heads&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;edges&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;head_vertex&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;정점은 다른 정점과 간선으로 연결된다
&lt;ul&gt;
&lt;li&gt;특정 유형과 관련 여부를 제한하는 스키마는 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다.&lt;/li&gt;
&lt;li&gt;다른 유형의 관계에 서로 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서 데이터 모델을 깔끔하게 유지할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 기능을 통해 그래프는 데이터 모델링을 위한 많은 &lt;strong&gt;유연성&lt;/strong&gt;을 제공한다.&lt;/p&gt;
&lt;p&gt;그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;사이퍼cypher&#34;&gt;사이퍼(Cypher)&lt;/h3&gt;
&lt;p&gt;속성 그래프를 위한 선언형 질의 언어&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네오포제이(Neo4j) 그래프 데이터베이스용으로 만들어졌다.&lt;/li&gt;
&lt;li&gt;wiki: 사이퍼는 식으로 나타내는, 프로퍼티 그래프의 효율적인 질의 및 업데이트를 허용하는 선언형 그래프 질의어이다. 사이퍼는 상대적으로 단순하지만 매우 강력한 언어이다. 매우 복잡한 데이터베이스 쿼리들은 사이퍼를 통해 쉽게 표현이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터 모델 생성&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-cypher&#34; data-lang=&#34;cypher&#34;&gt;CREATE
(NAmerica:Location {name:’North America’, type:’continent’}),
(USA:Location {name:’United States’, type:’country’}),
(Idaho:Location {name:’Idaho’, type:’state’}),
(Lucy:Person {name:’Lucy’}),
(Idaho) -[:WITHIN]-&amp;gt; (USA) -[:WITHIN]-&amp;gt; (NAmerica),
(Lucy) -[:BORN_IN]-&amp;gt; (Idaho)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;문제. 미국에서 유럽으로 이민 온 모든 사람들의 이름 찾기&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-cypher&#34; data-lang=&#34;cypher&#34;&gt;MATCH
(person) -[:BORN_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (USA:Location {name:’United States’}),
(person) -[:LIVES_IN]-&amp;gt; () -[:WITHIN*0..]-&amp;gt; (EU:Location {name:’Europe’})
RETURN person.name
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;질의 실행 방법&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;모든 사람을 조회로 시작 -&amp;gt; 사람들의 출생지와 거주지를 확인 -&amp;gt; 맞는 사람들만 반환&lt;/li&gt;
&lt;li&gt;2개의 Location으로 시작 -&amp;gt; 미국과 유럽의 모든 위치 찾기를 진행 -&amp;gt; leaf 에 해당하는 정점 중 하나에 BORN_IN, LIVES_IN 유입 간선을 통해 발견된 사람들을 반환&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;선언형의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수행 방법에 대해서 자세히 기술할 필요가 없음&lt;/li&gt;
&lt;li&gt;질의 최적화기가 알아서 가장 효율적인 전략을  자동으로 선택&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;관계형 모델에서 위의 쿼리를 한다면?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가능하지만 어려움&lt;/li&gt;
&lt;li&gt;보통 관계형 모델에서는 쿼리에 필요한 조인을 미리 알고 있다. (FROM 절에서 선언)&lt;/li&gt;
&lt;li&gt;그러나 그래프 쿼리에서는 찾고자 하는 정점을 위해 여러 간선을 순회해야 한다.
&lt;ul&gt;
&lt;li&gt;순회가 몇 번 인지 모른다.&lt;/li&gt;
&lt;li&gt;조인 수를 미리 고정할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;사이버 쿼리에서 &lt;code&gt;-[:WITHIN*0..]-&amp;gt;&lt;/code&gt; 로 순회를 매우 간결하게 표현한다. (*0은 0회 이상을 의미)&lt;/p&gt;
&lt;p&gt;SQL1999 이후로 가변 순회 경로에 대한 쿼리를 재귀 공통 테이블 식(Recursive common table expression, 이하 Recursive CTE)(WITH RECURSIVE 문)을 사용해 표현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Postgre, DB2, Oracle, SQL Server에서 지원함&lt;/li&gt;
&lt;li&gt;MySQL 5.7+ 에서는 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;트리플-저장소와-스파클&#34;&gt;트리플 저장소와 스파클&lt;/h3&gt;
&lt;p&gt;(안 중요)&lt;/p&gt;
&lt;p&gt;속성 그래프 모델과 거의 동일&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단지 동일 개념에 대한 용어만 다르다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터를 주어(subject), 서술어(predicate), 목적어(object)로 매우 간단한 세 부분 구문(three-part statements) 형식으로 저장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주어 = 정점&lt;/li&gt;
&lt;li&gt;목적어 = 다른 정점 or primitive datatype의 데이터&lt;/li&gt;
&lt;li&gt;서술어 = 간선&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Turtle&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wiki: Terse RDF Triple Language (Turtle)는 Resource Description Framework 데이터 모델에서 데이터를 표현하기 위한 구문 및 파일 형식입니다. Turtle 구문은 RDF 쿼리 언어인 SPARQL의 구문과 유사하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스파클은 RDF 데이터 모델을 사용한 트리플 저장소 질의 언어이다.&lt;/p&gt;
&lt;h3 id=&#34;데이터-로그&#34;&gt;데이터 로그&lt;/h3&gt;
&lt;p&gt;데이터 모델이 트리플 저장소 모델과 유사&lt;/p&gt;
&lt;p&gt;주어, 서술어 목적어 -&amp;gt; 서술어(주어, 목적어)&lt;/p&gt;
&lt;h3 id=&#34;그래프-데이터베이스-순위&#34;&gt;그래프 데이터베이스 순위&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://db-engines.com/en/ranking/graph&amp;#43;dbms&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://db-engines.com/en/ranking/graph+dbms&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;한 줄 요약 : 그래프 데이터베이스를 사용하고 싶을 경우 Neo4J를 사용하면 된다.&lt;/p&gt;
&lt;h3 id=&#34;neo4j&#34;&gt;Neo4J&lt;/h3&gt;
&lt;p&gt;SpringData 지원&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spring.io/guides/gs/accessing-data-neo4j/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://spring.io/guides/gs/accessing-data-neo4j/&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;spring-boot-starter-data-neo4j
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@NodeEntity&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Food&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@Id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Long&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;FoodRepository&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Neo4jRepository&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Food&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Long&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@NodeEntity&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Store&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@Id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Long&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#5c35cc;font-weight:bold&#34;&gt;@Relationship&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;has&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;foods&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Set&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Food&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;StoreRepository&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Neo4jRepository&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;Store&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Long&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;역사적으로 데이터를 하나의 큰 트리로 표현하려고 노력&lt;/li&gt;
&lt;li&gt;N:N 관계 표현에 적절하지 않음 → 관계형 모델 등장&lt;/li&gt;
&lt;li&gt;최근(?) 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견 → 비관계형 데이터 모델인 NoSQL 등장&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL은 두 가지의 주요 갈래가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문서형 모델
&lt;ul&gt;
&lt;li&gt;모든 데이터가 문서에 포함하고 문서간의 관계가 거의 없는 경우 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그래프형 모델
&lt;ul&gt;
&lt;li&gt;문서형 모델과 정반대로 모든 것이 잠재적으로 관련 있는 경우 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;세 가지 모델 모두 현재 널리 사용&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 모델을 다른 모델로 흉내낼 수 있지만 대부분 그 결과는 엉망이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;문서형 모델, 그래프형 모델의 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;저장할 데이터를 위한 스키마를 강제하지 않음 → 변화하는 요구사항에 맞춰 애플리케이션을 쉽게 변경할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 03장. 저장소와 검색</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/03/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/03/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 김경철, 김민규&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;데이터베이스에서 &lt;strong&gt;데이터를 저장하는 방법과 데이터를 요청 했을 때 다시 찾을 수 있는 방법&lt;/strong&gt;에 대해 알아본다.&lt;/p&gt;
&lt;p&gt;특정 작업부하(workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하려면, 엔진 내부에서 수행되는 작업에 대해 대략적인 개념을 이해할 필요가 있다.&lt;/p&gt;
&lt;p&gt;관계형 테이터 베이스, NoSQL이라 불리는 저장소 엔진에 대해서 설명을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그 구조(log-structured) 계열 저장소 엔진&lt;/li&gt;
&lt;li&gt;B트리(B-tree) 같은 페이지 저향(page-oriented) 계열 저장소 엔진&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터베이스를-강력하게-만드는-데이터-구조&#34;&gt;데이터베이스를 강력하게 만드는 데이터 구조&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;키-값 저장소&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2개의 bash 함수로 구현한, 세상에서 가장 간단한 데이터베이스이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;#!/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;db_set&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#204a87&#34;&gt;echo&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;$1&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;$2&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; database
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;db_get&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    grep &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;^&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;$1&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;,&amp;#34;&lt;/span&gt; database &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; sed -e &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;S/^&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;$1&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;,//&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;|&lt;/span&gt; tail -n &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;위 코드를 활용한 명령어는 아래와 같다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ db_set &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;{&amp;#34;name&amp;#34;:&amp;#34;San Francisco&amp;#34;,&amp;#34;attractions&amp;#34;:[&amp;#34;Exploratorium&amp;#34;]}&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ db_get &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;San Francisco&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;attractions&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Exploratorium&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ cat
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;123456,&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;London&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;attractions&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Big Ben&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;London Eye&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;42,&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;San Francisco&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;attractions&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Golden Gate Bridge&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;42,&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;San Francisco&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;attractions&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Exploratorium&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;저장(db_set)&lt;/th&gt;
          &lt;th&gt;저장(db_get)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;행위&lt;/td&gt;
          &lt;td&gt;key와 value를 저장&lt;/td&gt;
          &lt;td&gt;해당 key와 연관된 가장 최근 값을 찾아 반환&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;내부 동작&lt;/td&gt;
          &lt;td&gt;호출될 때마다 파일의 마지막에 추가(append)&lt;/td&gt;
          &lt;td&gt;파일에 키의 마지막(최근) 항목을 검색&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;성능&lt;/td&gt;
          &lt;td&gt;성능이 좋다.&lt;br&gt; - 간단한 작업인 경우에 좋다.&lt;/td&gt;
          &lt;td&gt;성능이 좋지 않다.&lt;br&gt; - 레코드가 많을 수록 더 안 좋다.&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;로그(log)란?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 로그는 애플리케이션에서 무슨 일이 일어나는지 기술한 텍스트이다.&lt;/li&gt;
&lt;li&gt;여기에서는 연속된 추가 전용(append-only) 레코드를 말한다.&lt;/li&gt;
&lt;li&gt;많은 데이터베이스는 내부적으로 추가 전용(apend-only) 데이터 파일인 로그(log)를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;검색 성능의 문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키가 있는지 찾기 위해 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다.&lt;/li&gt;
&lt;li&gt;알고리즘 용어로 검색 비용 O(n)이다.
&lt;ul&gt;
&lt;li&gt;레코드 수가 두배로 늘면, 검색도 두배로 오래 걸린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;검색 성능의 개선 방법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해 색인(index, 다른 데이터 구조)이 필요하다.&lt;/li&gt;
&lt;li&gt;색인의 일반적인 개념을 어떤 부가적인 메타데이터를 유지하는 것이다.
&lt;ul&gt;
&lt;li&gt;메타데이터는 이정표 역할을 해서 원하는 데이터 위치에 찾은데 도움을 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;여러가지 다양한 방법으로 검색하고자 한다면, 데이터의 각 여러 가지 다양한 색인이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;색인의 구조&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;색인은 기본 데이터(primary data)에서 파생된 추가적인 구조다.&lt;/li&gt;
&lt;li&gt;색인은 질의 성능에 영향을 준다.&lt;/li&gt;
&lt;li&gt;쓰기 과정에서 오버헤드가 발생한다.
&lt;ul&gt;
&lt;li&gt;데이터를 쓸 때마다 색인을 갱신해야 하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;색인의 선택&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;색인 선택에는 트레이드오프(trade-off)가 발생한다.
&lt;ul&gt;
&lt;li&gt;색인을 잘 선택했다면 &lt;strong&gt;읽기 질의 속도가 향상시킨다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;하지만, 모든 색인은 &lt;strong&gt;쓰기 속도를 떨어 뜨린다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;보통 자동으로 모든 것을 색인하지 않기에, 애플리케이션의 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다.&lt;br&gt;
오버헤드를 발생시키지 않으면서, 애플리케이션에 가장 큰 이익을 안겨주는 색인을 선택해야 한다.&lt;/p&gt;
&lt;h3 id=&#34;해시-색인-hash-index&#34;&gt;해시 색인 (Hash index)&lt;/h3&gt;
&lt;p&gt;키-값 데이터는 매우 일반적이고 더욱 복잡한 색인을 위한 구성 요소로 유용하다.&lt;br&gt;
대부분의 프로그래밍 언어에서 볼 수 있는 &lt;strong&gt;사전 타입(Dictionary type)&lt;/strong&gt; 유사하고, Hash map(Hash table)으로 구현한다.&lt;/p&gt;
&lt;p&gt;키를 데이터 파일의 **바이트 오프셋(byte offset)**에 매핑해서 인메모리(in-memory) 해시 맵을 유지하는 전략으로 색인에 접근해 보자.&lt;br&gt;
바이트 오프셋은 그림 3-1과 같이 값을 바로 찾을 수 있는 위치이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_1.png&#34; alt=&#34;그림 3-1&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 3-1. CSV와 유사한 형식의 키-값 쌍의 로그 저장하기, 인메모리 해시 맵으로 색인했다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추가 : 파일에 새로운 key-value 쌍을 추가할 때마다 방금 기록한 데이터의 offset 을 반영하기 위해 hash map 도 갱신해야 한다.&lt;/li&gt;
&lt;li&gt;조회 : 조회할 때는 hash map 을 사용해 데이터 파일에서 offset 을 찾아 해당 위치를 구해서 값을 읽는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 방식은 단순해 보이지만 많이 사용하는 접근법이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Riak의 비트케스크&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위에 방식은 &lt;a href=&#34;https://docs.riak.com/riak/kv/2.2.3/setup/planning/backend/bitcask/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Riak의 비트케스크(Bitcask, 기본 저장 엔진)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;가 사용하는 방식이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;해시맵을 전부 메모리에 유지하기 때문에 RAM에 모든 키가 저장된다는 조건을 전제로 고성능 읽기, 쓰기를 보장한다.&lt;/li&gt;
&lt;li&gt;값은 한번의 디스크 탐색으로 디스크에 적재할 수 있기 때문에 사용 가능한 메모리보다 더 많은 공간을 사용할 수 있다.
&lt;ul&gt;
&lt;li&gt;데이터 파일의 일부가 파일 시스템 캐시에 있다면 읽기에 디스크 입출력도 필요하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이런 형태의 저장소는 각 key의 value가 자주 갱신되는 상황에 매우 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;디스크 공간 부족의 해결책&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그런데 지금과 같은 상황으로 파일에 계속해서 추가만 된다면 결국 디스크 공간이 부족해 진다. 이럴때 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행한다.&lt;/li&gt;
&lt;li&gt;그러고 세그먼트 파일에 대해 **컴팩션(compaction)**을 수행한다.
&lt;ul&gt;
&lt;li&gt;컴팩션(compaction)란? 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;hellip; 이미지 &amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_2.png&#34; alt=&#34;그림 3-2&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 3-2. 키-값 갱신 로그를 컴팩션하고 각 키의 최신(마지막) 값만 유지한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컴팩션과 세그먼트 병합&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;컴팩션은 세그먼트를 더 작게 만들 수 때문에, 컴팩션을 수행할 때는 동시에 여러 세그먼트들을 병합할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;세그먼트가 쓰여진 후에는 변경할 수 없기 때문에, 병합할 세그먼트는 새로운 파일로 만든다.&lt;/li&gt;
&lt;li&gt;고정된 세그먼트의 병합과 컴팩션을 백그라운드로 스레드로 수행할 수 있어, 컴팩션을 수행하는 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기 요청의 처리를 정상적으로 계속 수행할 수 있게 된다.&lt;/li&gt;
&lt;li&gt;병합 과정이 끝난 이후에는 읽기 요청은 이전 세그먼트 대신 새로 병합한 세그먼트를 사용하게끔 전환한다.&lt;/li&gt;
&lt;li&gt;전환 후에는 이전 세그컨트 파일을 삭제된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_3.png&#34; alt=&#34;그림 3-3&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-3. 컴팩션과 세그먼트 병합을 동시에 수행한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;병합된 세그먼트는 키를 오프셋에 매핑한 자체 인메모리 해시 테이블에 반영한다.&lt;br&gt;
키의 값을 찾으려면 세그먼트 해시 맵을 먼저 확인한다. 만약 없다면 두 번째 최신 세그먼트 등을 확인 한다.&lt;br&gt;
병합 과정을 통해 세그먼트 수를 적게 유지하면 조회할 때 많은 해시 맵을 확인할 필요가 없다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;실제 구현할 때 주의해야 할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파일 형식
&lt;ul&gt;
&lt;li&gt;key-value 를 구분하는 것이 콤마(,) 이다. 그렇다고 해서 CSV 가 적합한 형식은 아니다.&lt;/li&gt;
&lt;li&gt;문자열을 부호화하는 바이너리 형식을 사용하는 것이 더 빠르고 간단하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;레코드 삭제
&lt;ul&gt;
&lt;li&gt;키에 해당하는 값을 삭제하려면, 데이터 파일에 특수한 삭제 레코드(Tombstone, 묘비)를 추가해야 한다.&lt;/li&gt;
&lt;li&gt;로그 세그먼트 이 톰스톰을 병합 과정에서 삭제된 키의 이전 값을 무시하게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;고장(Crash) 복구
&lt;ul&gt;
&lt;li&gt;데이터베이스가 재시작되면 in-memory hash map은 손실된다.&lt;/li&gt;
&lt;li&gt;데이터가 커지면 hash map을 복원하는데 오래 걸리기 때문에 스냅샷(Snapshot)을 만들어 디스크에 저장하여 복구 속도를 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;부분적으로 레코드 쓰기
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 로그에 record를 추가하는 도중에 죽을 수 있다.&lt;/li&gt;
&lt;li&gt;bitcask 파일은 checksum을 포함하고 있어서 로그의 손상된 부분을 탐지해 무시할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동시성 제어
&lt;ul&gt;
&lt;li&gt;순차적으로 로그에 추가할 때 일반적인 구현하는 방법은 Single thread만 사용한다.&lt;/li&gt;
&lt;li&gt;읽기는 불변(immutable)이므로,Multi thread 로 동시에 읽기를 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;추가 전용(append-only) 로그의 이점&lt;/strong&gt;&lt;br&gt;
추가 전용(append-only) 로그는 언뜻 보면 낭비처럼 보인다. 왜 파일의 그 자리에서 오래된 값을 갱신하지 않는 것일까? 하지만 append-only 설계는 여러 측면에서 좋은 설계이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;append-only 와 segment 병합은 순차적인 쓰기 작업이기 때문에 보통 &lt;strong&gt;무작위 쓰기보다 빠르다.&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;특히 자기 회전 디스크 하드 드라이브에서 더 빠르다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;segment 파일이 추가 전용이나 불변이면 동시성과 &lt;strong&gt;고장 복구가 간단하다.&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;값을 덮어 쓰는 동안 DB 가 죽는 경우에 대해서 걱정할 필요가 없다. 이전 값 부분과 새로운 값 부분을 포함한 파일을 나누어 함께 남겨두기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;오래된 segment 병합은 시간이 지남에 따라 &lt;strong&gt;조각화되는 데이터 파일 문제를 피할 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;해시 테이블 색인 제한 사항&lt;/strong&gt;&lt;br&gt;
그러나 hash table index 역시 한계가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메모리 저장해야 하므로 키가 너무 많으면 문제가 된다.
&lt;ul&gt;
&lt;li&gt;디스크에 hash map 을 유지할 수 있지만 디스크 상에서 좋은 성능을 기대하기 어렵다.&lt;/li&gt;
&lt;li&gt;이는 무작위 접근 I/O 가 많이 발생하고 디스크가 가득 찼을 때 확장하는 비용이 비싸며 해시 충돌 해소를 위해 성가신 로직이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;range query 에 효율적이지 않다.
&lt;ul&gt;
&lt;li&gt;해시 맵에서 모든 개별 키를 조회해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다음에는 이런 제한이 없는 색인 구조를 살펴보자.&lt;/p&gt;
&lt;h3 id=&#34;ss테이블과-lsm-트리&#34;&gt;SS테이블과 LSM 트리&lt;/h3&gt;
&lt;p&gt;일련의 키-값 쌍으로 키로 정렬하는 것이다. 이런 변경은 순차 쓰기(append-only)를 할 수 없게 하는거 같지만, 뒤에서 알아보겠다.&lt;/p&gt;
&lt;p&gt;키로 정렬된 형식을 정렬된 **문자열 테이블(Sorted String Table, SS테이블)**이라고 한다. 각 키가 병합된 세그먼트 파일 내에는 한번만 나타나야 한다(이미 컴팩트 과정이 이를 이미 보장한다).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;해시 색인을 가진 로그 세그먼트 비교한 SS 테이블의 장점&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;세그먼트 병합은 파일이 사용가능한 메모리보다 크더라도 간단하고 효율적이다. 병합 정렬(mergesort) 알고리즘의 방식과 유사하다.&lt;br&gt;
각 세그먼트를 읽고 첫 번째 키를 본다(이미 정렬되어있고, 그 순서대로) 그리고 가장 낮은 키를 출력 파일로 복사한뒤 이 과정을 반복한다.&lt;br&gt;
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_4.png&#34; alt=&#34;그림 3-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-4. 여러 SS테이블 세그먼트를 병합하고 각 키의 최신 값만 유지한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;여러 세그먼트에 동일한 키가 있다면 어떻게 해야 할까? 다중 세그먼트가 동일한 키를 포함하는 경우 가장 최근 세그먼트의 값은 유지하고 오래된 세그먼트의 값은 버린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일에서 특정 키를 찾기 위해 모든 키를 메모리에 색인으로 유지할 필요는 없다.&lt;br&gt;
아래 그림에서 handiwork 를 보면 handbag 과 handsome 사이에 있음을 알 수 있다.
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_5.png&#34; alt=&#34;그림 3-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 3-5. 인메모리 색인을 가진 SS테이블&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;읽기 요청은 요청 범위 내에서 key-value 를 스캔해야 한다. 따라서 record를 블록으로 그룹화 하고 디스크에 쓰기 전에 압축한다. 그러면 key는 압축된 블록의 시작을 가리키게 된다.&lt;br&gt;
disk 공간을 절약하는 것 외에도 I/O를 줄일 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ss테이블-생성과-유지-constructing-and-maintaining-sstables&#34;&gt;SS테이블 생성과 유지 (Constructing and maintaining SSTables)&lt;/h4&gt;
&lt;p&gt;그런데 이러한 기능을 구현할 수 있는것은 key 가 정렬되어 있기 때문이다. 쓰기 요청은 유입되는 순서대로 쓰기가 발생한다.&lt;/p&gt;
&lt;p&gt;디스크에 정렬된 구조를 유지하는 것은 가능하지만(B트리 참조), 메모리에 유지하는 편이 더 쉽다.&lt;br&gt;
레드 블랙 트리(red-black tree)나 AVL 트리와 같이 잘 알려진 데이터 구조 등은 많이 있다.&lt;br&gt;
이러한 데티터 구조를 이용하면 임의 순서로 키를 삽입하고 정렬된 순서로 해당 키를 다시 읽을 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;저장소 엔진 구현&lt;/strong&gt;&lt;br&gt;
저장소 엔진은 다음과 같이 만들 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쓰기가 들어오면 균형 트리(balanced tree)에 추가한다.
&lt;ul&gt;
&lt;li&gt;이 인메모리는 맴테이블(memtable)이라고도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이 맴테이블이 임계값 보다 커지면 SS테이블 파일로 디스크에 기록한다.
&lt;ul&gt;
&lt;li&gt;이미 정렬되어 있기 때문에 효율적으로 저장할 수 있다.&lt;/li&gt;
&lt;li&gt;이 새로운 SS테이블은 DB의 가장 최신 세그먼트가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 요청이 있으면 맴테이블에서 키를 찾는다.
&lt;ul&gt;
&lt;li&gt;없으면 그 다음 가장 최신의 세그먼트, 또 없으면 그 다음으로 오래된 세그먼트를 찾는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;가끔 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 작업을 한다.
&lt;ul&gt;
&lt;li&gt;이는 background 에서 수행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;저장소 엔진 장애 발생시 대응법&lt;/strong&gt;&lt;br&gt;
DB가 고장나서 디스크로 기록되지 않은 memtable 이 있다면, 이 데이터는 손실 될 수 있으므로 append-only 로그를 디스크 상에 유지해야 한다.&lt;br&gt;
이 로그는 데이터를 복구하는데만 사용하며 정렬되지 않아도 문제가 없다. 맴테이블은 SS테이블로 기록하고 나면 해당 로그는 버린다.&lt;/p&gt;
&lt;h4 id=&#34;ss테이블에서-lsm-트리-만들기-making-an-lsm-tree-out-of-sstables&#34;&gt;SS테이블에서 LSM 트리 만들기 (Making an LSM-tree out of SSTables)&lt;/h4&gt;
&lt;p&gt;이런 색인 구조를 로그 구조화 병합 트리(Log-Structred Merge-Tree, LSM)란 이름으로 패트릭 오닐(Patrick O`Neil) 등이 발표했다.&lt;/p&gt;
&lt;p&gt;정렬된 파일 병합과 컴팩트 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;루씬(Lucene)&lt;/strong&gt;
루씬(Lucene)은 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진이다.&lt;br&gt;
루씬은 용어 사전(term dictionary)을 저장하기 위해 유사한 방법으로 전문 검색을 구현했다.&lt;br&gt;
질의 단어가 들어오면 단어가 언급된 모든 문서를 찾는다.&lt;br&gt;
이 접근법이 키를 단어(용어)로, 같은 값을 포함한 모든 문서의 ID 목록으로 하는 key-value 로 구현한다.&lt;br&gt;
용어와 용어에 해당하는 문서를 SS테이블 같은 정렬 파일에 유지하고 필요에 따라 background 에서 병합한다.&lt;/p&gt;
&lt;h4 id=&#34;성능-최적화-performance-optimizations&#34;&gt;성능 최적화 (Performance optimizations)&lt;/h4&gt;
&lt;p&gt;LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다. 앞에서 설명 했듯이  맴테이블을 검색하고, 가장 오래된 세그먼트까지 검색해야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;이런 종류의 접근을 최적화하기 위해 **블룸 필터(bloom filter)**라는 것을 사용한다. (블룸 필터는 집한 내용을 근사한(approximating) 메모리 효율적 구조이다. 키가 데이터베이스에 존재하지 않음을 알려주므로 불필요한 디스크 읽기를 줄일 수 있다.)&lt;/p&gt;
&lt;p&gt;또한, SS테이블을 압축하고 압축(compaction)하고 병합(merge)하는 순서와 시기를 다양한 전략이 있다.&lt;/p&gt;
&lt;p&gt;대표적으로 **크기 계층(사이즈 계충, size-tiered)**과 **레벨 컴팩션(level compaction)**이 있다. LevelDB, LocksDB가 이 이름을 따왔다고 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;크기 계층 컴팩션
&lt;ul&gt;
&lt;li&gt;상대적으로 좀 더 새롭고 작은 SS테이블을 오래되고 큰 SS테이블에 연이어 병합한다.&lt;/li&gt;
&lt;li&gt;HBase, 카산드라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;레벨 컴팩션
&lt;ul&gt;
&lt;li&gt;키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 &amp;ldquo;level&amp;rdquo; 로 이동하기 때문에 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용했다.&lt;/li&gt;
&lt;li&gt;레벨DB(LevelDB, 레벨DB이라는 이름이 레벨 컴팩션에서 유래), 룩스DB(LocksDB), 카산드라&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 나누고 순차적으로 병합하는 것이다. 이 개념은 데이터셋이 가능한 메모리보다 훨신 더 크더라도 여전히 효과적이다.&lt;br&gt;
이 접근법은 디스크 쓰기가 순차적이기 때문에 LSM 트리가 매우 높은 쓰기 처리량을 보장할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;b-트리&#34;&gt;B 트리&lt;/h3&gt;
&lt;p&gt;로그 구조화 색인은 보편화 되고 있지만 일반적은 색인 유형이 아니다. 가장 널리 사용되는 색인 구조가 **B 트리(B-Tree)**로 구조가 로그 구조화 색인과는 상당히 다르다.&lt;/p&gt;
&lt;p&gt;B 트리는 1970년에 등장하여 오래동안 테스트되어 왔다. B-tree 인덱스는 RDB, NoSQL 모두 사용된다.&lt;br&gt;
SS 테이블과 같이 키로 정렬된 키-값을 유지하기 때문에 키-값 검색과 범위 질의에 효과적이다. 로그 구조화 색인 비슷한 점이 이거 뿐이다.&lt;/p&gt;
&lt;p&gt;로그 구조화 색인은 세그먼트로 나누고 항상 순차적으로 세그먼트에 기록하는 방식이지만, B-Tree 는 4KB 크기(때로는 더 큰)의 고정 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기 또는 쓰기를 한다.&lt;br&gt;
디스크가 고정 크기 블록으로 배열되기 때문에 하드웨어와 더 밀접한 관련이 있다.&lt;/p&gt;
&lt;p&gt;각 페이지는 주소나 위치를 통해 식별할 수 있고, 이 방식 때문에 다른 페이지를 참조할 수도 있다(포인트와 비슷하지만 메모리 대신에 디스크에 있다).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_6.png&#34; alt=&#34;그림 3-6&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-6. B 트리 색인을 이용한 key 검색(각 페이지가 다른 페이지를 참조하는 모습을 묘사함)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;한 페이지가 B 트리의 루트(root) 로 지정된다. 위 예제에서 보면 키 251을 찾기 위해 루트의 200~300 경계 사이의 페이지 참조를 따라가고, 다시 더 작은 범위로 나눈 페이지로 이동한다.&lt;br&gt;
최종적으로 개별 키(leaf page)를 포함한 페이지에 도달한다.&lt;/p&gt;
&lt;p&gt;B 트리의 한 페이지에서 하위 페이지를 참조(ref)하는 수를 분기 계수(branching factor)라고 부른다. 위 예제에서의 분기 계수는 6이다. 실제로 분기 계수는 페이지 참조와 범위 경계를 저장하는데 보통 수백 개에 달한다.&lt;/p&gt;
&lt;p&gt;B 트리에 존재하는 키의 값의 값을 갱신하려면, 키를 포함하고 있는 리프(leaf) 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다.&lt;br&gt;
새로운 키를  추가하려면, 새로운 키의 범위를 포함하는 페이지를 찾아 해당 페이지에 키와 값을 추가한다.&lt;br&gt;
새로운 키를 수용한 페이지에 충분한 공간이 없다면, 페이지를 반쯤 채워 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분을 알 수 있게 갱신하는 작업을 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_7.png&#34; alt=&#34;그림 3-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-7. 페이지 분리로 커진 B-Tree&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이 알고리즘은 트리가 계속 균형을 유지하는 것을 보장한다. n개의 키를 가진 B 트리는 깊이가 항상 O(logn) 이다. 대부분 DB에서 깊이는 3~4 단계면 충분하다.&lt;br&gt;
분기 계수 500의 4KB페이지의 4단계 트리는 256TB 까지 저장할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_Time-complexity.png&#34; alt=&#34;시간 복잡도&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. 시간 복잡도&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;신뢰할-수-있는-b트리-만들기-making-b-trees-reliable&#34;&gt;신뢰할 수 있는 B트리 만들기 (Making B-trees reliable)&lt;/h4&gt;
&lt;p&gt;B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상 페이지에 덮어쓴다. 이 동작은 덮어 쓰기가 페이지 위치를 변경하지 않는다고 가정한다. 페이지를 덮어 쓴다고 해도 페이지를 가리키는 참조는 온전하게 남는다.&lt;/p&gt;
&lt;p&gt;LSM 트리와 같은 로그 구조화 색인과는 대조적이다. 로그 구조화는 색인 파일을 추가할 뿐 같은 같은 위치의 파일은 변경하지 않는다.&lt;/p&gt;
&lt;p&gt;디스크 페이지를 덮어쓰는 일은 실제 H/W 동작이라 생각할 수 있다. SSD의 경우는 칩의 상당한 블록을 한번에 지우고 다시 쓰기를 해야하기 때문에 조금 더 복잡하다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;데이터 고장시 복구&lt;/strong&gt;&lt;br&gt;
일부 페이지만 기록하고 데이터베이스가 고장이 난다면 결국 색인이 훼손되기 때문에 매우 위험하다.&lt;/p&gt;
&lt;p&gt;데이터베이스가 고장이 난 상황에 스스로 복구하게 하려면, 쓰기전 로그(Write-ahead log, WAL, (재실행 로그, redo log)라고도 함)라는 데이터 구조를 추가 B-Tree를 구현한다.&lt;/p&gt;
&lt;p&gt;쓰기 전 로그는 B-Tree의 변경 사항을 기록하는 추가 전용(append-only) 파일이다. 이 로그는 고장 이후 복구될 때 일관성 있게 B-Tree를 복원하는 데 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동시성 제어&lt;/strong&gt;&lt;br&gt;
다중 스레드가 동시에 B-Tree에 접근한다면 주의 깊게 동시성 제어를 해야하는데, 이때 랜치(latch, 가벼운 잠금(lock))로 트리를 보호한다.&lt;/p&gt;
&lt;p&gt;로그 구조화 접근 방식은 이 상황에서 더 간단하다. 유입 질의에 간섭 없이 백그라운드에서 모든 병합를 수행하고 이따금 원자적으로 새로운 새그먼트 이전 세그먼트로 바꾸기 때문이다.&lt;/p&gt;
&lt;h4 id=&#34;b-트리-최적화-b-tree-optimizations&#34;&gt;B 트리 최적화 (B-tree optimizations)&lt;/h4&gt;
&lt;p&gt;B 트리는 오랜 동안 사용되면서 개발된 많은 최적화 기법이 있다. 몇가지를 언급하자면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 덮어쓰기와 WAL을 유지하는 대신, 쓰기 시 복사 방식(copy-on-write scheme)을 사용한다. 변경된 페이지는 다른 위치에 기록하고 트리 상위 페이지의 새로운 버젼을 만들어 새로운 위치를 가리킨다.
&lt;ul&gt;
&lt;li&gt;동시성 제어에 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;페이지에 전체 키를 저장하는 것이 아니라 키를 축약해 쓰면 공간을 절약할 수 있다. 페이지 하나에 키를 더 많이 채워 더 높은 분기 계수를 얻는다.
&lt;ul&gt;
&lt;li&gt;leaf 를 찾는 깊이 수준을 낮출 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;페이지는 디스크 상 어디든지 존재할 수 있다. 하지만 leaf 페이지 만큼은 디스크 상 연속된 순서로 나타나게끔 트리를 배치하려 시도한다.(하지만 트리가 커진다면 어렵다)
&lt;ul&gt;
&lt;li&gt;로그 구조화 기반과 비교하면, 병합과 압축 과정에서 세그먼트를 다시 쓰기 때문에 연속된 키를 더 가깝게 유지하기 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;트리에 포인터를 추가하여, 상위 페이지로 이동하지 않고 형제 페이지로 바로 이동하게 만들 수 있다.&lt;/li&gt;
&lt;li&gt;프랙탈 트리(fratal tree)와 같은 B 트리 변형은 디스크 찾기를 줄이기 위해 로그 구조화 개념을 일부 빌렸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;b-트리와-lsm-트리-비교&#34;&gt;B 트리와 LSM 트리 비교&lt;/h3&gt;
&lt;p&gt;B 트리가 LSM 트리보다 일반적으로 구현 성숙도가 더 높지만 LSM 트리도 그 성능 특성 때문에 여전히 관심을 받는다.&lt;/p&gt;
&lt;p&gt;LSM은 쓰기에 빠르고 B-tree 는 읽기에 더 빠르다. 읽기가 보통 LSM 트리에서 더 느린 이유는 컴팩트 단계에 있는 여러 데이터 구조와 SS 테이블을 확인해야 하기 때문이다.&lt;/p&gt;
&lt;h4 id=&#34;lsm-트리의-장점-advantages-of-lsm-trees&#34;&gt;LSM 트리의 장점 (Advantages of LSM-trees)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;B-Tree
&lt;ul&gt;
&lt;li&gt;색인은 모든 데이터 조각을 최소한 두번 기록한다.
&lt;ul&gt;
&lt;li&gt;쓰기 전 로그(WAL)에 한번, 트리 페이지에 한번(페이지가 분리될 때 다시 기록) 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;해당 페이지 내 몇 byte 만 바뀌어도 전체 페이지를 기록해야 하는 오버헤드가 존재하기도 한다.&lt;/li&gt;
&lt;li&gt;일부 엔진은 전원 장애가 발생했을 때 일부만 갱신된 페이지로 끝나지 않게 두번 덮어 쓴다.(innoDB)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LSM (로그 구조화 색인)
&lt;ul&gt;
&lt;li&gt;SS테이블의 반복된 compaction, merge 로 여러번 다시쓴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이렇게 한번 쓸때 여러번 쓰는 작업을 쓰기 증폭(write amplification)이라 하는데, SSD의 경우 블록에 덮어 쓰기 횟수가 정해져 있기 때문에 쓰기 증폭은 특별한 관심사 이다.&lt;/p&gt;
&lt;p&gt;쓰기가 많은 애플리케이션에서 디스크의 쓰기 증폭이 성능에 중요한 영향을 미친다.(저장소 엔진이 기록할수록 디스크 대역폭 내 초당 쓰기는 점점 줄어든다)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LSM 트리는 B 트리보다 쓰기 처리량을 높게 유지할 수 있다.
&lt;ul&gt;
&lt;li&gt;컴팩트과 병합 작업 때문에 B 트리에 비해 쓰기 증폭이 낮다. 특히 HDD 라면 순차 쓰기가 임의 쓰기 보다 훨씬 더 빠르기 때문에 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LSM 트리는 압축률이 좋다.
&lt;ul&gt;
&lt;li&gt;B 트리보다 더 적은 파일을 생성한다.&lt;/li&gt;
&lt;li&gt;B tree 는 파편화로 인해 디스크 공간 일부가 남는다. (일부 공간을 사용하지 않음)&lt;/li&gt;
&lt;li&gt;SS테이블을 다시 기록하면서 저장소 오버헤드가 낮다.&lt;/li&gt;
&lt;li&gt;이 장점은 SSD 에서도 유리하다(SSD는 임의 쓰기를 순차 쓰기로 전환할때 LSM 알고리즘을 사용한다)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;lsm-트리의-단점-downsides-of-lsm-trees&#34;&gt;LSM 트리의 단점 (Downsides of LSM-trees)&lt;/h4&gt;
&lt;p&gt;LSM 트리의 단점은 캠팩트 과정으로 인해 읽기와 쓰기의 성능에 영향을 준다.&lt;/p&gt;
&lt;p&gt;디스크가 가진 자원은 한계가 있다. 그래서 디스크에서 값 비싼 컴팩트 연산이 끝날 때까지 요청이 대기해야 하는 상황이 발생하기 쉽다.&lt;/p&gt;
&lt;p&gt;물론 처리량과 평균 응답 시간이 성능에 주는 영향은 작지만, 백분위로 비교하면 종종 매우 길어지는 시간이 존재한다.&lt;/p&gt;
&lt;p&gt;반면, B 트리의 성능은 상대적으로 예측하기 쉽다.&lt;/p&gt;
&lt;p&gt;쓰기 처리량이 높다 하더라도 설정을 주의 깊게 하지 않으면 컴팩션이 유입 속도를 따라가지 못하는 경우가 발생한다. 유입 속도에 맞춰 컴팩션이 줄어드는것이 아니기 때문에 이런 상황을 감지하기 위한 명시적인 모니터링이 필요하다.&lt;/p&gt;
&lt;p&gt;또한, 키의 다중 복사본이 여러 세그먼트에 존재할 수 있다. B 트리는 이것이 한 곳에 모여 있기 때문에 강력한 트랜잭션 시멘틱(semantic)을 제공하는 데이터베이스는 B 트리가 더 매력적일 수 밖에 없다(제세한 내용은 7장).&lt;/p&gt;
&lt;p&gt;요즘 나오는 저장소는 LSM 방식을 많이 채택하는데 그럼에도 불구하고 많은 작업 부하에 B 트리는 지속적으로 좋은 성능을 나타내기 때문에 사라질 가능성은 거의 없다.&lt;/p&gt;
&lt;h3 id=&#34;기타-색인-구조-other-indexing-structures&#34;&gt;기타 색인 구조 (Other Indexing Structures)&lt;/h3&gt;
&lt;p&gt;키-값 색인의 대표적인 예는 관계형 모델의 기본키(Primary key, PK) 색인이다.&lt;/p&gt;
&lt;p&gt;기본키로 아래와 같이 각 데이터베이스마다 Row/Document/Vertex 고유하게 식별하고 참조할 수 있다.&lt;/p&gt;
&lt;p&gt;색인은 이런 참조를 찾아 때 사용한다.&lt;/p&gt;
&lt;p&gt;보조 색인(secondary index)을 사용하기도 한다.  기본키와의 차이점은 키가 고유하지 않는다는 것이다. 즉, 같은 키를 가진 많은 로우(문서, 정점)가 있을 수 있다.&lt;/p&gt;
&lt;p&gt;이를 해결할 방법으로 색인의 각 값에 일치하는 row 식별자 목록을 만드는 방법 또는 row 식별자를 추가해서 각 키를 고유하게 만드는 방법이 있다.(대리키)&lt;/p&gt;
&lt;p&gt;어느 쪽이든 보조 색인으로 B 트리와 로그 구조화 색인(LSM) 둘 다 사용할 수 있다.&lt;/p&gt;
&lt;h4 id=&#34;색인-안에-값-저장하기-storing-values-within-the-index&#34;&gt;색인 안에 값 저장하기 (Storing values within the index)&lt;/h4&gt;
&lt;p&gt;색인에서 키는 질의가 검색하는 대상이지만, 값은 다음의 두 가지 중에 하나에 해당한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;값은 질문의 실제 Row(document, vertex)이다.&lt;/li&gt;
&lt;li&gt;다른 곳에 저장된 Row를 가리키는 참조(reference)이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;다른 곳을 가리키는 참조가 가리키는 곳을 **힙 파일(heap file)**이라 하는데 특정 순서 없이 데이터를 저장한다(tombstone을 기록할 수도 있다).&lt;/p&gt;
&lt;p&gt;힙 파일 방식을 선택하는 이유는 여러 보조 색인이 존재할 때 데이터 중복을 피할 수 있다. 각 색인은 힙 파일에서 위치만 참조하고 데이터는 일정한 곳에 유지한다.&lt;/p&gt;
&lt;p&gt;힙 파일 접근 방식은 키를 변경하지 않고 값만 갱신할 때 효과적이다.&lt;/p&gt;
&lt;p&gt;변경 될 데이터의 크기가 기존보다 작거나 같다면 record 를 그 자리에 덮어 쓸 수 있다.&lt;/p&gt;
&lt;p&gt;하지만, 크다면 새로운 곳으로 위치를 이동해야 하기 때문에 더 복잡하다. 이는 레코드의 새로운 힙 위치를 가리키게끔 갱신하거나 이전 힙 위치에 포인터를 남겨둬야 하기 때문이다.&lt;/p&gt;
&lt;p&gt;색인에서 힙 파일로 다시 이동하는 일은 읽기 성능에 불이익이 너무 많기 때문에, 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직하다. 이를 **클러스터드 색인(clustered index)**이라고 한다.&lt;/p&gt;
&lt;p&gt;MySQL의 InnoDB의 경우 PK는 언제나 clustered index 이고 보조 색인은 기본키를 참조한다.&lt;/p&gt;
&lt;p&gt;클러스터드 색인과 비-클러스터드 색인(non-clustered index) 사이의 절충안을 &lt;strong&gt;커버링 색인(covering index)&lt;/strong&gt; 혹은 **포괄열이 있는 색인(index with included column)**이라고 한다.&lt;/p&gt;
&lt;p&gt;이 색인은 색인(index) 안에 테이블의 컬럼일부를 저장한다. 이렇게 하면 색인만 사용해 일부 query 응답이 가능하다(색인이 질의를 cover 했다고 말함)&lt;/p&gt;
&lt;p&gt;클러스터드 색인과 커버링 색인은 읽기 성능을 높일 수 있지만, 추가적인 저장소가 필요하고 쓰기 과정에서 오버헤드가 발생한다.&lt;/p&gt;
&lt;h4 id=&#34;다중-칼럼-색인-multi-column-indexes&#34;&gt;다중 칼럼 색인 (Multi-column indexes)&lt;/h4&gt;
&lt;p&gt;다중 컬럼에 동시에 질의할 때 **결합 색인(concatenated index)**을 사용한다. 하나의 컬럼에 다른 컬럼을 추가하는 방식으로 하나의 키에 여러 필드를 결합하는 것이다.&lt;/p&gt;
&lt;p&gt;전화번호부와 유사하게 (성, 이름)이 순서가 정렬된 경우에 특정 성을 가진 사람을 찾거나, 특정 성 이름 조합으로 모든 사람을 찾을 때는 이 색인을 사용할 수 있지만,&lt;/p&gt;
&lt;p&gt;특정 이름을 가진 모든 사람을 찾을 때는 쓸모가 없다.&lt;/p&gt;
&lt;p&gt;다차원 색인은 지리 공간 데이터에 중요하게 사용되는데, 경위도에 대해 다음과 같은 이차원 범위 질의가 필요하다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;select&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;from&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;restaurants&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;where&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;latitude&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;51&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;4946&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;and&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;latitude&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;51&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;5079&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;and&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;longitude&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1162&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;and&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;longitude&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1004&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;B 트리나 LSM 는 이러한 색인 유형에 효율적으로 응답할 수 없다.&lt;/p&gt;
&lt;p&gt;한가지 방법은 &lt;a href=&#34;https://en.wikipedia.org/wiki/Space-filling_curve&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2차원 위치를 공간 채움 곡선(space-filling curve)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 을 이용해 단일 숫자로 변환하여 B 트리 색인을 하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_Space-filling-curve.png&#34; alt=&#34;Space-filling curve&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. Space-filling curve&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;좀 더 일반적인 방식은 PostGIS와 같이 R 트리처럼 전문 공간 색인(specialized spatial index)을 사용하는 것이다.&lt;/p&gt;
&lt;p&gt;그밖에 다차원 색인은 여러 곳에서 활용된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전자 상거래 웹 사이트에서 특정 색상을 위해 (빨강, 초록, 파랑)의 3차원 색인&lt;/li&gt;
&lt;li&gt;날씨 관측 데이터베이스에서 2013년에 기혼이 25도에서 40도 사이인 모든 관측을 찾기 위해(날짜, 기온)의 2차원 색인&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;전문-검색-색인과-퍼지-색인-full-text-search-and-fuzzy-indexes&#34;&gt;전문 검색 색인과 퍼지 색인 (Full-text search and fuzzy indexes)&lt;/h4&gt;
&lt;p&gt;지금까지는 키의 정환한 값이나 정렬된 키의 값의 범위를 질의할 수 있다고 가정한다. 하지만, 철자가 틀린 단어와 같이 유사한 혹은 애매모호한(fuzzy) 질의에는 다른 기술이 필요하다.&lt;/p&gt;
&lt;p&gt;예를 들어, 전문 검색 엔진은 단어를 검색할 때 단어의 동의어로 질의를 확장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단어의 문법적 활용을 무시하고 동일한 문서에서 서로 인접해 나타난 단어를 검색&lt;/li&gt;
&lt;li&gt;언어학적으로 텍스트를 분석해 사용하는 등 다양한 기능을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;루씬은 문서나 질의의 오타에 대처하기 위해 특정 편집 거리(edit distance) 내 단어를 검색할 수 있는 기능이 있다. 앞서 설명 했듯 루씬은 SS 테이블 같은 구조를 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_finite-state-automation.png&#34; alt=&#34;Space-filling curve&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. 유한 상태 오토마톤 (finite state automation)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;SS테이블은 인메모리 색인이 필요한데 루씬에서 인메모리 색인은 여러 키 내 문자에 대한 유한 상태 오토마톤으로 트라이(trie)와 유사한 메모리 색인을 사용한다.&lt;/p&gt;
&lt;p&gt;그밖에 퍼지 검색 기술은 문서 분류 및 머신머닝의 방향으로 진행되고 있다.&lt;/p&gt;
&lt;h4 id=&#34;모든-것을-메모리에-보관-keeping-everything-in-memory&#34;&gt;모든 것을 메모리에 보관 (Keeping everything in memory)&lt;/h4&gt;
&lt;p&gt;지금까지는 설명한 데이터 구조는 디스크 한계에 대한 해결책이었다. 디스크는 메인 메모리보다 비교해 다루기 어렵다. 디스크와 SSD를 사용할 때 읽기 쓰기에 좋은 성능을 원한다면, 주의해서 데이터를 디스크(HDD, SSD)에 배치해야 한다.&lt;/p&gt;
&lt;p&gt;이러한 불편함에도 불구하고 디스크를 선택하는 이유는 &lt;strong&gt;지속성&lt;/strong&gt;과 &lt;strong&gt;가격&lt;/strong&gt; 때문이다.&lt;/p&gt;
&lt;p&gt;램(ram)이  점점 저렴해지기 때문에 가격 논쟁은 약해졌다. 데이터셋 대부분은 충분히 크지 않기 때문에 메모리에 전체를 보관하는 방식도 꽤 현실적이고, 여러 장비간 분산해서 보관할 수도 있다.&lt;/p&gt;
&lt;p&gt;이런 이유로 인메모리 데이터베이스가 개발되었다.&lt;/p&gt;
&lt;p&gt;맴캐시드 같은 경우는 데이터 손실을 허용하는 캐시 용도로만 사용되지만, 다른 인메모리 DB는 지속성을 목표로 하여 배터리 전원을 공급 RAM 과 같은 특수 장비를 사용하거나 디스크를 함께 사용하여 주기적인 snapshot을 만드는 방식으로 지속성 문제를 해결한다.&lt;/p&gt;
&lt;p&gt;인메모리 DB가 재시작 되는 경우 특수 장비를 사용하지 않는다면 지속성을 위한 추가 전용(append-only) 로그와 함께 사용한다. 인메모리는 디스크에 데이터가 저장되더라도 읽기는 전적으로 메모리에서 제공된다.&lt;/p&gt;
&lt;p&gt;디스크 상의 파일은 쉽게 백업이 가능하고, 외부 유틸을 사용해 검사와 분석도 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VoltDB, MemSQL, Oracle TimeTen
&lt;ul&gt;
&lt;li&gt;관계형 모델의 인메모리 데이터베이스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ram Cloud
&lt;ul&gt;
&lt;li&gt;지속성 있는 오픈소스 인메모리 키-값 저장소&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Redis, Couchbase
&lt;ul&gt;
&lt;li&gt;비동기로 디스크에 기록하기 때문에 약한 지속성 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;직관에 어긋나지만, 인메모리 DB의 성능 장점은 디스크에서 읽지 않아도 되기 때문이 아니다. 심지어 OS가 최근에 사용한 디스크 블럭을 메모리에 캐시하기 때문에 충분한 메모리를 가진 경우 디스크 기반 저장소도 디스크 에서 데이터를 읽지 않기도 한다.&lt;br&gt;
오히려 메모리의 데이터 구조를 디스크에 기록하기 위해 부호화 하는 과정의 오버헤드를 피할 수 있기 때문에 더 빠를 수도 있다.&lt;/p&gt;
&lt;p&gt;성능 이외에도 인메모리 데이터베이스는 디스크 기반의 색인이 제공하지 못하는 데이터 모델을 제공한다. 예를들어, 레디스는 우선 순위 큐와 셋(set) 같은 데이터 구조를 데이터베이스의 인터페이스로 제공하기 때문에 구현이 간단하다.&lt;/p&gt;
&lt;p&gt;최근 연구에서는 인메모리 데이터베이스 아키텍쳐가 디스크 중심 아키텍쳐에서 발생하는 오버헤드를 제거하고 가용한 메모리 보다 큰 데이터셋(dataset)을 지원하게끔 확장할 수 있다.&lt;br&gt;
소희 안티 캐싱(anti-caching)은 메모리가 충분하지 않을 때 사용하는데 최근에 사용하지 않는 데이터를 디스크로 내보내고 나중에 다시 접근할 때 메모리에 적재하는 방식으로 동작한다(위의 설명이 anti-caching을 의미한다).&lt;br&gt;
이는 운영 체제가 가상 메모리와 swap 파일에서 수행하는 방식이 유사하지만, 데이터베이스는 전체 메모리 페이지보다 개별 레코드 단위로 작업하기 때문에 OS 보다 더 효율적으로 메모리를 관리할 수 있다.&lt;br&gt;
하지만 이 접근 방식은 여전히 전체 색인이 메모리에 있어야 한다.&lt;/p&gt;
&lt;h2 id=&#34;트랜젝션-처리나-분석&#34;&gt;트랜젝션 처리나 분석?&lt;/h2&gt;
&lt;p&gt;초창기 비즈니스 모델은 논리 단위의 형태로 읽기와 쓰기 그룹을 나타내는 커머셜 트랜잭션(commercial transaction, 상거래)에 해당한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;금전 거래가 아닌 영역으로 데이터베이스가 확장됐어도 트랜잭션이란 용어는 변하지 않고 논리 단위 형태로서 읽기와 쓰기 그룹을 나타내고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;온라인 트랜잭션 처리(OnLine Transaction Processing, OLTP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;레코드가 사용자 입력을 기반으로 삽입되거나 갱신됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;온라인 분석 처리(OnLine Analytic Processing, OLAP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 분석 용도&lt;/li&gt;
&lt;li&gt;많은 수의 레코드를 스캔해 레코드당 일부 칼럼만 읽어 집계 통계를 계산
&lt;ul&gt;
&lt;li&gt;ex) 1월의 각 매장의 총 수익, 평소보다 많은 프로모션 기간의 바나나 판매량&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비즈니스 분석가가 작성하고 회사 경영진에게 제공해 의사결정을 돕는다.
&lt;ul&gt;
&lt;li&gt;비즈니스 인텔리전스(business intelligence)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;트랜잭션 처리와 분석 시스템의 특징 비교&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;특성&lt;/th&gt;
          &lt;th&gt;트랜잭션 처리 시스템(OLTP)&lt;/th&gt;
          &lt;th&gt;분석 시스템(OLAP)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;주요 읽기 패턴&lt;/td&gt;
          &lt;td&gt;질의당 적은 record, 키 기준 fetch&lt;/td&gt;
          &lt;td&gt;많은 record 에 대한 집계&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;주요 쓰기 패턴&lt;/td&gt;
          &lt;td&gt;임의 접근, 사용자 입력을 낮은 지연 시간&lt;/td&gt;
          &lt;td&gt;대규모 불려오기(bulk import, ETL), 이벤트 스트림(event stream)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;주요 사용처&lt;/td&gt;
          &lt;td&gt;웹 앱, 사용자, 소비자	의사 결정을 위한 내부 분석가&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터 표현	데이터의 최신 상태(현재 시점, 실시간)	시간이 지나며 발생된 이력(과거)&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터셋 크기&lt;/td&gt;
          &lt;td&gt;기가바이트에서 테라바이트&lt;/td&gt;
          &lt;td&gt;테라바이트에서 페타바이트&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;최적화 방법&lt;/td&gt;
          &lt;td&gt;트랜잭션 효율화, 무결성의 극대화	조회 속도, 정보의 가치, 편의성&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터의 특성&lt;/td&gt;
          &lt;td&gt;트랜잭션 중심&lt;/td&gt;
          &lt;td&gt;정보 중심&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;처음에는 트랜잭션 처리와 분석 질의를 위해 동일한 데이터베이스를 사용했다.&lt;/li&gt;
&lt;li&gt;개별 데이터베이스를 데이터 웨어하우징(Data warehouse)라고 불렸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터-웨어하우징&#34;&gt;데이터 웨어하우징&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스&lt;/li&gt;
&lt;li&gt;회사 내의 모든 다양한 OLTP 시스템에 있는 데이터의 읽기 전용 복사본&lt;/li&gt;
&lt;li&gt;개별 데이터 웨어하우스를 사용하면 분석 접근 패턴에 맞게 최적화 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ETL(Extract-Transform-Load)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OLTP 데이터베이스에서 데이터를 추출(extract)하고&lt;/li&gt;
&lt;li&gt;분석 친화적인 스키마로 변환(transform)하고&lt;/li&gt;
&lt;li&gt;데이터 웨어하우스에 적재(load)한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_8.png&#34; alt=&#34;그림 3-8&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-8. 데이터 웨어하우스에 대한 ETL의 간략한 개요&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;oltp-데이터베이스와-데이터-웨어하우스의-차이점-the-divergence-between-oltp-databases-and-data-warehouses&#34;&gt;OLTP 데이터베이스와 데이터 웨어하우스의 차이점 (The divergence between OLTP databases and data warehouses)&lt;/h4&gt;
&lt;p&gt;표면적으로 데이터 웨어하우스와 관계형 OLTP 데이터베이스는 둘 다 SQL 질의 인터페이스를 지원하기 떄문에 비슷해보인다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하지만 각각 매우 다른 질의 패턴에 맞게 최적화됐기 때문에 시스템의 내부는 완전히 다르다.&lt;/li&gt;
&lt;li&gt;공통 SQL 인터페이스로 접근할 수 있는 저장소와 질의 엔진으로 점점 분리되고 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;상용 라이선스 데이터 웨어하우스 벤더&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테라데이터(Teradata)&lt;/li&gt;
&lt;li&gt;버티카(Vertica)&lt;/li&gt;
&lt;li&gt;SAP 하나&lt;/li&gt;
&lt;li&gt;파르에이셀(ParAccel)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;오픈소스 SQL 온 하둡(SQL-on-Hadoop)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아파치 하이브(Apache Hive)&lt;/li&gt;
&lt;li&gt;스파크 SQL(Spark SQL)&lt;/li&gt;
&lt;li&gt;클라우데라 임팔라(Cloudera Impala)&lt;/li&gt;
&lt;li&gt;페이스북 프레스토(Facebook Presto)&lt;/li&gt;
&lt;li&gt;아파치 타조(Apache Tajo)&lt;/li&gt;
&lt;li&gt;아파치 드릴(Apache Drill)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_sql-on-hadoop.png&#34; alt=&#34;Sql on Hadoop&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼. Sql on Hadoop&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;분석용-스키마-별-모양-스키마와-눈꽃송이-모양-스키마-stars-and-snowflakes-schemas-for-analytics&#34;&gt;분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마 (Stars and Snowflakes: Schemas for Analytics)&lt;/h3&gt;
&lt;p&gt;별 모양 스키마(star schema - 차원 모델링 dimensional modeling)로 알려진 정형화된 방식을 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사실 테이블(fact table)이 가운데에 있고 차원 테이블로 둘러싸고 있는 모양&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_9.png&#34; alt=&#34;그림 3-9&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-9. 데이터 웨어하우스에서 사용하는 별 모양 스키마 예제&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;사실 테이블(fact table): fact_sales&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;특정 시각에 발생한 이벤트(제품 구매)
사실 테이블의 다른 컬럼은 차원 테이블(dimension table)이라 부르는 다른 테이블을 가리키는 외래 키 참조다&lt;/p&gt;
&lt;p&gt;차원은 이벤트의 속성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;누가(dim_customer)&lt;/li&gt;
&lt;li&gt;언제(dim_date)&lt;/li&gt;
&lt;li&gt;어디서(dim_store)&lt;/li&gt;
&lt;li&gt;무엇을(dim_product)&lt;/li&gt;
&lt;li&gt;어떻게(dim_promotion) ??&lt;/li&gt;
&lt;li&gt;왜&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위에 그림에서 상품 정보(dim_product)는 아래 테이블과 같다.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;product_sk&lt;/th&gt;
          &lt;th&gt;stock-keeping unit, SKU&lt;/th&gt;
          &lt;th&gt;description&lt;/th&gt;
          &lt;th&gt;brand_name&lt;/th&gt;
          &lt;th&gt;category&lt;/th&gt;
          &lt;th&gt;&amp;hellip;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;제품 키&lt;/td&gt;
          &lt;td&gt;재고 관리 코드&lt;/td&gt;
          &lt;td&gt;설명&lt;/td&gt;
          &lt;td&gt;브랜드 이름&lt;/td&gt;
          &lt;td&gt;범주&lt;/td&gt;
          &lt;td&gt;그밖에&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;31&lt;/td&gt;
          &lt;td&gt;KA9511&lt;/td&gt;
          &lt;td&gt;해산물&lt;/td&gt;
          &lt;td&gt;아쿠아테크&lt;/td&gt;
          &lt;td&gt;애완용품&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;fact_sales 테이블의 각 로우는 특정 트랙잭션에서 제품이 판매되었는지 나타내기 위해 외래키를 사용한다.&lt;br&gt;
여러 다양한 제품을 동시에 구매함녀 사실 테이블에는 개별 로우로 표시된다.&lt;br&gt;
심지어 날짜, 시간 등을 모두 차원 테이블(dimension table) 을 통해 표현한다. 이러한 차원 테이블은 추가적인 정보를 부호화할 수 있고 휴일과 평일의 판매 차이를 질의할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;눈꽃송이 모양 스키마(snowflake schema)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;별 모양 스키마의 변형이다.&lt;/li&gt;
&lt;li&gt;차원이 하위차원으로 더 세분화된다.
&lt;ul&gt;
&lt;li&gt;질의를 수행하기 위해서 더 많은 조인을 필요 → 검색의 효과를 감소 → 시스템의 성능에 악영향을 끼칠 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터웨어하우스는 설계에 있어서 스타스키마 만큼 널리 쓰이지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_star-schema.jpg&#34; alt=&#34;Star schema&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. Star schema&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_Snowflake-schema-example.png&#34; alt=&#34;Snowflake schema example&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. Snowflake schema example&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;컬럼-지향-저장소-column-oriented-storage&#34;&gt;컬럼 지향 저장소 (column-Oriented Storage)&lt;/h2&gt;
&lt;p&gt;데이터 웨어하우스의 사실 테이블에는 엄청난 개수의 로우의 페타바이트 데이터가 있다면 효율적으로 저장하고 질의하기에는 어려운 문제가 있다.&lt;/p&gt;
&lt;p&gt;Large Data Means?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1000 Kilobytes = 1 Megabyte&lt;/li&gt;
&lt;li&gt;1000 Megabytes = 1 Gigabyte&lt;/li&gt;
&lt;li&gt;1000 Gigabytes = 1 Terabyte&lt;/li&gt;
&lt;li&gt;1000 Terabytes = 1 Petabyte&lt;/li&gt;
&lt;li&gt;1000 Petabytes = 1 Exabyte&lt;/li&gt;
&lt;li&gt;1000 Exabytes = 1 Zettabyte&lt;/li&gt;
&lt;li&gt;1000 Zettabytes = 1 Yottabyte&lt;/li&gt;
&lt;li&gt;1000 Yottabytes = 1 Bronobyte&lt;/li&gt;
&lt;li&gt;1000 Bronobytes = 1 Geobyte&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_Floppy-disk.jpg&#34; alt=&#34;플로피 디스크&#34;&gt;&lt;br&gt;
&lt;em&gt;그림. 플로피 디스크&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8인치: 250KB&lt;/li&gt;
&lt;li&gt;5.25인치: 500KB ~ 1.2MB&lt;/li&gt;
&lt;li&gt;3.5인치: 1.44MB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일반적으로 데이터 웨어하우스에서 한번에 4, 5개의 컬럼만 접근한다 (SELECT * 를 사용하는 일은 거의 없다)&lt;/p&gt;
&lt;p&gt;사람들이 요일에 따라 신선 과일을 사고싶어하는지 사탕을 더 사고싶어 하는지 분석하기&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SELECT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_date&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;weekday&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_product&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;category&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SUM&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fact_sales&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;quantity&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AS&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;quantity_sold&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fact_sales&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;JOIN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_date&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;       &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fact_sales&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;date_key&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_date&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;date_key&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;JOIN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_product&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fact_sales&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;product_sk&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_product&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;product_sk&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_data&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;year&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2013&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AND&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;product&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;category&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;IN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;fresh fruit&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;Candy&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;GROUP&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;BY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;     &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_date&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;weekday&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;dim_product&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;category&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;대부분의 OLTP 데이터베이스에서 저장소&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로우 지향 방식으로 데이터를 배치한다.&lt;/li&gt;
&lt;li&gt;데이틀에 한 로우의 모든 값은 서로 인접하게 저장된다.
&lt;ul&gt;
&lt;li&gt;문서 데이터베이스와 유사하다. 문서 데이터베이스는 전체 문서를 보통 하나의 연속된 바이트 열로 저장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;fact_sales 에서 3개의 컬럼에만 접근한고 했을 때, &lt;em&gt;date_key&lt;/em&gt;, &lt;em&gt;product_sk&lt;/em&gt; 둘 중하나에만 색인이 있다고 가정하자.&lt;/p&gt;
&lt;p&gt;이 색인은 저장소 엔진에 &lt;em&gt;특정 날짜&lt;/em&gt;나 &lt;em&gt;특정 제품&lt;/em&gt;의 모든 판매 내용을 찾을 수 있는 위치를 알려준다.&lt;/p&gt;
&lt;p&gt;하지만 위와 같은 질의를 처리하기 위해서는 &lt;strong&gt;디스크에서 100개 이상의 속성을 포함하는 로우(row)를 모두 메모리에 적재&lt;/strong&gt;하고,&lt;/p&gt;
&lt;p&gt;구문을 분석하여 필요한 조건을 충족하는 로우를 필터링 하는 방식으로 대응하는데 이것은 &lt;strong&gt;시간이 너무 오래걸린다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;컬럼 지향 저장소&lt;/strong&gt;의 개념은 모든 값을 하나의 로우에 저장하지 않고 모든 값(column)을 함께 저장한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 칼럼은 개별 파일에 저장하면 질의에 필요한 칼럼만 읽고 구문 분석할 수 있다.&lt;/li&gt;
&lt;li&gt;각 칼럼 파일에 포함된 로우가 모두 순서가 같아야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_10.png&#34; alt=&#34;그림 3-10&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-10. 관계형 데이터를 로우 단위가 아닌 컬럼 단위로 저장&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;컬럼 지향 저장소 배치는 각 컬럼 파일에 포함된 로우가 모두 같은 순서인 점에 의존한다.&lt;br&gt;
예를 들면, 23번째 데이터를 모두 모으려면 컬럼별로 23번째에 해당하는 모든 데이터를 가져오면 된다.&lt;/p&gt;
&lt;h3 id=&#34;컬럼-압축&#34;&gt;컬럼 압축&lt;/h3&gt;
&lt;p&gt;데이터를 압축하면 디스크 처리량을 줄일 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컬럼 저장소는 대개 압축에 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컬럼의 데이터에 따라 다양한 압축 기법을 사용할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 웨어하우스에 효과적인 압축 중 비트맵 부호화(bitmap encoding)이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_11.png&#34; alt=&#34;그림 3-11&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-11. 압축된 단일 칼럼의 비트맵 저장소&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;보통 컬럼에서 고유 값의 수는 로우에 비해 적다.(판매되는 제품의 고유한 수가 10만개, 판매 거래는 수십억)&lt;/p&gt;
&lt;p&gt;그러면 n개의 고유 값을 가진 column(69,69,69,69,74,31,31&amp;hellip;) 을 가져와 n개의 개별 비트맵으로 변환하는데(product_sk 별 비트맵을 따로 가짐) 만약 row가 해당 값을 가지면 비트는 1이고 그렇지 않으면 0 이다.&lt;/p&gt;
&lt;p&gt;위와 같은 상황으로 보면 비트맵엔 0이 더 많은데 이것을 런 렝스(run-length) 부호화를 하여 한번 더 압축이 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;런 렝스 부호화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) AABBBBCC(8byte) → A2B4C2(6byte)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;where product_sk in (30, 68, 69)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;product_sk = 30, product_sk = 68, product_sk = 69 에 비트맵 3개를 적재하고 3개 비트맵의 비트를 or 로 계산한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;0&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;1&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;2&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;3&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;4&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;5&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;6&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;7&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;8&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;9&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;10&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;11&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;12&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;13&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;14&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;15&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;16&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;17&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;product_sk = 30&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;product_sk = 68&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;product_sk = 69&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;종합&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;where product_sk = 31 and store_sk = 3
&lt;ul&gt;
&lt;li&gt;product_sk = 31, store_sk = 3 으로 비트맵을 적재하고 and 계산한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;0&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;1&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;2&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;3&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;4&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;5&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;6&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;7&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;8&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;9&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;10&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;11&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;12&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;13&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;14&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;15&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;16&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;17&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;product_sk = 31&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;product_sk = 3&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;1&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;종합&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;0&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;이런 계산은 각 컬럼에 동일한 순서로 row 가 포함되기 때문에 가능하다.&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;B-Tree&lt;/th&gt;
          &lt;th&gt;Bitmap index&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;큰 분포도를 갖는 테이블에 적합&lt;/td&gt;
          &lt;td&gt;적은 분포도를 갖는 테이블에 적합&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;비교적 키의 갱신 비용이 적음&lt;/td&gt;
          &lt;td&gt;갱신 비용이 매우 큼&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;OR 사용 Query 비효율적&lt;/td&gt;
          &lt;td&gt;OR 사용 Query 효율적&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;OLTP에 유용함&lt;/td&gt;
          &lt;td&gt;Cardinality가 낮고 대량의 데이터에 대한 조회 작업이 많은 시스템에 유용함&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;비트맵 인덱스의 탄생 배경&lt;/p&gt;
&lt;p&gt;B-tree 가 가진 문제점을 해결하기 위해..&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B-tree 인덱스에서는 실제 칼럼 값을 보관: 대용량 데이터를 관리에는 부담&lt;/li&gt;
&lt;li&gt;결합 인덱스에서 조건을 사용하지 않는 칼럼이나 =(equals) 조건이 아닌 칼럼이 결합 인덱스 중간에 있으면 액세스 효율이 떨어짐&lt;/li&gt;
&lt;li&gt;다양한 액세스 패턴을 수용하기 위해 많은 인덱스가 필요할 수 있음&lt;/li&gt;
&lt;li&gt;NOT 이나 NULL을 사용하거나 복잡한 OR 조건에서는 인덱스의 성능을 보장받지 못함&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;BITMAP&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;INDEX&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;fact_sales&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;ON&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;sales&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;product_sk&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


칼럼 지향 저장소와 칼럼 패밀리

카산드라와 HBase는 빅테이블로부터 내려오는 칼럼 패밀리 개념이 있다.

하지만 이를 칼럼 지향적이라고 부르기에는 오해의 소지가 많다.

각 칼럼 패밀리 안에는 로우 키에 따라 로우와 모든 칼럼을 함께 저장하며 칼럼 압축을 사용하지 않는다.

따라서 빅테이블 모델은 여전히 대부분 로우 지향이다.
&lt;/div&gt;

&lt;h3 id=&#34;메모리-대역폭과-백터화-처리&#34;&gt;메모리 대역폭과 백터화 처리&lt;/h3&gt;
&lt;p&gt;수백만 로우를 스캔해야 하는 데이터 웨어하우스 질의는 디스크로부터 메모리로 데이터를 가져오는 대역폭이 큰 병목이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;분석용 데이터베이스 개발자는 메인 메모리에서 CPU 캐시로 가는 대역폭을 효율적으로 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클럭: 데이터를 보내는 빠르기&lt;/li&gt;
&lt;li&gt;대역폭: 한 번에 전송되는 데이터의 양&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU 명령 처리 파이프라인에서 분기 예측 실패(branch misprediction)와 버블(bubble)을 피해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_%E1%84%87%E1%85%AE%E1%86%AB%E1%84%80%E1%85%B5%E1%84%8B%E1%85%A8%E1%84%8E%E1%85%B3%E1%86%A8_4%E1%84%83%E1%85%A1%E1%86%AB%E1%84%80%E1%85%A8-%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%91%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB.png&#34; alt=&#34;분기예측 4단계 파이프라인&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼. 분기예측 4단계 파이프라인&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다음 실행될 조건문이 어떤 곳으로 분기할 것인지를 확실히 알게 되기 전에 미리 추측하여 실행하여 파이프라인 효율성 확보&lt;/li&gt;
&lt;li&gt;버블: 빈 공간&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;최신 CPU에서 단일 명령 다중 데이터(Single Instruction Multi Data, SIMD) 명령을 사용하게끔 신경 써야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIMD: CPU에서 지원되는 명령어 셋으로 하나의 명령어로 동일한 형태/구조의 여러 데이터를 한 번에 처리하는 병렬처리기법&lt;/li&gt;
&lt;li&gt;SISD(Single Instruction Single Data)&lt;/li&gt;
&lt;li&gt;4번의 연산과 1번의 연산
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/simd.png&#34; alt=&#34;SISD, SIMD&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;벡터화-처리&#34;&gt;벡터화 처리&lt;/h4&gt;
&lt;p&gt;한 번에 처리하는 데이터의 양을 늘려서 CPU 사용률을 높이고 처리속도를 빠르게 하는 기법
비트 AND와 OR같은 연산자는 압축된 칼럼 데이터 덩어리를 바로 연산할 수 있게 설계할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;컬럼-저장소의-순서-정렬&#34;&gt;컬럼 저장소의 순서 정렬&lt;/h3&gt;
&lt;p&gt;로우가 저장되는 순서가 중요하지는 않다.&lt;/p&gt;
&lt;p&gt;하지만 각 칼럼은 독립적으로 정렬하면 안되고 한 칼럼의 k번째 항목이 다른 칼럼 k번째 항목과 같은 로우에 속해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;그룹화, 필터링 용이
&lt;ul&gt;
&lt;li&gt;1차 정렬 키를 date_key 로 시간 범위 지정&lt;/li&gt;
&lt;li&gt;product_sk를 보조 정렬 키로 같은 날짜에 판매한 같은 제품 그룹화 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;칼럼 압축에 도움
&lt;ul&gt;
&lt;li&gt;기본 정렬 칼럼은 연속해서 같은 값이 연속해서 길게 반복된다.&lt;/li&gt;
&lt;li&gt;간단한 런 렝스 부호화는 수십억 개의 로우를 가진 테이블이라도 수 킬로바이트로 칼럼을 압축할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-순서-정렬&#34;&gt;다양한 순서 정렬&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터 복원력을 위해 데이터를 여러 장비에 복제
&lt;ul&gt;
&lt;li&gt;데이터마다 서로 다른 방식으로 정렬해서 저장 → 질의를 처리할 때 패턴에 적합한 버전 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컬럼 지향 저장에서 여러 정렬 순서를 갖는 것은 로우 지향 저장에서 2차 색인을 갖는 것과 약간 비슷하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로우 지향 저장
&lt;ul&gt;
&lt;li&gt;한 곳(힙 파일이나 클러스터 색인)에 모든 로우를 유지하고 2차 색인은 일치하는 로우를 가리키는 포인터만 포함한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;컬럼 저장 지장
&lt;ul&gt;
&lt;li&gt;일반적인 데이터를 가리키는 포인터가 없고, 단지 값을 포함한 컬럼만 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;칼럼-지향-저장소에-쓰기&#34;&gt;칼럼 지향 저장소에 쓰기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;칼럼 지향 저장소, 압축, 정렬은 모두 읽기에 더 빠르다.
&lt;ul&gt;
&lt;li&gt;제자리 갱신(update-in-place) 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;쓰기를 위한 해결책은 LSM 트리 구조가 적절하다.
&lt;ul&gt;
&lt;li&gt;쓰기 → 인메모리 저장소로 이동해 정렬된 구조에 추가 → 디스크에 쓸 준비&lt;/li&gt;
&lt;li&gt;디스크의 칼럼 파일에 병합하고 → 대량으로 새로운 파일에 기록&lt;/li&gt;
&lt;li&gt;ex) 버티카&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;집계-데이터-큐브와-구체화-뷰&#34;&gt;집계: 데이터 큐브와 구체화 뷰&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;구체화 집계(materialized aggregate)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;데이터 웨어하우스 질의는 보통 SQL에 COUNT, SUM, AVG, MIN, MAX 같은 집계 함수를 포함한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동일한 집계를 많은 많은 질의에서 사용한다면 매번 원시 데이터를 처리하는 일은 낭비다.&lt;/li&gt;
&lt;li&gt;질의 자주 사용하는 일부 카운트(count)나 합(sum)을 캐시하는 하는 방법중 하나는 구체화 뷰(materialized view)이다.&lt;/li&gt;
&lt;li&gt;구체화 뷰는 원본데이터의 복사본
&lt;ul&gt;
&lt;li&gt;원본 데이터를 변경하면 구체화 뷰를 갱신해야 함 → DB가 자동으로 수행&lt;/li&gt;
&lt;li&gt;비용이 비싸기 때문에 OLTP에서는 사용하지 않음&lt;/li&gt;
&lt;li&gt;데이터 웨어하우스는 읽기 비중이 크기 때문에 합리적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;데이터 큐브(data cube)&lt;/strong&gt; 또는 &lt;strong&gt;OLAP 큐브&lt;/strong&gt;라고 알려려진 구체화 뷰는 일반화된 구체화 뷴의 특별한 사례이다.&lt;/p&gt;
&lt;p&gt;&amp;hellip; 이미지 &amp;hellip;
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/03_12.png&#34; alt=&#34;그림 3-11&#34;&gt;&lt;br&gt;
&lt;em&gt;그럼 3-11. 합으로 데이터를 집계한 2차원 데이터 큐브&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구체화 데이터 큐브&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;특정 질의를 효과적으로 미리 계산했기 때문에 해당 질의를 수행할 때 매우 빠르다.
&lt;ul&gt;
&lt;li&gt;ex) 어제 매장별 총 판매량(풀스캔 X, 차원을 따라 합계를 살펴본다)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;원시 데이터의 질의하는 것과 동일한 유연성이 없다.
&lt;ul&gt;
&lt;li&gt;포함되지 않은 차원을 기준으로 집계를 할 수 없다.&lt;/li&gt;
&lt;li&gt;데이터 재적재해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터 큐브와 같은 집계 값은 특정 질의에 다한 성능 향상에만 사용한다.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;참조-자료&#34;&gt;참조 자료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.yevgnenll.me/data-intensive/storage-and-retrieval&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.yevgnenll.me/data-intensive/storage-and-retrieval&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Space-filling_curve&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://en.wikipedia.org/wiki/Space-filling_curve&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.researchgate.net/figure/Star-schema-left-vs-Snowflake-schema-right_fig4_227246694&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.researchgate.net/figure/Star-schema-left-vs-Snowflake-schema-right_fig4_227246694&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bitmap: &lt;a href=&#34;http://wiki.gurubee.net/pages/viewpage.action?pageId=1507452&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://wiki.gurubee.net/pages/viewpage.action?pageId=1507452&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bloom Filters: &lt;a href=&#34;https://llimllib.github.io/bloomfilter-tutorial/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://llimllib.github.io/bloomfilter-tutorial/&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Huffman Conding: &lt;a href=&#34;https://blog.naver.com/PostView.nhn?blogId=whwo161&amp;amp;logNo=221065253075&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://blog.naver.com/PostView.nhn?blogId=whwo161&amp;logNo=221065253075&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 04장. 부호화 발전</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/04/</link>
      <pubDate>Fri, 04 Mar 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/04/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 황윤호&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;애플리케이션은 필연적으로 시간이 지남에 따라 변한다.&lt;br&gt;
새로운 제품을 출시하거나 사용자 요구사항, 비즈니스 환경이 변함에 따라 애플리케이션 기능은 추가하거나 변경된다.&lt;/p&gt;
&lt;p&gt;이 변환에 DB의 변화도 포함되고 컬럼, 필드가 추가되거나 삭제되기도 한다.&lt;br&gt;
이러한 DB 관점의 변경은 바로 적용이 가능하다. 하지만, application의 코드는 대체로 바로 적용되지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Application 코드가 바로 적용되지 않는 이유&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;code의 update 방식은 rolling update 방식으로 진행된다.&lt;/li&gt;
&lt;li&gt;client의 경우 업데이트를 바로 하지 않는 사용자도 있기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;호환성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하위 호환성
&lt;ul&gt;
&lt;li&gt;새로운 코드는 이전 코드가 기록한 데이터를 읽을 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;새로운 코드는 기존 데이터에 대해 알기에 큰 문제가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;상위 호환성
&lt;ul&gt;
&lt;li&gt;이전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;새 버전에 추가된 것을 무시할 수 있어야 하므로 적용이 어렵다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터-부호화-형식&#34;&gt;데이터 부호화 형식&lt;/h2&gt;
&lt;p&gt;프로그램은 보통 두 가지 형태로 표현된 데이터를 사용해 동작한다.&lt;br&gt;
메모리에 객체, 구조체, 리스트, 배열, 해시테이블, 트리 등으로 데이터가 유지된다.&lt;br&gt;
이러한 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 최적화 된다.&lt;/p&gt;
&lt;p&gt;데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 바이트열의 의 형태로 부호화해야 한다.&lt;br&gt;
포인터는 다른 프로세스가 이해할 수 없으므르 이 일련의 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 상당히 다르다.&lt;/p&gt;
&lt;p&gt;인메모리 표현에서 바이트열로의 전환을 부호화(직렬화 또는 마샬링).&lt;br&gt;
그 반대를 복호화 (파싱, 역직렬화, 언마샬링) 이라고 한다&lt;/p&gt;
&lt;p&gt;Ex) Java - Serializable, Ruby - Marshal, Python - pickle 등등&lt;/p&gt;
&lt;h3 id=&#34;json과-xml-이진-변형&#34;&gt;JSON과 XML, 이진 변형&lt;/h3&gt;
&lt;p&gt;표준화된 부호화로서, JSON과 XML text 형식이며 인기가 많다.
JSON과 XML은 널리 알려져 있고 많은 곳에서 지원하지만 그만큼 호불호가 갈리고도 한다.&lt;br&gt;
특히 XML의 경우 불필요하고 복잡하다고 비판받는다.&lt;br&gt;
강력하지 않지만, csv도 인기 있는 언어 독립적인 형식이다.&lt;/p&gt;
&lt;p&gt;수의 부호화에는 많은 애매함이 존재. 정수와 부동소수점 수를 구별 X, 정밀도 지정 X.&lt;br&gt;
이 애매함은 큰 수를 다룰때 문제. 2^53보다 큰 정수를 다룰때 부정확해 질 수 있음.&lt;br&gt;
JSON, XML은 유니코드 문자열은 잘 지원, 그러나 이진문자열을 지원하지 않음.&lt;/p&gt;
&lt;p&gt;이러한 결점에도 JSON, XML, CSV는 사용하기 충분하고 인기 있음.&lt;br&gt;
특히, 데이터 교환 형식에서 사용하기 매우 좋음.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Binary Encoding (이진 부호화)&lt;/strong&gt;&lt;br&gt;
json, xml과 비교해 더 적은 공간, 더 간결하고 더 빠른 파싱인데 data set이 적다면 별 의미가 없지만, terabyte 급이 된다면 이야기가 달라진다.&lt;br&gt;
Json도 이진 형식과 비교하면 더 많은 공간을 사용한다.&lt;br&gt;
이러한 관점이 json(message pack, BSON, BJSON, BISON, smile) 등으로 사용 가능한 이진 부호화 개발이 되었다.&lt;/p&gt;
&lt;p&gt;다만, JSON만큼 사용되진 않는다.&lt;/p&gt;
&lt;p&gt;예제4-1)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{ //1 byte
	&amp;#34;userName&amp;#34; :&amp;#34;Martin&amp;#34;, // 20 byte
	&amp;#34;favoriteNumber&amp;#34; :1337, // 22  byte
	&amp;#34;interests&amp;#34;:[&amp;#34;daydreaming&amp;#34;, &amp;#34;hacking&amp;#34;] // 37 byte
} // 1 byte
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;json을 이진 부호화 한다고 해도 객체의 필드 이름을 포함해야 한다. (81바이트)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/04-1.png&#34; alt=&#34;그림 4-1&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 4-1. 메시지팩으로 부호화한 예제 레코드(예제4-1)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Json 이진 부호화 66 바이트 (16진수)&lt;/p&gt;
&lt;p&gt;참고)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0x83 = 0x80 (객체), 0x03 (필드) 3개의 필드를 가진 객체&lt;/li&gt;
&lt;li&gt;0xa8 = 0xa0 (문자열), 0x08 (8바이트)&lt;/li&gt;
&lt;li&gt;cd = 16바이트 숫자, 16^2 * 5 = 1280. 16 * 3 = 48 . 9 = 1337&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://ko.wikipedia.org/wiki/ASCII&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ASCII - 위키백과, 우리 모두의 백과사전&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;a href=&#34;https://github.com/msgpack/msgpack/blob/master/spec.md#int-format-family&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;msgpack/spec.md at master | msgpack/msgpack | GitHub&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;스리프트와-프로토콜-버퍼&#34;&gt;스리프트와 프로토콜 버퍼&lt;/h3&gt;
&lt;p&gt;아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers)는 같은 원리를 기반으로 한 이진 부호화 라이브러리&lt;br&gt;
프로토콜 버퍼는 구글에서 개발, 스리프트는 페이스북에서 개발 =&amp;gt; 현재 둘다 오픈소스&lt;br&gt;
둘다 부호화할 데이터를 위한 스키마가 필요&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 스리프트 스키마
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;struct Person {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	1:required string userName, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	2:optional i64 favoriteNumber, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	3:optional list&amp;lt;string&amp;gt; interests 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;# 프로토콜 스키마
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;message Person {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	required string user_name = 1; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	optional int64 favorite_number = 2; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	repeated string interests = 3; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/04-3.png&#34; alt=&#34;그림 4-3&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 4-3. 스리프트의 컴팩트 프로토콜을 사용한 부호화 예제&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/04-4.png&#34; alt=&#34;그림 4-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 4-4. 프로토콜 버퍼를 사용해 부호화한 예제 레코드&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;두 프로토콜 모두, 스키마를 이용해 바이트수가 급격히 줄었다.&lt;br&gt;
가장 큰 차이점은 필드이름 대신 필드 태그(1,2,3)을 포함한다.&lt;br&gt;
이 숫자는 스키마 정의에 나타난 숫자다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;필드태그와 스키마 발전&lt;/strong&gt;&lt;br&gt;
스키마는 필연적으로 시간이 지남에 따라 변한다. 이를 스키마 발전이라 한다.&lt;br&gt;
어떻게 상위 호환성, 하위 호환성을 유지하면서 변경할까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상위 호환성 (예전 코드는 현재 데이터를 읽을 수 있어야 함)
&lt;ul&gt;
&lt;li&gt;새로운 코드로 기록한 데이터를 읽으려 할 때 인식할 수 있는 tag 번호인지만 확인하여 인식이 안되면 자연스럽게 무시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하위 호환성 (지금 코드는 예전 코드로 생성한 데이터를 읽을 수 있어야 함)
&lt;ul&gt;
&lt;li&gt;최초 배포 후에는 required 로 field를 추가할 수 없음 (예전 코드로 생성한 데이터를 읽지 못함)&lt;/li&gt;
&lt;li&gt;optional field만 삭제 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;아브로-apache-avro&#34;&gt;아브로 (Apache Avro)&lt;/h3&gt;
&lt;p&gt;프로토콜 버퍼와 스리프트와 다르지만 이들과 대적할만한 또 하나의 이진 부호화 형식.&lt;br&gt;
스리프트가 하둡의 사용 사례와 적합하지 않아 2009년 하둡에 하위 프로젝트로 시작.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;record Person {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	string userName;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	union { null, long } favoriteNumber = null;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	array&amp;lt;string&amp;gt; interests;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;type&amp;#34;: &amp;#34;record&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;name&amp;#34;: &amp;#34;Person&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &amp;#34;fields&amp;#34;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&amp;#34;name&amp;#34;: &amp;#34;userName&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;string&amp;#34;},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&amp;#34;name&amp;#34;: &amp;#34;favoriteNumber&amp;#34;, &amp;#34;type&amp;#34;: [&amp;#34;null&amp;#34;,&amp;#34;long&amp;#34;], &amp;#34;default&amp;#34;: null},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {&amp;#34;name&amp;#34;: &amp;#34;interests&amp;#34;,&amp;#34;type&amp;#34;: {&amp;#34;type&amp;#34;: &amp;#34;array&amp;#34;,&amp;#34;items&amp;#34;: &amp;#34;string&amp;#34;}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/04-4.png&#34; alt=&#34;그림 4-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 4-5. 아브로를 이용한 부호화한 에제 레코드&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;32바이트로 길이가 가장 짧다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;필드나 데이터타입을 식별하기 위한 정보가 없다&lt;/li&gt;
&lt;li&gt;아브로를 사용해 parsing 하려면 schema를 먼저 읽고 각 필드의 데이터 타입을 기억해야 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;쓰기 스키마와 읽기 스키마&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;file, db, network를 통해 전송 목적으로 부호화하기 위해 사용&lt;/li&gt;
&lt;li&gt;application이 빌드하는 동안 스키마 생성&lt;/li&gt;
&lt;li&gt;쓰기, 읽기의 스키마가 다를 수 있다. 또한 필드의 순서가 달라도 문제 없다&lt;/li&gt;
&lt;li&gt;없는 필드를 만드면 이 필드를 무시후 기본값으로 채운다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아보로 스키마 발전 규칙&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;상위 호환
&lt;ul&gt;
&lt;li&gt;새로운 버젼의 쓰기 스키마와 예전 버전의 읽기 스키마를 가질 수 있음&lt;/li&gt;
&lt;li&gt;필드 이름 변경 불가&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하위 호환(예전 데이터를 지금도 읽을 수 있다)
&lt;ul&gt;
&lt;li&gt;새로운 버젼의 읽기 스키마와 예전 버젼의 쓰기 스키마를 가질 수 있다&lt;/li&gt;
&lt;li&gt;필드 이름 변경을 추적할 수 있기 때문에 필드 이름 변경 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 호환성을 유치하기 위해 default 가 있는 필드만 추가 삭제 가능&lt;br&gt;
예전 스키마에 없는 값이 읽기 스키마에 있으면 기본값으로 대체&lt;br&gt;
아브로는 스키마가 동적으로 변경될 가능성을 고려하여 설계됨&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;코드 생성과 동적 타입언어&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스리프트와 프로토컬 버퍼는 코드 생성에 의존
&lt;ul&gt;
&lt;li&gt;Java, C++, C# 같은 정적 타입 언어에서 유용&lt;/li&gt;
&lt;li&gt;스키마가 변경되면 재컴파일 필요
avro는 이저한 관점에서 compile, interpreter 언어를 선택해 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스키마의-장점&#34;&gt;스키마의 장점&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로토컬버퍼, 스리프트 아브로는 스키마를 사용해 이진 부호화 형식을 기술한다.&lt;/li&gt;
&lt;li&gt;이 스키마 언어는 xml, json 스키마 보다 훨씬 간단하며 더 자세한 유효성 검사 규칙을 지원한다.&lt;/li&gt;
&lt;li&gt;부호화된 데이터는 필드 이름을 생략할 수 있어, data 크기가 json 에 비해 작을 수 있다.&lt;/li&gt;
&lt;li&gt;schema database 를 사용한다면 상위 호환, 하위 호환을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터플로-모드&#34;&gt;데이터플로 모드&lt;/h2&gt;
&lt;p&gt;하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB를 통해&lt;/li&gt;
&lt;li&gt;서비스 호출을 통해&lt;/li&gt;
&lt;li&gt;비동기 메시지 전달을 통해&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터베이스를-통한-데이터플로&#34;&gt;데이터베이스를 통한 데이터플로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 읽는 프로세스는 복호화한다&lt;/li&gt;
&lt;li&gt;단일프로세스로 DB에 접근
&lt;ul&gt;
&lt;li&gt;DB에 저장하는 일은 미래의 자신에게 메시지를 보내는 일&lt;/li&gt;
&lt;li&gt;하위 호환성이 분명히 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;다양한 프로세스가 DB에 접근
&lt;ul&gt;
&lt;li&gt;흔한 방식의 application이나 서비스&lt;/li&gt;
&lt;li&gt;순회식으로 배포를 한다면 새로운 버젼을 배포하는 몇몇 instance 는 예전 코드로 데이터를 저장하고 갱신중일 것&lt;/li&gt;
&lt;li&gt;상위 호환성이 필요&lt;/li&gt;
&lt;li&gt;부호화는 모르는 필드는 건들지 않지만 DB 관점에선 데이터가 유실될 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/04-7.png&#34; alt=&#34;그림 4-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 4-7. 새로운 버전의 애플리케이션이 기록한 데이터를 예전 버전의 애플리케이션이 갱신한 경우 주의하지 않으면 데이터가 유실될 수 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;주의하지 않으면 이처럼 데이터 갱신시 새로운 필드의 데이터가 유실될 수 있다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;다양한 시점에 기록된 다양한 값&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB는 언제나 데이터를 갱신할 수 있다&lt;/li&gt;
&lt;li&gt;이 데이터는 5년전 데이터일 수도 있고, 5ms 전에 기록됐을 수 있다&lt;/li&gt;
&lt;li&gt;DB에 별다른 기능을 실행하지 않는다면 원래 부호화 그대로 유지되어 있을 것이다&lt;/li&gt;
&lt;li&gt;데이터를 새로운 스키마를 통해 다시 기록 할수 있지만 마이그레이션하는 작업은 큰 비용이 든다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;보관 저장소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;백업 목적이나 데이터 웨어하우스로 적재하기 위해 데이터베이스의 스냅숏을 수시로 만든다.&lt;/li&gt;
&lt;li&gt;이 경우 최신 스키마를 이용해 부호화한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서비스를-통한-데이터플로-rest와-rpc&#34;&gt;서비스를 통한 데이터플로: REST와 RPC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크를 통해 통신해야하는 프로세스가 있을때 해당 통신을 배치하는 몇가지 방법이 있다&lt;/li&gt;
&lt;li&gt;가장 일반적인 방법으로는 클라이언트와 서버의 두 역할로 배치하는 것이다&lt;/li&gt;
&lt;li&gt;서버가 네트워크를 통해 API를 공개하고 클라이언트는 이 API로 요청을 만들어 서버에 연결한다&lt;/li&gt;
&lt;li&gt;서버가 공개한 API를 서비스라 한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;웹은 다음과 같은 방식으로 동작한다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트는 웹서버로 요청을 보낸다&lt;/li&gt;
&lt;li&gt;GET 요청을 보내고 HTML, CSS, JS, Image 등을 받는다&lt;/li&gt;
&lt;li&gt;서버는 데이터를 전송하기 위해서 POST 요청을 보낸다&lt;/li&gt;
&lt;li&gt;웹에서 웹 브라우저만 유일한 client는 아니다.
&lt;ul&gt;
&lt;li&gt;모바일 디바이스, 데스크톱 기본앱도 서버에 네트워크를 요청할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서버 자체가 다른 서비스의 클라이언트일 수도 있다
&lt;ul&gt;
&lt;li&gt;예를 들어 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비스에 요청을 보낸다&lt;/li&gt;
&lt;li&gt;이런 application 개발 방식을 전통적으로 서비스 지향 설계 (SOA)라 불렀다&lt;/li&gt;
&lt;li&gt;최근엔 이런 더욱 개선해 마이크로서비스 설계란 이름으로 재탄생했다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;서비스와 Database는 여러가지 측면에서 유사하다. 단, 차이는 service 는 비즈니스 로직에 기반하여 입출력을 제한하고, 정해진 입출력만 허용해 API를 공개한다는 것이다.&lt;br&gt;
MSA, SOA의 목표는 서비스를 배포와 변경에 독립적으로 만들어 application의 유지보수를 더 쉽게 만드는데 있다.&lt;br&gt;
즉 변경이 잦을것을 대응하기 위한 것이며 새로운 버젼 출시가 빠르기 때문에 API간 호환이 필요하다. 이점이 이번 장의 핵심 내용이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;웹서비스&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서비스와 통신하기 위한 기본 프로토콜로 HTTP를 사용할 때 이를 웹 서비스라고 한다&lt;/li&gt;
&lt;li&gt;웹서비스에는 대중적인 두가지 방식 REST와 SOAP이 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;REST&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP를 원칙을 토대로 설계한 원칙&lt;/li&gt;
&lt;li&gt;간단한 데이터 타입을 강조&lt;/li&gt;
&lt;li&gt;URL을 사용해 Resource를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상&lt;/li&gt;
&lt;li&gt;SOAP이 비해 인기있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SOAP&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 API 요청을 위한 XML 기반 프로토콜&lt;/li&gt;
&lt;li&gt;HTTP 상에서 일반적으로 사용하지만, HTTP와 독립적이며 HTTP 기능을 사용하지 않는다.&lt;/li&gt;
&lt;li&gt;그대신 다양한 기능을 추가한 광범휘하고 복잡한 여러 관련 표준을 제공&lt;/li&gt;
&lt;li&gt;사람이 읽을 수 없도록 설계되어 도구나 IDE에 크게 의존한다.&lt;/li&gt;
&lt;li&gt;대부분은 RESTful API 를 통한 간단한 접근 방식을 선호한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;원격 프로시저 호출(RPC) 문제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 서비스는 network 상에서 API를 호출하는 여러 기술중 가장 최신의 형상일 뿐이다&lt;/li&gt;
&lt;li&gt;웹서비스는 1970년대부터 사용한 원격 프로시저 호출 (RPC)의 아이디어를 기반으로 한다&lt;/li&gt;
&lt;li&gt;RPC 모델은 원격 network 서비스 요청을 같은 process 안에서 특정 method를 호출하는것 처럼 사용 가능하게 해준다&lt;/li&gt;
&lt;li&gt;RPC가 처음에는 편리한 것 같지만 RPC 접근 방식은 근본적으로 결함이 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;로컬함수 호출은 결과를 반환하거나 예외를 반환하지 않을 수 있다&lt;/li&gt;
&lt;li&gt;실패한 네트워크 요청을 다시 시도할 때 요청이 실제로는 처리되고 응답만 유실될 수 있다&lt;/li&gt;
&lt;li&gt;로컬함수를 호출할 때마다 보통 거의 같은 실행 시간이 소요된다&lt;/li&gt;
&lt;li&gt;로컬 함수를 호출하는 경우 참조(포인터)를 로컬 메모리의 객체에 효율적으로 전달할 수 있다&lt;/li&gt;
&lt;li&gt;클라이언트 서비스는 다른 프로그래밍 언어로 구현할 수 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;RPC의 현재 방향&lt;/strong&gt;
이러한 문제에도 불구하고 RPC는 사라지지 않았으며, 지금까지 언급한 이진 부호화 위에 RPC 프레임워크가 개발되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;thrift, avro 는 RPC 지원 기능을 내장하고 있다&lt;/li&gt;
&lt;li&gt;gRPC는 protocol buffer를 이용해 RPC를 구현했다&lt;/li&gt;
&lt;li&gt;Finagle은 thrift를 사용하고 Rest.li는 HTTP 위에서 json을 사용한다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;데이터 부호화와 RPC의 발전&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;발전성이 있으려면, RPC client와 서버를 독립적으로 변경하고 배포할 수 있어야 한다&lt;/li&gt;
&lt;li&gt;데이터베이스를 통한 데이터플로에 비해 발전성은 가정을 단순화 할 수 있다&lt;/li&gt;
&lt;li&gt;모든 서버를 먼저 갱신하고 나서 모든 클라이언트를 갱신해도 문제가 없다고 가정한다&lt;/li&gt;
&lt;li&gt;그러면 요청은 하위 호환성만 필요하고 응답은 상위 호환성만 필요하다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;API 버젼 관리가 반드시 어떤 방식으로 동작해야 한다는 합의는 없으나, 일반적으로 HTTP Aceept 헤더에 버전 번호를 사용하는 방식이 일반적이다&lt;/p&gt;
&lt;h3 id=&#34;메시지-전달-데이터플로&#34;&gt;메시지 전달 데이터플로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;메시지 전달 데이터플로는 RPC와 데이터베이스간 비동기 메시지 전달 시스템이다&lt;/li&gt;
&lt;li&gt;클라이언트 요청을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서 RPC와 비슷&lt;/li&gt;
&lt;li&gt;메세지를 직접 네트워크 연결로 전송하지 않는다
&lt;ul&gt;
&lt;li&gt;임시로 메시지를 저장하는 메세지 브로커를 이용&lt;/li&gt;
&lt;li&gt;또는 메시지 지향 미들웨어라는 중간 단계를 거쳐 전송한다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Message broker를 사용했을때 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있다.&lt;/li&gt;
&lt;li&gt;죽었던 프로세스에 메세지를 다시 전달할 수 있기 때문에 메시지 유실을 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;송신자가 수신자의 IP 주소나 포트 번호를 알 필요가 없다.&lt;/li&gt;
&lt;li&gt;하나의 메세지를 여러 수신자로 전송할 수 있다.&lt;/li&gt;
&lt;li&gt;논리적으로 송신자는 수신자와 분리된다할 뿐이고 누가 소비하는지 상관하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;메시지 전달 통신은 일반적으로 단방향이라는 점이 RPC와 다르다. 즉, 송신 프로세스는 대게 메시지에 대한 응답을 기대하지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메시지 브로커&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;최근엔 래빗MQ, 액티브MQ, 호닛Q, 아파치카프카 같은 오픈소스 구현이 대중화 됐다&lt;/li&gt;
&lt;li&gt;세부전달 전달 시맨틱은 구현과 설정에 따라 다양하다&lt;/li&gt;
&lt;li&gt;하지만, 일반적인 메시지브로커는 다음과 같이 사용한다
&lt;ul&gt;
&lt;li&gt;메시지이름이 지정된 큐나 토픽으로 전송&lt;/li&gt;
&lt;li&gt;브로커는 해당 큐나 토픽 의 하나 이상의 컨슈머 또는 구독자에게 메세지를 전달&lt;/li&gt;
&lt;li&gt;동일한 토픽에 여러 생산자와 소비자가 있을 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;토픽은 단방향 데이터플로만 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;분산 액터 프레임워크&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;액터 모델은 단일 프로세스안에서 동시성을 위한 프로그래밍 모델이다&lt;/li&gt;
&lt;li&gt;스레드 경쟁 조건, 잠금, 교착상태를 직접 처리하는 대신 로직이 액터에 캡슐화 된다&lt;/li&gt;
&lt;li&gt;각 액터는 하나의 클라이언트나 엔티티를 나타낸다&lt;/li&gt;
&lt;li&gt;액터는 로컬 상태를 가질수 있고 비동기 메시지의 송수신으로 다른 액터와 통신한다&lt;/li&gt;
&lt;li&gt;액터는 메세지 전달을 보장하지 않는다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;분산 액터 프레임워크는 노드간 application 확장에 사용하는데 송신자, 수신자가 같은 노드이건 아니건 관계없이 동일한 메세지 전달 구조를 사용한다. 만약 다른 노드이면 부호화되고 network를 통해 전송된다.&lt;/p&gt;
&lt;p&gt;액터 모델은 메세지가 유실된다는 가정을 가지기 때문에 위치 투명성은 RPC 보다 actor 모델에 더 잘 동작한다(로컬과 원격 통신간 불일치를 줄여준다)&lt;/p&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;p&gt;다양한 데이터 부호화 형식과 호환성 속성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍 언어에 특화된 부호화는 단일 프로그래밍 언어로 제한되며 상위 호환성과 하위 호환성을 제공하지 못하는 경우가 있다&lt;/li&gt;
&lt;li&gt;JSON, XML, CSV 같은 텍스트 형식은 널리 사용된다
&lt;ul&gt;
&lt;li&gt;이들간 호환성은 데이터타입을 사용하는 방법에 달려 있어 스키마가 있으면 유용할 수 있으나 반대로 불편할 수 있다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스리프트, 프로토콜, 아브로 같은 이진 스키마 기반은 짧은 길이로 부호화 되어 효율적
&lt;ul&gt;
&lt;li&gt;단, 이진 부호화는 사람이 읽을 수 있도록 하기위해 복호화 과정이 필요하다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터 부호화에 대한 시나리오 data flow mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 기록하는 프로세스가 부호화하고 데이터베이스에 읽는 프로세스사 복호화하는 데이터베이스&lt;/li&gt;
&lt;li&gt;클라이언트가 요청을 부호화하고 서버는 요청을 복호화하고 응답을 부호화하고 최종적으로 응답을 복호화하는 RPC와 REST API&lt;/li&gt;
&lt;li&gt;송신자가 부호화하고 수신자가 복호화하는 메시지를 서로 전송해서 노드간 통신하는 비동기 메시지전달 (메시지브로커나 액터를 이용)&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 05장. 복제</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/05/</link>
      <pubDate>Thu, 17 Feb 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/05/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 이호준, 조성직&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;part-2-분산-데이터&#34;&gt;Part 2. 분산 데이터&lt;/h2&gt;
&lt;p&gt;1부에서는 단일 장비에서 데이터를 저장할 때 적용하는 데이터 시스템 측면을 살펴보았다.&lt;br&gt;
2부에서는 여러 장비가 관여하는 경우에 대해서 다룬다.&lt;br&gt;
그런데 여러 장비가 관여해야 하는 이유는 무엇일까? 그 이유는 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;확장성&lt;/strong&gt;&lt;br&gt;
데이터 볼륨, 읽기/쓰기 부하가 단일 장비에서 다룰 수 있는 양보다 커지는 경우 부하를 여러 장비로 분산한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;확장성(Scalability)&lt;/em&gt; : 시스템이 특정한 요구사항을(요구 처리량의 변화와 같은) 충족하기 위해 애플리케이션의 상당 부분을 변경하지 않고도 하드웨어 수준의 변경(추가/감소, 업그레이드/다운그레이드) 등을 통해 시스템을 확장 또는 축소할 수 있는 능력 또는 그 정도를 의미함&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;내결함성/고가용성&lt;/strong&gt;&lt;br&gt;
장비 하나가 죽더라도 다른 장비가 존재하면 애플리케이션이 계속해서 동작할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;가용성(Availability)&lt;/em&gt; : 서버, 네트워크와 같은 시스템이 정상적으로 사용가능한 정도&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05_Availability.png&#34; alt=&#34;가용성&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;고가용성(HA, High Availability)&lt;/em&gt; : 위 가용성이 굉장히 높은 경우(&amp;gt;= 99.9999..) 또는 이에 근접하다면 시스템이 고가용성을 지녔다고 표현한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;내결함성(FT, Fault Tolerance)&lt;/em&gt; : 결함이 발생하더라도 시스템이 정상적으로 동작할 수 있는 경우 내결함성을 지녔다고 표현한다. 가용성의 관점에서 다운 타임이 0인 것을 의미.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;지연 시간&lt;/strong&gt;
전 세계에 사용자가 있는 경우 사용자와 지리적으로 가까운 곳의 데이터센터에서 서비스를 제공하기 위해 전 세계 다양한 곳에 서버를 둘 필요가 있다. 이를 통해 서비스 지연 시간을 단축시킨다.&lt;/p&gt;
&lt;h3 id=&#34;수직-확장과-수평-확장&#34;&gt;수직 확장과 수평 확장&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;수직 확장(scale up)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;더 강력한 장비를 사용하는 것&lt;/li&gt;
&lt;li&gt;많은 CPU, 메모리 칩, 디스크를 하나의 운영체제로 결합한다.&lt;/li&gt;
&lt;li&gt;빠른 상호 연결로 모든 CPU가 메모리나 디스크의 모든 부분에 접근한다.&lt;/li&gt;
&lt;li&gt;공유 메모리 아키텍처
&lt;ul&gt;
&lt;li&gt;모든 구성 요소를 단일 장비로 다룬다.&lt;/li&gt;
&lt;li&gt;비용 대비 성능 측면에서 가성비가 좋지 않다.&lt;/li&gt;
&lt;li&gt;제한적인 내결함성 제공 : 하이엔드 장비는 핫 스왑이 가능한 구성요소가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;공유 디스크 아키텍처
&lt;ul&gt;
&lt;li&gt;독립적인 CPU, RAM을 탑재한 여러 장비를 사용&lt;/li&gt;
&lt;li&gt;그러나 디스크는 공유한다.&lt;/li&gt;
&lt;li&gt;각 장비는 고속 네트워크로 연결된다.&lt;/li&gt;
&lt;li&gt;일부 데이터 웨어하우스 작업 부하에 사용된다.&lt;/li&gt;
&lt;li&gt;잠금 경합과 오버헤드 등으로 인해 확장성에 제한이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;수평-확장scale-out&#34;&gt;수평 확장(scale out)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;노드
&lt;ul&gt;
&lt;li&gt;데이터베이스 소프트웨어를 수행하는 각 장비 혹은 가상 장비&lt;/li&gt;
&lt;li&gt;각 노드는 CPU, RAM, 디스크를 독립적으로 사용&lt;/li&gt;
&lt;li&gt;노드 간의 코디네이션은 네트워크를 사용하여 소프트웨어 수준에서 수행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비공유 아키텍처
&lt;ul&gt;
&lt;li&gt;특별한 하드웨어를 필요로 하지 않음 → 가성비를 갖춘 시스템을 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;여러 지리적인 영역에 데이터를 분산한다.
&lt;ul&gt;
&lt;li&gt;사용자 지연 시간을 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;전체 데이터 센터의 손실을 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;주의할 점이 있다. → 이 장에서 다루는 이유
&lt;ul&gt;
&lt;li&gt;분산 시스템에서 발생하는 &lt;strong&gt;제약 조건&lt;/strong&gt;과 &lt;strong&gt;트레이드오프&lt;/strong&gt;가 존재&lt;/li&gt;
&lt;li&gt;부가적인 애플리케이션 복잡도를 야기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;복제&#34;&gt;복제&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;복제와 필요한 이유&lt;/strong&gt;&lt;br&gt;
복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지하는 것을 말한다.&lt;/p&gt;
&lt;p&gt;복제가 필요한 이유는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;지리적으로 사용자와 가깝게 데이터를 유지 → 지연시간을 줄인다.&lt;/li&gt;
&lt;li&gt;시스템 일부에 장애 발생해도 지속적으로 동작 → 내결함성, 고가용성 달성&lt;/li&gt;
&lt;li&gt;읽기 질의를 제공하는 장비의 수 확장 → 읽기 처리량 향상&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q. 복제는 왜 어려운가?&lt;br&gt;
A. 데이터가 변경되기 때문. 복제에서 오는 어려움은 복제된 데이터의 변경 처리와 관련이 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;복제 알고리즘&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더(single-leader)&lt;/li&gt;
&lt;li&gt;다중 리더(multi-leader)&lt;/li&gt;
&lt;li&gt;리더가 없음(leaderless)&lt;/li&gt;
&lt;li&gt;각 알고리즘은 장단점이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;리더와-팔로워&#34;&gt;리더와 팔로워&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;복제 서버(replica)&lt;/strong&gt;
데이터 베이스의 복사본을 저장하는 각 노드&lt;/p&gt;
&lt;p&gt;Q. 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할까?&lt;br&gt;
A. 일반적인 해결방법 : 리더 기반 복제(leader-based replication)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-1.png&#34; alt=&#34;그림 5-1&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-1. 리더 기반(마스터 슬레이브) 복제&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리더 기반 복제(leader-based replication)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;= 마스터 슬레이브 복제(master slave replication), 능동/수동 복제(active/passive replication)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리더(leader)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;= 마스터, 프라이머리(primary)&lt;/li&gt;
&lt;li&gt;클라이언트의 쓰기, 읽기 요청을 처리&lt;/li&gt;
&lt;li&gt;쓰기 기록 후 팔로워에게 이를 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;팔로워(follower)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;= 읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby)&lt;/li&gt;
&lt;li&gt;리더가 보낸 데이터 변경 로그, 변경 스트림을 전달 받아 데이터 복제본을 갱신&lt;/li&gt;
&lt;li&gt;클라이언트의 읽기 요청 만을 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RDBMS, NoSQL, 메시지 브로커 등에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동기식-대-비동기식-복제&#34;&gt;동기식 대 비동기식 복제&lt;/h3&gt;
&lt;p&gt;복제가 동기식으로 발생하는지, 비동기식으로 발생하는 지는 복제 시스템에서 중요한 세부사항이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-2.png&#34; alt=&#34;그림 5-2&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-2. 한 팔로워는 동기식, 다른 팔로워는 비동기식인 리던 기반 복제&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동기식 복제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(그림 5-2) 팔로워1의 경우&lt;/li&gt;
&lt;li&gt;리더가 팔로워의 쓰기 수신에 대한 응답을 확인하기 위해 대기한다.&lt;/li&gt;
&lt;li&gt;확인이 끝나면 사용자에게 성공을 보고 후 해당 쓰기를 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 방식의 장단점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리더와 팔로워의 일관성(최신 데이터)을 보장한다.&lt;/li&gt;
&lt;li&gt;팔로워가 (죽거나 네트워크 등의 문제로)응답하지 않을 시 쓰기가 처리될 수 없다.
&lt;ul&gt;
&lt;li&gt;리더는 모든 쓰기를 차단(block)하고 팔로워가 사용가능할 때 까지 기다려야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;비동기식 복제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(그림 5-2) 팔로워2의 경우&lt;/li&gt;
&lt;li&gt;리더가 팔로워의 쓰기 수신에 대한 응답을 기다리지 않는다.&lt;/li&gt;
&lt;li&gt;일관성은 떨어지지만, 사용자 응답 지연 시간이 적고 고가용성 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;동기식, 비동기식을 바탕으로 한 복제 구성 방식에는 다음과 같은 방식이 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;반동기식(semi-synchronous)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 팔로워가 동기식 복제 방식을 사용할 수는 없다. 하나의 노드만 고장나도 전체 시스템이 마비.&lt;/li&gt;
&lt;li&gt;팔로워 하나는 동기식, 나머지는 비동기 식으로 구성하는 것을 의미&lt;/li&gt;
&lt;li&gt;동기식 팔로워가 사용 불가 시 → 다른 비동기 팔로워가 동기식으로 동작&lt;/li&gt;
&lt;li&gt;적어도 두 노드(리더, 동기식 팔로워)에 데이터의 최신 복사본이 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;완전한 비동기식&lt;/strong&gt;
리더 기반 복제 방식에서 일반적으로 선택&lt;/p&gt;
&lt;p&gt;이 방식의 장단점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리더가 잘못되고 복구 불가능한 경우 팔로워에 복제되지 않은 쓰기는 유실&lt;/li&gt;
&lt;li&gt;클라이언트가 어떤 쓰기를 확인했어도 해당 쓰기의 지속성을 보장할 수 없음&lt;/li&gt;
&lt;li&gt;모든 팔로워가 잘못되어도 리더가 쓰기 처리를 계속할 수 있다.&lt;/li&gt;
&lt;li&gt;내구성이 약하다는 단점에도 불구하고 다음과 같은 조건 하에 많이 사용된다.
&lt;ul&gt;
&lt;li&gt;많은 팔로워가 존재하는 경우&lt;/li&gt;
&lt;li&gt;노드가 지리적으로 분산된 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;새로운-팔로워-설정&#34;&gt;새로운 팔로워 설정&lt;/h3&gt;
&lt;p&gt;새로운 팔로워 설정이 필요한 경우가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복제 서버의 수를 늘려야 하는 경우&lt;/li&gt;
&lt;li&gt;장애 노드를 대체하는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Q. 새로운 팔로워의 추가 설정은 어떻게 진행해야 할까?&lt;br&gt;
A1. 데이터 파일을 복사한다. &lt;em&gt;(X)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복사하는 와중에도 클라이언트의 쓰기 요청은 계속 발생한다. 파일의 복사본은 유효하지 않은(out-of-date) 데이터를 포함한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A2. 일관성을 보장하기 위해 데이터베이스를 잠가 잠시동안 쓰기를 막는다. &lt;em&gt;(X)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고가용성 목표에 부합하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A3. 다음과 같이 중단 없이 팔로워 설정을 수행한다. &lt;em&gt;(O)&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스를 잠그지 않고 리더의 데이터베이스 스냅샷을 가져온다.&lt;/li&gt;
&lt;li&gt;스냅샷을 새로운 팔로워 노드에 복사한다.&lt;/li&gt;
&lt;li&gt;이후 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경 내역을 요청한다.&lt;/li&gt;
&lt;li&gt;요청한 데이터 변경 미처리분(backlog)을 모두 처리하면 팔로워가 리더를 따라잡았다고 말한다.&lt;/li&gt;
&lt;li&gt;이제 팔로워는 리더의 데이터 변경을 처리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;노드-중단-처리&#34;&gt;노드 중단 처리&lt;/h3&gt;
&lt;p&gt;시스템의 모든 노드는 다음과 같은 사유로 중단될 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장애&lt;/li&gt;
&lt;li&gt;계획된 유지보수
&lt;ul&gt;
&lt;li&gt;ex. 커널 보안 패치를 위한 장비 리부팅&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단일 노드는 중단 되더라도 전체 시스템은 중단되지 않고 서비스되어야 한다.&lt;br&gt;
개별 노드의 장애애도 전체 시스템이 잘 동작하고 노드 중단의 영향을 최소화하는 것이 목표다.&lt;br&gt;
리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을까?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;팔로워 장애: 따라잡기 복구&lt;/strong&gt;
팔로워에 장애가 나는 경우. → 팔로워가 리더를 따라잡음으로써 복구한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관&lt;/li&gt;
&lt;li&gt;팔로워가 죽거나, 네트워크 중단 등으로 복구하는 경우 로그를 이용하여 복구를 시작할 수 있다.
&lt;ul&gt;
&lt;li&gt;로그에서 마지막으로 처리된 트랜잭션을 찾는다.&lt;/li&gt;
&lt;li&gt;해당 트랜잭션 이후의 데이터 변경 내역을 리더에 요청&lt;/li&gt;
&lt;li&gt;요청한 변경 내역을 모두 적용하면 리더를 따라잡아 복구가 완료된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;리더 장애: 장애 복구(failover)&lt;/strong&gt;
장애 복구 과정은 다음과 같이 진행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팔로워 중 하나를 새로운 리더로 승격&lt;/li&gt;
&lt;li&gt;클라이언트는 새로운 리더로 쓰기를 전송해야 함. → 재설정이 필요하다.&lt;/li&gt;
&lt;li&gt;다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작&lt;/li&gt;
&lt;li&gt;수동 또는 자동으로 진행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;수동으로 복구하는 경우 관리자가 리더의 장애 알림을 수신 후 새로운 리더를 만들기 위한 조치를 취한다.&lt;br&gt;
자동으로 복구하는 경우는 이하에서 설명한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;자동 장애 복구 과정&lt;/strong&gt;&lt;br&gt;
자동 장애 복구는 다음과 같이 진행한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리더가 장애인지 판단한다.
&lt;ul&gt;
&lt;li&gt;판단할 수 있는 확실한 방법은 없음 → 보통 타임아웃을 사용&lt;/li&gt;
&lt;li&gt;노드 간 메시지를 주고 받고 일정시간 응답하지 않는 노드는 죽은 것으로 간주
&lt;ul&gt;
&lt;li&gt;예외도 존재, 리더가 계획된 유지 보수를 위해 의도적으로 중단되는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;새로운 리더를 선택한다.
&lt;ul&gt;
&lt;li&gt;복제 노드들이 새로운 리더를 선출&lt;/li&gt;
&lt;li&gt;또는 제어 노드(controller node)가 새로운 리더를 임명&lt;/li&gt;
&lt;li&gt;최신 데이터 변경사항을 가진 복제 서버가 새로운 리더의 가장 적합한 후보로 지목된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;새로운 리더 사용을 위해 시스템을 재설정한다.
&lt;ul&gt;
&lt;li&gt;클라이언트의 쓰기 요청, 팔로워의 데이터 변경 로그 재설정&lt;/li&gt;
&lt;li&gt;이전 리더가 복구되는 경우 이전 리더가 새로운 리더를 인식하고 자신은 팔로워가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;자동 장애 복구 과정에서의 위험&lt;/strong&gt;&lt;br&gt;
다양한 위험이 존재한다. 그래서 수동 장애 복구 방식을 선호하는 운영팀도 존재한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;내구성을 보장하지 않음
&lt;ul&gt;
&lt;li&gt;비동기식 복제 사용 시 새로운 리더는 이전 리더의 최신 쓰기 중 일부를 받지 못했을 수 있음&lt;/li&gt;
&lt;li&gt;이전 리더가 다시 클러스터에 추가되면 해당 최신 쓰기 내역은 어떻게 해야 하는가?&lt;/li&gt;
&lt;li&gt;새로운 리더가 이와 충돌하는 쓰기를 받았을 수 있음 → 해당 쓰기를 폐기하는 것이 일반적&lt;/li&gt;
&lt;li&gt;클라이언트 입장에서 내구성을 신뢰할 수 없음.&lt;/li&gt;
&lt;li&gt;쓰기를 폐기하는 방식의 경우 DB 외부의 다른 저장소 시스템에서 DB 내용에 맞춰 조정되는 경우 문제 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Github 실제 사례, MySQL과 Redis 간 데이터 불일치
&lt;ul&gt;
&lt;li&gt;MySQL의 팔로워가 리더로 승격. 이 팔로워가 이전 리더의 쓰기 내역을 완벽히 갱신하지 못함&lt;/li&gt;
&lt;li&gt;새로운 리더에는 없고, 이전 리더에만 존재하는 기본키를 레디스에서는 사용하고 있었음.&lt;/li&gt;
&lt;li&gt;새로운 팔로워는 이미 할당된 기본키를 재사용 → 레디스와 MySQL간의 데이터 불일치 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05_network-glitch.png&#34; alt=&#34;Network Glitch&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스플릿 브레인(Split Brain)
&lt;ul&gt;
&lt;li&gt;특정 결함 시나리오에서 두 노드가 자신이 리더라고 인식&lt;/li&gt;
&lt;li&gt;두 리더가 각자 쓰기 요청을 처리하기 때문에 쓰기 충돌이 발생&lt;/li&gt;
&lt;li&gt;쓰기 충돌을 해소하지 못하면 데이터가 유실 또는 오염된다.&lt;/li&gt;
&lt;li&gt;둘 이상의 리더가 감지되면 하나를 종료하는 메커니즘도 있으나 잘못 설계 시 둘 모두가 종료될 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;죽었다고 판단하기에 적절한 타임아웃 값을 정하기가 어렵다.
&lt;ul&gt;
&lt;li&gt;타임아웃이 길면 → 복구에 너무 오랜 시간이 소요&lt;/li&gt;
&lt;li&gt;타임아웃이 짧으면 → 불필요한 장애복구 발생&lt;/li&gt;
&lt;li&gt;노드의 응답시간 조차 일시적인 부하 급증, 네트워크 문제 등으로 일정할 수 없다.&lt;/li&gt;
&lt;li&gt;시스템이 높은 부하, 네트워크 문제와 씨름 중인 경우 불필요한 장애 복구는 상황을 악화시킬 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복제-로그-구현&#34;&gt;복제 로그 구현&lt;/h3&gt;
&lt;p&gt;리더 기반 복제는 내부적으로 어떻게 동작하는가? 다음과 같은 다양한 복제 방법을 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구문(Statement) 기반 복제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;요청받은 구문을 기록하고 쓰기를 실행한 다음 구문을 팔로워에게 전송
&lt;ul&gt;
&lt;li&gt;RDB : INSERT, UPDATE, DELETE &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;비결정적인 요인에 의해 복제가 깨질 수 있다.
&lt;ul&gt;
&lt;li&gt;NOW(), RAND() 등은 복제 서버마다 다른 값을 생성할 가능성이 존재&lt;/li&gt;
&lt;li&gt;자동증가 컬럼을 사용하거나, 기존 데이터에 의존하는 경우(WHERE) 정확히 같은 순서로 실행되어야 함&lt;/li&gt;
&lt;li&gt;순서가 다르면 구문의 효과가 다를 수 있음 → 동시에 여러 트랜잭션이 수행되는 것을 제한한다.&lt;/li&gt;
&lt;li&gt;부수효과를 가진 구문의 경우 부수효과가 완벽히 결정적이어야 모든 팔로워에서 그 효과도 동일하다.&lt;/li&gt;
&lt;li&gt;트리거, 스토어드 프로시저, 사용자 정의 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;대안은 리더가 구문 기록 시 비결정적 함수 호출을 고정 값을 반환하도록 대체하는 것
&lt;ul&gt;
&lt;li&gt;여러 에지 케이스가 있어 현재는 다른 방식을 선호&lt;/li&gt;
&lt;li&gt;MySQL은 비결정성 요인이 있으면 로우 기반 복제 방식으로 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;쓰기 전 로그(WAL, write-ahead log) 배송&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 데이터베이스의 모든 쓰기는 로그에 기록이 된다.&lt;/li&gt;
&lt;li&gt;리더가 로그를 팔로워에게 전송하고, 팔로워는 이 로그를 처리함으로써 복제한다.&lt;/li&gt;
&lt;li&gt;로그는 제일 저수준의 데이터를 기술함
&lt;ul&gt;
&lt;li&gt;디스크 블록에서 어떤 데이터를 변경했는 지와 같은 상세 정보 포함&lt;/li&gt;
&lt;li&gt;복제 프로세스가 저장소 엔진과 밀접하게 연관된다.&lt;/li&gt;
&lt;li&gt;리더와 팔로워가 동일한 소프트웨어 버전에서 실행되어야 한다.&lt;/li&gt;
&lt;li&gt;소프트웨어 업그레이드 시 중단 시간이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PostgresQL, Oracle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;논리적(로우 기반) 로그 복제&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그를 저장소 엔진과 분리하기 위한 대안으로 복제와 저장소 엔진에 각기 다른 로그 형식을 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;논리적 로그(logical log)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;이와 같이 복제에서 사용하는 로그를 저장소 엔진의 물리적 데이터 표현과 구별하여 부른다.&lt;/li&gt;
&lt;li&gt;RDBMS에서 논리적 로그는 대개 로우 단위이고, 테이블에 쓰기를 기술한 레코드 열이다.
&lt;ul&gt;
&lt;li&gt;삽입된 로우 : 모든 컬럼의 새로운 값을 포함&lt;/li&gt;
&lt;li&gt;삭제된 로우 : 로우를 식별하기 위한 정보(보통 기본 키)를 포함&lt;/li&gt;
&lt;li&gt;갱신된 로우 : 로우를 식별하기 위한 정보 + 모든 컬럼의 새로운 값 또는 변경된 컬럼의 새로운 값&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션 커밋을 레코드에 표시&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;논리적 로그와 저장소 엔진 내부를 분리
&lt;ul&gt;
&lt;li&gt;하위 호환성을 유지&lt;/li&gt;
&lt;li&gt;리더와 팔로워가 각기 다른 버전의 소프트웨어에서 실행 가능&lt;/li&gt;
&lt;li&gt;심지어 저장소 엔진이 다를 수도 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;논리적 로그는 외부 애플리케이션이 파싱하기 쉽다.
&lt;ul&gt;
&lt;li&gt;데이터 웨어하우스와 같은 외부 시스템에 데이터베이스 내용 전송 시 유용하다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;변경 데이터 캡쳐(CDC, change data capture)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;트리거 기반 복제&lt;/strong&gt;&lt;br&gt;
지금까지 설명한 복제 방식은 애플리케이션의 관여 없이 DB 시스템에 의해 구현되었다.&lt;/p&gt;
&lt;p&gt;때로는 복제 방식에 유연성이 요구되며 애플리케이션이 관여할 필요가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Oracle의 GoldenGate : 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있도록 함&lt;/li&gt;
&lt;li&gt;많은 RDBMS : 트리거, 스토어드 프로시저 제공&lt;/li&gt;
&lt;li&gt;트리거(trigger)
&lt;ul&gt;
&lt;li&gt;사용자 정의 애플리케이션 코드를 등록할 수 있다.&lt;/li&gt;
&lt;li&gt;데이터 변경 시(쓰기 트랜잭션) 자동으로 실행된다.&lt;/li&gt;
&lt;li&gt;트리거를 통해 데이터 변경을 분리된 테이블에 로깅한다.&lt;/li&gt;
&lt;li&gt;이 테이블에 기록된 데이터 변경을 외부 프로세스가 읽고 처리한다.&lt;/li&gt;
&lt;li&gt;필요한 애플리케이션 로직 적용 후 다른 시스템에 데이터 변경을 복제한다.&lt;/li&gt;
&lt;li&gt;ex. Oracle의 Databus, PostgresQL의 Bucardo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;트리거 방식의 장단점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트리거 기반 복제는 다른 복제 방식보다 많은 오버헤드가 있다.&lt;/li&gt;
&lt;li&gt;그리고 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생한다.&lt;/li&gt;
&lt;li&gt;그럼에도 불구하고 유연성 때문에 매우 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;복제-지연-문제&#34;&gt;복제 지연 문제&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;읽기 확장(read-scaling) 아키텍처&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 리더와 여러 팔로워로 구성&lt;/li&gt;
&lt;li&gt;리더는 읽기 + 쓰기, 팔로워는 읽기 요청 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 아키텍처의 장점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹 서비스의 경우 읽기 요청이 대부분, 쓰기 요청은 작은 비율로 구성&lt;/li&gt;
&lt;li&gt;리더의 부하를 경감하고 복제 서버에서 읽기 요청을 처리 → 웹 서비스에 적합&lt;/li&gt;
&lt;li&gt;복제의 목표 중 확장성, 지연시간 단축 달성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단점은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비동기식 복제 방식에서만 동작한다.&lt;/li&gt;
&lt;li&gt;동기식 복제는 단일 노드의 장애, 네트워크 중단이 전체 시스템의 쓰기를 마비시켜 적절하지 않음&lt;/li&gt;
&lt;li&gt;노드가 많아질 수록 다운될 가능성이 커져 동기식 설정과 적절하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일시적인 데이터 불일치와 최종적 일관성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비동기 팔로워에서 데이터를 읽을 경우 지난 데이터를 읽을 수 있음 → 데이터 불일치 발생&lt;/li&gt;
&lt;li&gt;불일치는 일시적이다. 결국 팔로워는 리더를 따라잡게 된다. → 최종적 일관성&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Tip&lt;/div&gt;


**최종적 일관성 (Eventual Consistency)**

분산 컴퓨팅 환경에서 사용되는 일관성 모델 중 하나. 일시적으로는 데이터의 일관성이 깨지는 것을 허용한다.

그러나 최종적으로는 (데이터의 변경사항이 없다면) 데이터 대한 모든 접근들에 대해 마지막으로 갱신된 값을 반환하는 것을 보장한다.
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;복제 지연&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정상적인 경우 복제 지연으로 인한 데이터 불일치는 찰나의 순간이고 크게 문제가 되지 않음&lt;/li&gt;
&lt;li&gt;시스템이 가용량 근처에서 동작하거나 네트워크 문제가 있다면 복제 지연으로 인한 불일치가 문제가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;복제 지연으로 인해 발생 가능한 사례는 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;h3 id=&#34;자신이-쓴-내용-읽기&#34;&gt;자신이 쓴 내용 읽기&lt;/h3&gt;
&lt;p&gt;복제 지연으로 인해 사용자가 자신이 제출한 레코드를 읽지 못할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-3.png&#34; alt=&#34;그림 5-3&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-3. 사용자 쓰기를 한 다음 새로운 내용이 반영되지 않은 복제 서버에서 데이터를 읽는다. 이런 이상 현상을 방지하려면 쓰기 후 읽기(read-after-write) 일괄성이 필요하다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;쓰기 후 읽기(read-after-write) 일관성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자신의 쓰기 읽기 일관성&lt;/li&gt;
&lt;li&gt;사용자가 페이지를 리로딩하면 자신이 제출한 모든 갱신을 볼수 있음을 보장한다.
&lt;ul&gt;
&lt;li&gt;다른 사용자가 제출한 것에 대해서는 보장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그러면 어떻게 이를 구현할까?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리더 기반 복제 시스템에서 쓰기 후 읽기 일관성 구현하기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 수정한 내용을 읽을 때에는 리더에서 읽는다. 이 외의 경우는 팔로워에서 읽는다.
&lt;ul&gt;
&lt;li&gt;ex. SNS
&lt;ul&gt;
&lt;li&gt;사용자 프로필은 소유자 자신만 편집이 가능하다. → 자신의 프로필 조회는 리더에서 조회&lt;/li&gt;
&lt;li&gt;다른 사용자의 프로필은 팔로워에서 조회&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;시간을 기준으로 판단하기
&lt;ul&gt;
&lt;li&gt;애플리케이션 내 대부분의 내용에 대해 사용자 편집이 가능하면 첫 번째 방식은 적합하지 않다.&lt;/li&gt;
&lt;li&gt;다른 기준이 필요.&lt;/li&gt;
&lt;li&gt;레코드의 마지막 갱신 시각을 기준으로(ex. 1분 이내) 리더 읽기 여부를 구분하기&lt;/li&gt;
&lt;li&gt;팔로워에서 복제 지연을 모니터링 하여 1분 이상 늦은 팔로워에 대한 질의 금지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트가 기억하는 가장 최근 쓰기의 타임스탬프를 사용하기
&lt;ul&gt;
&lt;li&gt;시스템은 팔로워에게 타임스탬프까지 갱신을 반영하도록 할 수 있음&lt;/li&gt;
&lt;li&gt;복제서버에 아직 갱신이 반영되지 않았다면?
&lt;ul&gt;
&lt;li&gt;다른 복제 서버가 읽기 요청을 처리&lt;/li&gt;
&lt;li&gt;복제 서버에 갱신이 반영될 때 까지 질의를 대기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;타임스탬프는 논리적 의미의 타임스탬프 또는 실제 시스템 시간일 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;복제 서버가 여러 데이터센터에 분산된 경우
&lt;ul&gt;
&lt;li&gt;사용자에게 지리적 근접성, 가용성을 보장하기 위해 설계된 경우&lt;/li&gt;
&lt;li&gt;리더가 제공해야하는 요청은 전부 리더가 포함된 데이터센터로 라우팅되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;또 다른 문제 : 디바이스 간(cross-device) 쓰기 후 읽기 일관성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동일한 사용자가 여러 디바이스(데스크톱 웹 브라우저, 모바일 앱)로 서비스에 접근하는 경우&lt;/li&gt;
&lt;li&gt;하나의 디바이스에서 방금 입력한 정보가 다른 디바이스에서도 조회되어야 한다.&lt;/li&gt;
&lt;li&gt;디바이스 간 쓰기 후 읽기 일관성이 보장되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;멀티 디바이스 사용자 환경에서는 다음과 같은 문제를 추가적으로 고려해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자의 마지막 갱신 타임스탬프의 경우 다른 디바이스에서는 알 수가 없다.
&lt;ul&gt;
&lt;li&gt;이러한 메타데이터를 중앙집중식으로 관리해야 다른 디바이스에서도 확인이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;복제 서버가 여러 데이터센터 간에 분산된 경우
&lt;ul&gt;
&lt;li&gt;다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다.&lt;/li&gt;
&lt;li&gt;데스크톱 → 홈 광대역 연결, 모바일 기기 → 셀룰러 데이터 네트워크&lt;/li&gt;
&lt;li&gt;각 디바이스의 네트워크 라우팅은 완전히 다르다.&lt;/li&gt;
&lt;li&gt;사용자 디바이스의 요청을 동일한 데이터센터로 라우팅해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;단조-읽기&#34;&gt;단조 읽기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-4.png&#34; alt=&#34;그림 5-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-4. 사용자는 최신 복제 서버에서 먼저 읽고 그당므 예전 복제 서버에서 읽는다. 시간 역전 현상이 나타난다. 이런 이상 현상을 방지하려면 단조 읽기가 필요하다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시간이 거꾸로 흐르는 현상&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팔로워 간에도 동일한 쓰기에 대해 갱신 시점의 차이가 존재한다.&lt;/li&gt;
&lt;li&gt;동일한 읽기 요청을 여러번 보낼 때 각기 다른 팔로워에게 전달이 될 수 있다.&lt;/li&gt;
&lt;li&gt;어떤 팔로워는 쓰기를 알고 있으나, 어떤 팔로워는 모른다면 시간이 거꾸로 흐르는 현상을 겪을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단조 읽기(monotonic read)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위와 같은 종류의 이상 현상이 발생하지 않음을 보장한다.&lt;/li&gt;
&lt;li&gt;강한 일관성 보다는 덜하고, 최종적 일관성 보다는 강한 보장이다.&lt;/li&gt;
&lt;li&gt;한 사용자가 여러 번에 걸쳐 읽어도 시간이 되돌아가는 현상을 경험하지 않는다.&lt;/li&gt;
&lt;li&gt;이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;단조 읽기를 달성하는 방법은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되도록 한다.&lt;/li&gt;
&lt;li&gt;사용자 ID의 해시를 기반으로 복제 서버를 선택&lt;/li&gt;
&lt;li&gt;복제 서버가 고장나면 사용자 질의를 다른 복제 서버로 재라우팅할 필요가 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;일관된-순서로-읽기&#34;&gt;일관된 순서로 읽기&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;인과성의 위반&lt;/strong&gt;
예시용 대화를 하나 보자. 다음 대화에는 인과성이 있다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;푼스 씨 : 미래에 대해 얼마나 멀리 볼 수 있나요. 케이크 부인?&lt;/em&gt;&lt;br&gt;
&lt;em&gt;케이크 부인 : 보통 10초 정도요, 푼스 씨.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이제 팔로워를 통해 이 대화를 듣고 있는 제3자 관찰자가 있다고 상상해보자.&lt;br&gt;
케이크 부인이 한 말은 거의 지연없이 팔로워에게 전달이 되었으나 푼스 씨가 한 말은 긴 복제 지연이 있었다.&lt;br&gt;
이런 상황에서 관찰자는 대화를 다음과 같이 들을 것이다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;케이크 부인 : 보통 10초 정도요, 푼스 씨.&lt;/em&gt;&lt;br&gt;
&lt;em&gt;푼스 씨 : 미래에 대해 얼마나 멀리 볼 수 있나요. 케이크 부인?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이를 그림으로 표현하면 다음과 같다.&lt;/p&gt;
&lt;p&gt;파티션 간의 복제 시점에 차이가 있다면 관찰자 입장에서 질문 보다 대답을 먼저 확인할 가능성이 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-5.png&#34; alt=&#34;그림 5-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-5. 일부 파티션이 다른 것보다 느리게 복제되는 경우 관찰자는 질문을 보기 전에 대답을 볼 수 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;일관된 순서로 읽기(consistence prefix read)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이러한 종류의 이상현상을 방지하기 위해 일관된 순서로 읽기와 같은 유형의 보장이 필요&lt;/li&gt;
&lt;li&gt;일련의 쓰기가 특정 순서로 발생한 경우 다른 사용자에게도 쓰기에 대해 쓰여진 순서대로 읽는 것을 보장&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인과성의 위반&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;**파티셔닝(샤딩)**된 데이터베이스에서 발생하는 특징적인 문제&lt;/li&gt;
&lt;li&gt;많은 분산 데이터베이스에서 파티션은 서로 독립적으로 동작 → 쓰기의 전역 순서가 없음&lt;/li&gt;
&lt;li&gt;한 가지 해결책은 서로 인과성이 있는 쓰기에 대해 동일한 파티션에 기록되도록 하는 방법&lt;/li&gt;
&lt;li&gt;그러나 일부 애플리케이션에서 효율적이지 않음&lt;/li&gt;
&lt;li&gt;인과성을 명시하기 위한 알고리즘 → 이후(이전 발생 관계와 동시성)에 다룰 예정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;복제-지연을-위한-해결책&#34;&gt;복제 지연을 위한 해결책&lt;/h3&gt;
&lt;p&gt;해결 방안으로는 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 후 읽기와 같은 강한 보장을 제공하도록 시스템을 설계
&lt;ul&gt;
&lt;li&gt;비동기식 복제를 사용하지만 동기식 방식으로 동작하는 것 처럼 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;애플리케이션이 데이터베이스보다 더 강력한 보장을 제공하는 방법도 있다.
&lt;ul&gt;
&lt;li&gt;ex. 특정 종류의 리더에서 읽기를 수행&lt;/li&gt;
&lt;li&gt;그러나 애플리케이션에서 다루기에는 복잡하여 잘못되기 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;트랜잭션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션이 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법&lt;/li&gt;
&lt;li&gt;애플리케이션 개발자가 미묘한 복제 문제를 걱정하지 않는다.&lt;/li&gt;
&lt;li&gt;또한 올바른 작업 수행을 위해 항상 데이터베이스를 신뢰할 수 있다.&lt;/li&gt;
&lt;li&gt;이것이 트랜잭션이 존재하는 이유&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;분산 시스템에서의 트랜잭션&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 노드에 대한 트랜잭션을 오랫동안 존재했음&lt;/li&gt;
&lt;li&gt;분산(복제, 파티셔닝 된) 데이터베이스 상에선 많은 시스템이 트랜잭션을 포기&lt;/li&gt;
&lt;li&gt;트랜잭션은 가용성과 성능 측면에서 너무 비싸다.&lt;/li&gt;
&lt;li&gt;확장 가능한 시스템에서는 최종적 일관성을 선택하는 것이 불가피하다는 주장도 존재&lt;/li&gt;
&lt;li&gt;이러한 주장의 일부는 사실이지만 지나치게 단순화된 측면이 있다.&lt;/li&gt;
&lt;li&gt;트랜잭션 및 대안 메커니즘에 대해서는 이후 챕터에서 다룰 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;다중-리더-복제&#34;&gt;다중 리더 복제&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;다중 리더&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 처리를 하는 각 노드는 데이터 변경을 모든 노드에 전달하는데 이를 다중 리더 설정 (마스터 마스터, 액티브/액티브 복제라고도 함)&lt;/li&gt;
&lt;li&gt;여기서 각 리더는 동시에 다른 리더의 팔로워 역할도함&lt;/li&gt;
&lt;li&gt;모든 쓰기를 해당 리더를 거쳐야 하고, 리더 연결이 불가능한 경우 쓰기 불가능한 단점 보완&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다중-리더-복제의-사용-사례&#34;&gt;다중 리더 복제의 사용 사례&lt;/h3&gt;
&lt;p&gt;다중 데이터 센터 운영&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-6.png&#34; alt=&#34;그림 5-6&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-6. 다중 데이터센터 간 다중 리더 복제&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;다중 리더 설정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 데이터 센터마다 리더&lt;/li&gt;
&lt;li&gt;각 데이터 센터내 리더 팔로워 복제&lt;/li&gt;
&lt;li&gt;각 데이터 센터 간 리더가 다른 데이터 센터 리더에게 변경 사항 복제&lt;/li&gt;
&lt;li&gt;동일한 데이터를 다른 두 개의 데이터센터에서 동시에 변경 가능하므로 쓰기 충돌은 반드시 해소되어야함&lt;/li&gt;
&lt;li&gt;일부 데이터베이스는 기본적으로 다중 리더 설정 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단일 리더, 다중 리더 설정 비교&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;성능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 : 쓰기는 인터넷을 통해 리더가 있는 데이터 센터로 이동해야해서 쓰기 지연 발생&lt;/li&gt;
&lt;li&gt;다중 리더 : 쓰기는 로컬 데이터센터 처리 후 비동기 방식으로 다른 데이터센터에 복제&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;데이터센터 중단 내성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 : 리더가 있는 데이터센터가 고장 나면 다른 데이터센터의 팔로워를 리더로 승진&lt;/li&gt;
&lt;li&gt;다중 리더 : 각 데이터센터 독립적으로 동작, 고장난 데이터센터가 온라인으로 돌아왔을때 복제&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;네트워크 문제 내성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 : 데이터 센터 내 쓰기는 동기식이기에 데이터 센터 내 연결 문제에 민감&lt;/li&gt;
&lt;li&gt;다중 리더 : 비동기 복제를 사용해 네트워크 문제에 보다 잘 견딤, 일시적 네트워크 중단에도 쓰기 처리는 진행되기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;사용 사례 - 오프라인 작업을 하는 클라이언트&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인터넷 연결이 끊어진 동안 애플리케이션 동작해야 하는 경우&lt;/li&gt;
&lt;li&gt;협업 편집 : 동시에 여러 사람이 문서를 편집할 수 있는 애플리케이션 ex) 이더패드, 구글 독스 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰기-충돌-다루기&#34;&gt;쓰기 충돌 다루기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-7.png&#34; alt=&#34;그림 5-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-7. 동일한 레코드를 두 리더가 동시에 갱신하면 쓰기 충돌이 발생한다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다중 리더 복제에서 가장 큰 문제는 쓰기 충돌&lt;/li&gt;
&lt;li&gt;각 사용자가 동시에 편집 후 로컬 리더에 저장하였으나 변경을 비동기로 복제 시 쓰기 충돌 발생&lt;/li&gt;
&lt;li&gt;동기식으로 충돌 감지를 하면 다중 리더 복제의 장점을 잃어버림&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;충돌 회피&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;충돌 처리하는 가장 간단한 전략&lt;/li&gt;
&lt;li&gt;충돌 처리가 어려워 충돌 피하는 것이 자주 권장됨&lt;/li&gt;
&lt;li&gt;특정 레코드의 모든 쓰기를 동일한 리더에서 처리함&lt;/li&gt;
&lt;li&gt;ex) 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장
→ 동일한 데이터센터로 라우팅하는 것이 아니면 충돌 회피가 실패&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;일관된 상태 수렴&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 복제 서버가 동일해야 함이 원칙&lt;/li&gt;
&lt;li&gt;수렴(convergent) : 모든 변경이 복제돼 모든 복제 서버에 동일한 최종 값이 전달되게 해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;수렴 충돌 해소 방법들&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;각 쓰기에 고유 ID () 부여해 가장 높은 ID를 가진 쓰기를 선택&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;타임스탬프를 사용하는 경우를 최종 쓰기 승리라 한다.&lt;/li&gt;
&lt;li&gt;대중적이지만 데이터 유실 위험이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제서버에서 생긴 쓰기가 낮은 숫자의 복제 서버에서 생긴 쓰기보다 항상 우선적으로 적용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;데이터 유실 가능성있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;어떻게든 값을 병합&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;예로 사전 순 정렬 후 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;나중에 (사용자에게 알려줌) 충돌을 해소하는 애플리케이션 코드를 작성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;사용자 정의 충돌 해소 로직&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;충돌 해소의 가장 적합한 방법은 애플리케이션에 따라 다르다.&lt;/li&gt;
&lt;li&gt;따라서 대부분 다중 리더 복제도구는 애플리케이션 코드를 사용해 충돌 해소 로직 작성&lt;/li&gt;
&lt;li&gt;쓰기 수행 중 :
&lt;ul&gt;
&lt;li&gt;복제된 변경사항 로그에서 데이터베이스 시스템 충돌 감지되면 충돌 핸들러 호출&lt;/li&gt;
&lt;li&gt;백그라운드에서 실행됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;읽기 수행 중 :
&lt;ul&gt;
&lt;li&gt;충돌 감지 시 모든 충돌 쓰기 저장&lt;/li&gt;
&lt;li&gt;다음 번 읽기 시 여러 데이터 반환. 애플리케이션은 사용자에게 충돌 내용 보여주거나 자동으로 충돌 해소해 결과를 데이터베이스에 기록&lt;/li&gt;
&lt;li&gt;카우치DB가 이렇게 동작&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;자동 충돌 해소&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;충돌 없는 복제 데이터 타입
&lt;ul&gt;
&lt;li&gt;Set, Map, 정렬 목록, 카운터 등을 위한 데이터 구조의 집합&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;병합 가능한 영속 데이터 구조&lt;/li&gt;
&lt;li&gt;Git 처럼 명시적으로 히스토리 추적하고 삼중 병합 함수를 사용한다&lt;/li&gt;
&lt;li&gt;운영 변환&lt;/li&gt;
&lt;li&gt;이더패트, 구글 독스 같은 협업 편집 애플리케이션의 충돌 해소 알고리즘&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다중-리더-복제-토폴로지&#34;&gt;다중 리더 복제 토폴로지&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;복제 토폴로지&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복제 토폴로지는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로&lt;/li&gt;
&lt;li&gt;리더가 둘 이상이라면 다양한 토폴로지가 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-8.png&#34; alt=&#34;그림 5-8&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-8. 다중 리더 복제를 설정하는 세가지 토폴로지 예제&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;원형 토폴로지&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기를 다른 노드에 전달&lt;/li&gt;
&lt;li&gt;MySQL 에서 기본적으로 제공&lt;/li&gt;
&lt;li&gt;노드 장애 시 노드 간 복제 메시지 흐름에 방해를 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;별 모양 토폴로지&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;지정된 루트 노드 하나가 다른 모든 노드에 쓰기 전달&lt;/li&gt;
&lt;li&gt;트리로 일반화 가능&lt;/li&gt;
&lt;li&gt;노드 장애 시 노드 간 복제 메시지 흐름에 방해를 줌&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;전체 연결 토폴로지&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;모든 리더가 각자의 쓰기를 다른 모든 리더에 전송&lt;/li&gt;
&lt;li&gt;가장 일반적인 토폴로지&lt;/li&gt;
&lt;li&gt;내결함성이 상대적으로 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-9.png&#34; alt=&#34;그림 5-9&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-9. 다중 리더 복제에게 일부 복제 서버에 쓰기가 잘못된 순서로 도착할 수 있다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전체 연결 토폴로지의 문제점&lt;/li&gt;
&lt;li&gt;네트워크 연결 속도 차이로 인한 복제 메시지 추월&lt;/li&gt;
&lt;li&gt;리더2는 삽입 이전에 갱신을 처리하게 됨&lt;/li&gt;
&lt;li&gt;올바른 이벤트 정렬을 위한 버전 벡터 기법으로 해결 가능&lt;/li&gt;
&lt;li&gt;따라서 다중 리더 복제 시스템을 사용하려면 이런 문제를 인지하고 문서를 주의깊게 읽은 다음 데이터 베이스를 철저하게 테스트해봐야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;리더-없는-복제&#34;&gt;리더 없는 복제&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 하는 방식을 사용하기도 함&lt;/li&gt;
&lt;li&gt;다이나모 스타일 DB로 리악, 카산드라, 볼드모트 등 오픈소스 데이터스토어가 있음&lt;/li&gt;
&lt;li&gt;일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 코디네이터 노드가 클라이언트를 대신해 이를 수행하기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;노드가-다운됬을-때-데이터베이스에-쓰기&#34;&gt;노드가 다운됬을 때 데이터베이스에 쓰기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-10.png&#34; alt=&#34;그림 5-10&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-10. 정족수(quorum) 쓰기, 정족 수 읽기와 노드 중단 후 읽기 복구&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다운된 노드에서는 쓰기가 누락되어 오래된(outdated) 값을 읽게 됨&lt;/li&gt;
&lt;li&gt;읽기 요청을 병렬로 여러 노드에 전송해 최신 값을 읽어와 해결 가능&lt;/li&gt;
&lt;li&gt;버전 숫자를 통해 읽어온 값 중 최신 값을 결정함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;읽기 복구와 안티 엔트로피&lt;/strong&gt;
복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;읽기 복구
&lt;ul&gt;
&lt;li&gt;클라이언트가 여러 노드에서 병렬로 읽기 수행하면 오래된 응답 감지 가능&lt;/li&gt;
&lt;li&gt;복제 서버의 오래된 값을 새로운 값으로 기록&lt;/li&gt;
&lt;li&gt;값을 자주 읽는 상황에 적합&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;안티 엔트로피 처리
&lt;ul&gt;
&lt;li&gt;백그라운드 프로세스와 복제 서버 간 데이터 차이를 찾아 누락된 데이터를 복사&lt;/li&gt;
&lt;li&gt;특정 순서로 쓰기를 복사하기 때문에 지연이 있을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;정족수&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러 사람의 합의로 운영되는 의사기관에서 의결을 하는데 필요한 최소한의 참석자 수 (사전적 정의)&lt;/li&gt;
&lt;li&gt;유효한 읽기와 쓰기를 위한 복제서버 수, 쓰기 성공 노드 수, 질의 노드 수를 나타냄&lt;/li&gt;
&lt;li&gt;다이나모 스타일 DB에서는 복제 서버(n), 쓰기 노드(w), 읽기 노드(r) 설정 가능&lt;/li&gt;
&lt;li&gt;일반적으로 n 은 3 또는 5 등의 홀수, w = r = (n+1) / 2 (반올림) 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-11.png&#34; alt=&#34;그림 5-11&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-11. w + r &amp;gt; n이면 읽는 r개의 복제 서버 중 최소한 하나는 가장 최근 성공한 쓰기를 알아야 한다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 읽기와 쓰기는 항상 모든 n개의 복제 서버에 병렬 전송한다.&lt;/li&gt;
&lt;li&gt;w, r 은 기다릴 노드를 결정한다.&lt;/li&gt;
&lt;li&gt;읽기, 쓰기 성공 여부는 읽기, 쓰기가 성공한 노드의 갯수로 확인한다.&lt;/li&gt;
&lt;li&gt;w, r개 보다 사용가능한 노드 수가 적다면 에러를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;정족수-일관성의-한계&#34;&gt;정족수 일관성의 한계&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;w + r &amp;gt; n 으로 설정하면 읽은 노드 중 최신 값을 가진 노드가 하나 이상이어야 함. (그림 5-11)&lt;/li&gt;
&lt;li&gt;그러나 모든 과정이 올바르게 동작해도 시점 문제로 오래된 값을 반환할 수 있음 (느슨한 정족수 사용)&lt;/li&gt;
&lt;li&gt;즉, 정족수를 아무리 잘 설정해도 오래된 값을 읽을 가능성이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;느슨한-정족수와-암시된-핸드오프&#34;&gt;느슨한 정족수와 암시된 핸드오프&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;정족수 불충족&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 중단으로 데이터베이스 노드와 클라이언트 연결 유실&lt;/li&gt;
&lt;li&gt;응답 가능한 노드가 w, r보다 적을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;느슨한 정족수&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정족수 불충족 상황에서 보통 저장하는 노드가 아닌 연결이 가능한 다른 노드에 쓰기를 하는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;암시된 핸드오프&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 장애가 해제되면 일시적으로 수옹한 모든 쓰기를 해당 홈 노드로 전송&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;동시-쓰기-감지&#34;&gt;동시 쓰기 감지&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용해 엄격한 정족수를 사용해도 충돌이 발생할 수 있음&lt;/li&gt;
&lt;li&gt;문제는 네트워크 지연 등으로 이벤트가 다른 노드에 다른 순서로 도착할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-12.png&#34; alt=&#34;그림 5-12&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-12. 다이나모 스타일 데이터스토어에ㅔ 동시 쓰기 잘 정의된 순서가 없다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;get 요청에서 노드들마다 읽어오는 값이 달라 일관성이 깨짐&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;최종 쓰기 승리 (동시 쓰기 버리기)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복제본을 가장 최신 값으로 덮어 쓰는 방법&lt;/li&gt;
&lt;li&gt;쓰기에 타임스탬프를 붙여 최신 값을 선택하는 방법 (LWW)&lt;/li&gt;
&lt;li&gt;손실 데이터를 허용하지 않는다면 LWW가 부적합&lt;/li&gt;
&lt;li&gt;카산드라에서 유일하게 제공하는 충돌 해소 방법, 리악에서는 선택적 기능&lt;/li&gt;
&lt;li&gt;키를 한번만 쓰고 이후에 불변값으로 만들어 동시에 같은 키를 갱신하는 상황을 방지해야 함&lt;/li&gt;
&lt;li&gt;카산드라 사용 시 키로 UUID를 사용해 모든 쓰기작업에 고유한 키를 부여하는 것을 추천&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이전 발생&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;작업 B가 작업 A에 대해 알거나 A에 의존적이거나, 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 이전 발생이라 함&lt;/li&gt;
&lt;li&gt;작업이 다른 작업보다 먼저 발생하지 않으면 (어느 작업도 다른 작업에 대해 알지 못하면) 동시 작업이라 일컫음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이전 발생 관계 파악하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-13.png&#34; alt=&#34;그림 5-13&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-13. 두 클라이언트가 동시에 장바구니를 수정하는 동안 인과성 파악하기&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;버전\클라이언트&lt;/th&gt;
          &lt;th&gt;클라이언트 1&lt;/th&gt;
          &lt;th&gt;클라이언트 2&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;버전 1&lt;/td&gt;
          &lt;td&gt;우유&lt;/td&gt;
          &lt;td&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;버전 2&lt;/td&gt;
          &lt;td&gt;우유&lt;/td&gt;
          &lt;td&gt;달걀&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;버전 3&lt;/td&gt;
          &lt;td&gt;우유, 밀가루&lt;/td&gt;
          &lt;td&gt;달걀&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;버전 4&lt;/td&gt;
          &lt;td&gt;우유, 밀가루&lt;/td&gt;
          &lt;td&gt;달걀, 우유, 햄&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;버전 5&lt;/td&gt;
          &lt;td&gt;우유, 밀가루, 달걀, 베이컨&lt;/td&gt;
          &lt;td&gt;달걀, 우유, 햄&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;client1 - 우유 추가, version1 = [(우유)]&lt;/li&gt;
&lt;li&gt;client2 - 달걀 추가, version2 = [(우유) , (달걀)]&lt;/li&gt;
&lt;li&gt;client1 - 밀가루 추가, version3 = [(우유, 밀가루), (달걀)]&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;1번 응답인 우유에 밀가루 추가, version2 값 달걀&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;client2 - 햄 추가, version4 = [(달걀, 우유, 햄), (우유, 밀가루)]&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;2번 응답인 우유, 달걀에 햄 추가, version3의 우유, 밀가루&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;client1 - 베이컨 추가, version5 = [(우유, 밀가루, 달걀, 베이컨), (달걀, 우유, 햄)]&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;3번 응답인 우유, 밀가루, 달걀에 베이컨 추가, version4의 달걀, 우유, 햄&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/05-14.png&#34; alt=&#34;그림 5-14&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 5-14. 그림 5-14의 인과성 도표&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동시, 이전 발생 결정 알고리즘&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;06.서버가 모든 키에 대한 버전 번호 유지, 버전 번호 증가하며 키를 기록함&lt;/li&gt;
&lt;li&gt;클라이언트가 키를 읽을 때는 최신 버전과 덮어쓰지 않은 모든 값 반환&lt;/li&gt;
&lt;li&gt;클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고 이전 읽기에서 받은 모든 값을 함께 합침&lt;/li&gt;
&lt;li&gt;서버가 특정 번호를 가진 쓰기를 받을 때는 해당 버전 이하 모든 값을 덮어쓸 수 있지만 높은 버전 번호의 값은 유지해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동시에 쓴 값 병함&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;위 알고리즘은 데이터가 자동으로 삭제되지 않지만 클라이언트의 추가 작업이 필요&lt;/li&gt;
&lt;li&gt;동시에 쓴 값을 합쳐 정리하는 걸 리악에서 형제(sibling) 라 부름&lt;/li&gt;
&lt;li&gt;값을 제거할 때에는 제거했다고 버젼에 표시를 남겨야하는데 이를 툼스톤이라고 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;버전 벡터 (version vector)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 복제본의 버전 번호 모음을 나타냄&lt;/li&gt;
&lt;li&gt;리악2.0 에서 도티드 버전 벡터로 버전 벡터를 변형해 사용함&lt;/li&gt;
&lt;li&gt;값을 읽을 때 데이터베이스 복제본에서 클라이언트로, 값이 기록될 때 데이터베이스로 전송
&lt;ul&gt;
&lt;li&gt;쓰기 시 버전 번호 증가, 다른 복제본의 번호도 추적해 덮어쓸 값, 형제 값을 구분함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터베이스는 덮어쓰기와 동시 쓰기를 구분할 수 있음&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 06장. 파티셔닝</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/06/</link>
      <pubDate>Fri, 18 Mar 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/06/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 박현도, 이승익&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;파티셔닝&#34;&gt;파티셔닝&lt;/h2&gt;
&lt;p&gt;데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이 작업을 파티셔닝 또는 샤딩이라고 한다.&lt;/p&gt;
&lt;p&gt;파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 한다. 데이터베이스가 여러 파티션을 동시에 건드리는 연산을 지원할 수도 있지만 결과적으로 각 파티션은 그 자체로 작은 데이터베이스가 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;즉 테이블은 논리적인 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해주는 기능이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_partition.png&#34; alt=&#34;파티션&#34;&gt;&lt;br&gt;
&lt;em&gt;출처 : Real MySQL 8.0&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;파티셔닝을-하는-주된-이유&#34;&gt;파티셔닝을 하는 주된 이유&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;확장성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;비공유 클러스터에서 다른 파티션은 다른 노드에 저장될 수 있다. 따라서 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.&lt;/li&gt;
&lt;li&gt;단일 파티션에 실행되는 질의를 생각해 보면 각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있다. 크고 복작한 질의는 훨씬 더 어렵기는 하지만 여러 노드에서 병렬 실행이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;이력 데이터의 효율적인 관리&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결 가능&lt;/li&gt;
&lt;li&gt;ex) 로그 데이터 - 단기간에 대량으로 누적되며 일정 기간이 지나면 쓸모가 없어지는 데이터이며 삭제하며 백업할 때 고부하 작업&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;파티셔닝과-복제&#34;&gt;파티셔닝과 복제&lt;/h2&gt;
&lt;p&gt;보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결합성을 보장할 수 있다는 의미이다.&lt;/p&gt;
&lt;p&gt;한 노드에 여러 파티션을 저장할 수도 있다. 리더 팔로워 복제 모델을 사용한다면 파티셔닝과 복제의 조합은 아래와 같은 형태가 된다.&lt;/p&gt;
&lt;p&gt;각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당된다.&lt;/p&gt;
&lt;p&gt;각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_Partitioning_copy.png&#34; alt=&#34;파티셔닝과 복제&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;키-값-데이터-파티셔닝&#34;&gt;키-값 데이터 파티셔닝&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;skewed(쏠림): 파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있는 경우&lt;/li&gt;
&lt;li&gt;hotspot(핫스팟) : 불균형하게 부하가 높은 파티션을 지칭하는 용어&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;키-범위-기준-파티셔닝&#34;&gt;키 범위 기준 파티셔닝&lt;/h3&gt;
&lt;p&gt;각 파티션에 연속된 범위의 키를 할당하는 것이다. 이를 통해 각 범위들 사이의 경계를 알 수 있고 어떤 키가 어떤 파티션에 속하는지 쉽게 찾을 수 있다.
또한, 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.&lt;br&gt;
ex) 어떤 최솟값에서 최대값까지&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;CREATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TABLE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;employees&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;INT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;first_name&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;VARCHAR&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;last_name&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;VARCHAR&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;30&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;reg_date&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;DATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;NOT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;NULL&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;DEFAULT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;1970-01-01&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;....&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PARTITION&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;BY&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;RANGE&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;YEAR&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;hired&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PARTITION&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p0&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;LESS&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;THAN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2000&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PARTITION&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p1&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;LESS&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;THAN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2010&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PARTITION&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p2&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;LESS&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;THAN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;2020&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;),&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;PARTITION&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;p3&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;VALUES&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;LESS&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;THAN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;MAXVALUE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;);&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_partition_insert.png&#34; alt=&#34;파티션 insert&#34;&gt;&lt;br&gt;
&lt;em&gt;출처 : Real MySQL 8.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지는 이점이 있고 키를 연쇄적 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어 오는데 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;ex) 애플리케이션에서 reg_date 칼럼 date type을 키로 사용한다고 하자. 이 경우 범위 스캔이 유용하다. 범위 스캔을 써서 특정 년도의 모든 데이터를 쉽게 읽을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정한 접근 패턴이 핫스팟을 유발한다.&lt;/li&gt;
&lt;li&gt;reg_date가 키라면 파티션은 년(year) 범위에 대응된다. 예를 들어 1년의 데이터를 파티션 하나가 담당하는 식이다.&lt;/li&gt;
&lt;li&gt;데이터를 갱신할 때 마다 데이터베이스에 기록하므로 쓰기 연산이 모두 동일한 파티션(해당하는 year)으로 전달되어 해당 파티션만 과부하가 걸리고 나머지 파티션은 유휴 상태로 남을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;키의-해시값-기준-파티셔닝&#34;&gt;키의 해시값 기준 파티셔닝&lt;/h3&gt;
&lt;p&gt;해시 파티션은 특정 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법이다.&lt;/p&gt;
&lt;p&gt;파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다. 예를 들어 카산드라와 몽고 DB는 MD5를 쓰고 볼드모트는 파울러 놀보(Fowler-Noll-Vo) 함수를 사용한다. MySQL은 표현식의 결과값을 파티션의 개수로 나눈 나머지로 저장될 파티션을 결정한다.&lt;/p&gt;
&lt;p&gt;ex) 문자열을 입력으로 받는 32비트 해시 함수가 있다고 하자. 이 함수에 문자열을 넣으면 겉으로 보기에는 0과 2의 32승 -1 사이의 무작위 숫자를 반환한다. 입력 문자열이 거의 유사해도 해시값은 숫자 범위 내에서 균일하게 분산된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_hash.png&#34; alt=&#34;해시&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 6-3. 키의 해시값 기준 파티셔닝&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;쏠림과 핫스팟의 위험을 줄여 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;범위 질의를 효율적으로 실행할 수 있는 키 범위 파티셔닝의 좋은 속성을 잃어버린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;전에는 인접했던 키들이 이제는 모든 파티션에 흩어져서 정렬 순서가 유지되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;몽고 DB에서는 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다. 리악, 카우치베이스, 볼드모트에서는 기본키에 대한 범위 질의가 지원되지 않는다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Θ 카산드라&lt;br&gt;
카산드라는 두 가지 파티셔닝 전략 사이에서 타협한다. 카산드라에서 테이블을 선언할 때 여러 칼럼을 포함하는 &lt;strong&gt;복합 기본키&lt;/strong&gt;를 지정할 수 있다.&lt;br&gt;
키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다.&lt;br&gt;
&lt;strong&gt;즉, 복합 키의 첫 번째 칼럼에 대해서는 값 범위로 검색하는 질의를 쓸 수 없지만 첫 번째 칼럼에 고정된 값을 지정하면 키의 다른 칼럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ex) 소셜 미디어 사이트에서 사용자 한 명이 수정한 문서 여러 개를 올릴 수도 있다.&lt;/p&gt;
&lt;p&gt;특정한 사용자가 어떤 시간 구간에서 수정한 모든 문서를 타임스탬프 순으로 정렬해서 읽어올 수 있다.&lt;br&gt;
다른 사용자가 수정한 정보는 다른 파티션에 저장될 수도 있지만 한 사용자가 수정한 정보는 한 파티션 내에서 타임스탬프 순으로 정렬된 상태로 저장 된다.&lt;br&gt;
기본키 (user_id, update_timestamp)&lt;/p&gt;
&lt;h3 id=&#34;쏠린-작업부하와-핫스팟-완화&#34;&gt;쏠린 작업부하와 핫스팟 완화&lt;/h3&gt;
&lt;p&gt;앞에서 설명한 대로 키를 해싱해서 파티션을 정하면 핫스팟을 줄이는 데 도움이 된다. 그렇지만 핫스팟을 완벽히 제거할 수는 없다. 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다.&lt;br&gt;
ex) 소셜 미디어 사이트에서 수백만 명의 팔로워를 거느린 유명인이 뭔가를 하면 후폭풍이 발생할 수 있다. 유명인이 실행한 작업 때문에 동일한 키에 막대한 양의 데이터를 기록해야 할 수도 있다.&lt;br&gt;
(키는 아마도 유명인의 사용자 ID이거나 사람들이 댓글을 다는 액션의 ID). 동일한 ID의 해시값은 동일하므로 해싱은 아무런 도움이 되지 않는다.&lt;/p&gt;
&lt;p&gt;책에서 제안한 해결책&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각키의 시작이나 끝에 임의의 숫자를 붙인다. 임의의 10진수 두 개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산되고 그 키들은 다른 파티션으로 분산될 수 있다.&lt;/li&gt;
&lt;li&gt;그러나 다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 100개의 키에 해당 하는 데이터를 읽어서 조합해야 하기 때문이다. 추가적으로 저장해야 할 정보도 있다.&lt;/li&gt;
&lt;li&gt;이 기법은 요청이 몰리는 소수의 키에만 적용하는게 타당하다. 쓰기 처리량이 낮은 대다수의 키에도 적용하면 불필요한 오버헤드가 생긴다. 따라서 어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;파티셔닝과-보조-색인&#34;&gt;파티셔닝과 보조 색인&lt;/h2&gt;
&lt;p&gt;기본적으로 레코드를 기본키를 통해서만 접근한다면 키로부터 파티션을 결정하고 이를 사용해 해당 키를 담당하는 파티션으로 읽기 쓰기 요청을 전달할 수 있다.&lt;br&gt;
그러나 특정한 값이 발생한 항목을 검색하는 수단인 보조색인이 연관되면 복잡해 진다.&lt;br&gt;
&lt;strong&gt;보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점이 있기 때문이다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;문서-기준-보조-색인-파티셔닝&#34;&gt;문서 기준 보조 색인 파티셔닝&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_document_index.png&#34; alt=&#34;문서 기준 인덱스&#34;&gt;&lt;/p&gt;
&lt;p&gt;각 파티션에 속하는 문서만 담당하며 완전히 독립적으로 동작하는 색인 방법을 지역 색인(Local Index)이라고 한다.&lt;br&gt;
데이터베이스에 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때는 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다. 다른 파티션에 어떤 데이터가 저장되는지 신경 쓰지 않는다.&lt;br&gt;
ex) 중고차를 판매하는 웹사이트를 운영한다. 각 항목에는 Document ID라고 부르는 고유 ID가 있고 데이터베이스를 문서 ID기준으로 파티셔닝 한다. (Document ID 0 ~499 : 파티션0, Document ID 500 ~ 999: 파티션 1)&lt;/p&gt;
&lt;p&gt;color와 make에 보조 색인을 만들어야 한다. 색인을 선언했다면 데이터베이스가 자동으로 색인 생성을 할 수 있다. 예를 들어 빨간색 자동차가 데이터베이스에 추가되면 데이터베이스 파티션은 자동으로 그것을 color:red 색인 항목에 해당하는 문서 ID 목록에 추가한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주의할 점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문서 ID에 뭔가 특별한 작업을 하지 않는다면 특정한 색상이거나 특정한 제조사가 만든 자동차가 동일한 파티션에 저장되리라는 보장이 없다.&lt;/li&gt;
&lt;li&gt;위 이미지를 보면 빨간색 자동차는 파티션 0에도 있고 파티션 1에도 있다.&lt;/li&gt;
&lt;li&gt;따라서 빨간색 자동차를 찾고 싶다면 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;파티셔닝된 데이터베이스에 이런 식으로 질의를 보내는 방법을 스캐터/개더(scatter/gather)라고도 하는데 보조 색인을 써서 읽는 질의는 큰 비용이 들 수 있다.&lt;br&gt;
여러 파티션에서 질의를 병렬 실행 하더라도 스캐터/개더는 꼬리 지연 시간 증폭이 발생하기 쉽다. 그럼에도 보조 색인을 문서 기준으로 파티셔닝하는 경우가 많다.&lt;br&gt;
ex) 몽고 DB, 리악, 카산드라, 엘라스틱서치, 솔라클라우드, 볼트DB&lt;/p&gt;
&lt;p&gt;MySQL의 경우는 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당 한다. 파티션과 관계 없이 테이블 전체 단위로 글로벌하게 하나의 통합된 인덱스는 지원하지 않는다.&lt;br&gt;
그래서 WHERE 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐(Priority Queue)에 임시로 저장한다. 그리고 우선순위 큐에서 다시 필요한 순서대로 데이터를 가져간다.&lt;br&gt;
결과적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 MySQL 서버가 별도의 정렬 작업을 수행하지는 않는다. 일반 테이블의 인덱스 스캔터럼 결과를 바로 반환하지 않고 내부적으로 큐 처리가 한번 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;용어-기준-보조-색인-파티셔닝&#34;&gt;용어 기준 보조 색인 파티셔닝&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_term_index.png&#34; alt=&#34;용어 기준 인덱스&#34;&gt;&lt;/p&gt;
&lt;p&gt;지역 색인과 다르게 모든 파티션의 데이터를 담당하는 색인을 전역 색인(Global Index)이라고 한다.&lt;br&gt;
이러한 방법은 한 노드에만 색인을 저장할 경우 해당 노드가 병목이 되어 파티셔닝의 목적을 헤칠 수 있기 때문에 여러 노드에 나눠서 저장한다.&lt;/p&gt;
&lt;p&gt;찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다(term-partitioned)고 한다. 여기서는 color:red가 용어의 예다.&lt;/p&gt;
&lt;p&gt;ex) 모든 파티션에 있는 빨간색 자동차 정보는 색인에서 color:red 항목에 저장되지만 색깔 색인은 a부터 r까지의 글자로 시작하는 색깔은 파티션 0에, s부터 z까지의 글자로 시작하는 색깔은 파티션1에 저장되도록 파티셔닝 된다.&lt;/p&gt;
&lt;p&gt;자동차 제조사 색인도 마찬가지로 파티셔닝 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;특이점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이전처럼 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다. 용어 자체로 파티셔닝하면 범위 스캔(이를테면 자동차의 판매 희망가 같은 숫자 속성에 적용되는)에 유용한 반면 용어의 해시값을 사용해 파티셔닝하면 부하가 좀 더 고르게 분산된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;문서 파티셔닝 색인에 비해 전역(용어 파티셔닝) 색인이 갖는 이점은 &lt;strong&gt;읽기가 효율적이라는 것이다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;클라이언트는 모든 파티션에 스개터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;단점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있으며 쓰기가 느리고 복잡하다.&lt;/li&gt;
&lt;li&gt;(문서에 있는 모든 용어가 다른 노드에 있는 다른 파티션에 속할 수도 있다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이상적으로 색인은 항상 최신 상태에 있고 데이터베이스에 기록된 모든 문서는 바로 색인에 반영되어야 한다.&lt;br&gt;
하지만 용어 파티셔닝 색인을 사용할 때 그렇게 하려면 쓰기에 영향받는 모든 파티션에 걸친 분산 트랜잭션을 실행해야 하는데, 모든 데이터베이스에서 분산 트랜잭션을 지원하지는 않는다.&lt;/p&gt;
&lt;p&gt;현실에서는 전역 보조 색인은 대개 비동기로 갱신된다.(즉 쓰기를 실행한 후 바로 색인을 읽으면 변경 사항이 색인에 반영되지 않았을 수도 있다.)&lt;br&gt;
ex) 아마존 다이나모 DB는 정상적인 상황에서는 전역 보조 색인을 갱신하는 데 1초도 안 걸리지만 인프라에 결함이 생기면 반영 지연 시간이 더 길어질 수도 있다.&lt;/p&gt;
&lt;p&gt;전역 용어 파티셔닝 색인의 다른 사용처로는 리악의 검색 기능과 오라클 데이터 웨어하우스가 있다. 오라클 데이터 웨어하우스는 지역 색인과 전역 색인 사이에서 선택할 수 있다.&lt;/p&gt;
&lt;p&gt;Q) Local Index? Global Index? 어떤 것이 더 사용하기 좋은지?&lt;br&gt;
A) 물론 서비스 구조와 여러 가지를 고려해야겠지만 일반적으로 파티션 특성상 특정 파티션에 해당하는 작업(추가, 삭제)를 많이 하기 때문에 해당 작업 대상 파티션의 인덱스에만 영향을 받는 로컬 인덱스를 많이 사용 한다.
글로벌 인덱스 같은 경우는 파티션에 해당하는 작업을 하는 경우 전체 적으로 다시 재조정 작업을 해줘야 되기 때문에 부하가 많이 간다.&lt;/p&gt;
&lt;h2 id=&#34;파티션-재균형화&#34;&gt;파티션 재균형화&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;개요&lt;/strong&gt;
데이터베이스에 물리 장비에 대한 변화 발생&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU, RAM, DISK 추가&lt;/li&gt;
&lt;li&gt;새로운 노드 추가&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_node_move.png&#34; alt=&#34;노드 이동&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;재균형화(rebalancing)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;재균형화 요구사항&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부하 균등&lt;/li&gt;
&lt;li&gt;순단 X&lt;/li&gt;
&lt;li&gt;데이터 이동 최소화&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;재균형화-전략&#34;&gt;재균형화 전략&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;해시 값에 mod N(노드 개수) 연산&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_mode_calc_1.png&#34; alt=&#34;모드연산1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_mode_calc_2.png&#34; alt=&#34;모드연산2&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;모드 N 방식의 문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;노드 개수 N 이 바뀌면 대부분의 키가 노드 사이에 옮겨져야 함 → 재균형화 비용 상승&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;정적 파티셔닝 (파티션 개수 고정)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_partition_fix_1.png&#34; alt=&#34;파티션고정1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_partition_fix_2.png&#34; alt=&#34;파티션고정2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리악, 엘라스틱서치, 카우치베이스, 볼드모트 에서 사용됨&lt;/li&gt;
&lt;li&gt;전체 데이터셋의 크기 변동이 심하다면 적절한 파티션 개수를 정하기 어려움&lt;/li&gt;
&lt;li&gt;파티션이 너무 커지면 재균형화 및 장애 복구 비용이 큼&lt;/li&gt;
&lt;li&gt;적절한 크기를 정하는 것이 제일 Best, 하지만 어려움&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;동적 파티셔닝&lt;/strong&gt;
리스팅개발팀 &amp;gt; 06. 파티셔닝 &amp;gt; 동적파티셔닝1.png&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_dynamic_artitioning_1.png&#34; alt=&#34;동적 파티셔닝1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_dynamic_artitioning_2.png&#34; alt=&#34;동적 파티셔닝2&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파티션 개수가 전체 데이터 용량에 맞춰 조정됨 (크기를 제한하고 개수를 늘림)&lt;/li&gt;
&lt;li&gt;빈 데이터베이스의 경우 파티션 경계 설정 값에 도달하기 전에는 파티션이 1개임
&lt;ul&gt;
&lt;li&gt;HBase 와 MongoDB 는 빈 데이터베이스에 초기 파티션 집합을 설정할 수 있음 → 사전 분할 (pre-splitting)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;정적 파티셔닝 &amp;amp; 동적 파티셔닝 특징 정리&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정적 파티셔닝 : 파티션 크기가 데이터 크기에 비례&lt;/li&gt;
&lt;li&gt;동적 파티셔닝 : 파티션 개수가 데이터 크기에 비례&lt;/li&gt;
&lt;li&gt;두가지 모두 노드와는 관련이 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;노드 비례 파티셔닝&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_node_partitioning_1.png&#34; alt=&#34;노드 비례 파티셔닝1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_node_partitioning_2.png&#34; alt=&#34;노드 비례 파티셔닝2&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;운영--자동-재균형화와-수동-재균형화&#34;&gt;운영 : 자동 재균형화와 수동 재균형화&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;완전 자동 재균형화&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;관리자의 개입이 전혀 없이 시스템이 자동으로 재균형화&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;완전 수동 재균형화&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;요청-라우팅&#34;&gt;요청 라우팅&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06_request_routing.png&#34; alt=&#34;요청 라우팅&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파티션이 재균형화 되면서 노드에 할당되는 파티션이 바뀜 → 데이터 위치가 바뀐다는 의미&lt;/li&gt;
&lt;li&gt;파티션 할당 정보를 실시간으로 파악하고 있어야 하는 요구사항 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Service discovery&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 국한되지 않은 일반적인 문제&lt;/li&gt;
&lt;li&gt;고가용성을 지향하는 소프트웨어라면 모두 가지고 있는 문제
&lt;ul&gt;
&lt;li&gt;고가용성 → 사실상 분산 네트워크 시스템&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mangchhe.github.io/springcloud/2021/04/07/ServiceDiscoveryConcept&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://mangchhe.github.io/springcloud/2021/04/07/ServiceDiscoveryConcept&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;라우팅 결정을 내리는 구성요소의 위치에 따른 접근법&lt;/strong&gt;
라우팅 결정을 내리는 구성요소 ? → 위치 정보&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06-7.png&#34; alt=&#34;그림 6-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 6-7. 요청을 올바른 노드로 라우팅하는 세 가지 다른 방법&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;핵심 정보를 관리하는 방법&lt;/strong&gt;
모든 경우에 핵심 문제는 라우팅 결정을 내리는 구성요소가 노드에 할당된 파티션의 변경 사항을 어떻게 알 수 있는가임&lt;br&gt;
많은 코디네이션 서비스가 존재함 → &lt;a href=&#34;https://stackshare.io/service-discovery&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://stackshare.io/service-discovery&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/06-8.png&#34; alt=&#34;그림 6-8&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 6-8. 주키퍼를 사용해 파티션 할당 정보 추적하기&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;데이터베이스 별 파티션 할당 정보 접근법&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;방법 1. 개별 노드가 파티션 할당 정보 소유&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카산드라, 리악&lt;/li&gt;
&lt;li&gt;데이터베이스 노드에 복잡성을 더하지만 외부 코디네이션 서비스에 의존하지 않는 것은 장점&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;방법 2. 라우팅 계층이 파티션 할당 정보 소유&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HBase, 솔라클라우드, 카프카, 몽고DB&lt;/li&gt;
&lt;li&gt;코디네이션 라이브러리 사용 또는 자체적인 설정 서버 사용 (몽고DB)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;방법 3. 클라이언트가 파티션 할당 정보 소유&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;제보 부탁드립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;병렬-질의-실행&#34;&gt;병렬 질의 실행&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 대규모화 → 대규모 데이터 분석 및 질의가 중요함 → 클러스터형 데이터베이스&lt;/li&gt;
&lt;li&gt;대규모 병렬 처리(massively parallel processing, MPP) 지원&lt;/li&gt;
&lt;li&gt;RDB 는 조인, 필터링, 그룹화, 집계 연산 등 복잡한 종류의 질의 지원&lt;/li&gt;
&lt;li&gt;MPP 질의는 클러스터 내의 서로 다른 노드에서 병렬적으로 실행됨&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 07장. 트랜잭션</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/7/</link>
      <pubDate>Fri, 01 Apr 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/7/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 박현도, 이승익&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;매모호한-트랜잭션의-개념&#34;&gt;매모호한 트랜잭션의 개념&lt;/h2&gt;
&lt;h3 id=&#34;acid&#34;&gt;ACID&lt;/h3&gt;
&lt;p&gt;ACID는 데이터베이스 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질을 가리키는 약어이다.&lt;/p&gt;
&lt;h4 id=&#34;원자성atomicity&#34;&gt;원자성(Atomicity)&lt;/h4&gt;
&lt;p&gt;데이터베이스는 전부 반영되거나 아무것도 반영되지 않는 것을 보장하는 것으로써 원자성을 통해 부분 갱신으로 더 큰 문제가 야기되는 것을 방지할 수 있다.&lt;/p&gt;
&lt;p&gt;ex) 항공 티켓
티켓은 반드시 지불과 예약이 동시에 되거나 아니면 모두 되지 않아야 한다. 성공적으로 지불은 되었으나 좌석 예약은 되지 않은 경우는 허용되지 않는다.&lt;br&gt;
하나의 트랜잭션은 항공 티켓 예약뿐 아니라 호텔, 운송, 현재 환율로 정확히 환전되는 데에도 적용된다.&lt;br&gt;
&lt;em&gt;출처: &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%9B%90%EC%9E%90%EC%84%B1_%28%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%8B%9C%EC%8A%A4%ED%85%9C%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wikipedia&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;일관성consistency&#34;&gt;일관성(Consistency)&lt;/h4&gt;
&lt;p&gt;트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 말한다.&lt;br&gt;
&lt;em&gt;출처: &lt;a href=&#34;https://ko.wikipedia.org/wiki/ACID&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wikipedia&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ex) 회계시스템에서 모든 계좌에 걸친 대변과 차변은 항상 맞아 떨어져야 한다.&lt;/p&gt;
&lt;p&gt;일관성(C)은 실제로는 ACID에 속하지 않고 애플리케이션의 속성으로 본다.&lt;br&gt;
&lt;strong&gt;데이터베이스 자체만으로 불변식을 위반하는 잘못된 데이터를 쓰지 못하도록 막을 수 없기 때문이다.&lt;/strong&gt;&lt;br&gt;
이러한 것은 애플리케이션의 책임으로 보고 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수 있다.&lt;/p&gt;
&lt;h4 id=&#34;격리성isolation&#34;&gt;격리성(Isolation)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;동시에 실행되는 트랜잭션은 서로 격리되어 방해할 수 없다.&lt;/strong&gt;&lt;br&gt;
한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼수 없든지 둘 중 하나여야 하고 일부분만 볼 수 있어서는 안된다.&lt;/p&gt;
&lt;h4 id=&#34;지속성durability&#34;&gt;지속성(Durability)&lt;/h4&gt;
&lt;p&gt;데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공하는 것이다.&lt;br&gt;
&lt;strong&gt;지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;단일-객체-연산과-다중-객체-연산&#34;&gt;단일 객체 연산과 다중 객체 연산&lt;/h3&gt;
&lt;h4 id=&#34;단일객체-쓰기&#34;&gt;단일객체 쓰기&lt;/h4&gt;
&lt;p&gt;원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.&lt;/p&gt;
&lt;p&gt;그렇기에 저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성과 격리성을 제공하는 것을 목표로 한다.&lt;/p&gt;
&lt;p&gt;ex) 20KB의 JSON 문서를 데이터베이스에 쓰는 경우&lt;/p&gt;
&lt;p&gt;첫 10KB를 보낸 후 네트워크 연결이 끊기는 경우
데이터베이스가 디스크에 기존 값을 덮어쓰는 도중에 전원이 나가는 경우
문서를 쓰고 있을 때 다른 클라이언트에서 그 문서를 읽는 경우에 부분적으로 갱신된 값을 읽는지&lt;/p&gt;
&lt;h4 id=&#34;다중-객체-트랜잭션의-필요성&#34;&gt;다중 객체 트랜잭션의 필요성&lt;/h4&gt;
&lt;p&gt;다중 객체 트랜잭션 : 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요&lt;/p&gt;
&lt;p&gt;트랜잭션이 없더라도 복잡한 데이터의 쓰기와 읽기를 수행하는 애플리케이션을 구현할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그러나 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다.(외래키 등 참조)&lt;/li&gt;
&lt;li&gt;비정규화된 데이터가 동기화가 꺠지는 것을 방지(한번에 여러 문서 갱신 시)&lt;/li&gt;
&lt;li&gt;트랜잭션 격리성이 없으면 어떤 색인에서는 레코드가 보이지만 다른 색인은 아직 갱신되지 않아서 레코드가 보이지 않을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;완화된-격리-수준&#34;&gt;완화된 격리 수준&lt;/h2&gt;
&lt;h3 id=&#34;커밋-후-읽기-read-committed&#34;&gt;커밋 후 읽기 (READ COMMITTED)&lt;/h3&gt;
&lt;p&gt;가장 기본적인 수준의 트랜잭션 격리로 이 수준에서는 두 가지를 보장해 준다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기가 없음)&lt;/li&gt;
&lt;li&gt;데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기가 없음)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;더티-읽기-방지&#34;&gt;더티 읽기 방지&lt;/h4&gt;
&lt;p&gt;더티 읽기(dirty read)  : 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-2.jpg&#34; alt=&#34;그림 7-2&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-2. 격릭성 위반: 트랜잭션이 다른 트랜잭션에서 썼지만 커밋되지 않는 데이터를 읽음&amp;quot;(더티 읽기(dirty read))&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;더티 읽기를 막는게 유용한 이유&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을, 일부는 갱신되지 않은 값을 볼 수 있다.&lt;/li&gt;
&lt;li&gt;트랜잭션이 어보트되면 모두 롤백되어야 하나, 더티 읽기를 허용하면 트랜잭션이 나중에 롤백될 데이터를 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;더티-쓰기-방지&#34;&gt;더티 쓰기 방지&lt;/h4&gt;
&lt;p&gt;더티 쓰기(dirty write) : 두 트랜잭션이 동일한 객체를 동시에 갱신하려고 할 때, 먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮는 경우&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-5.jpg&#34; alt=&#34;그림 7-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-5. 다른 트랜잭션에서 충돌하는 쓰기를 실행할 때 더티 쓰기가 있으면 내용이 섞일 수 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;다른 트랜잭션에서 충돌하는 쓰기를 실행할 때 더티 쓰기가 있으면 내용이 섞일 수 있으며 더티 쓰기를 막음으로써 몇 가지 동시성 문제를 회피할 수 있다.&lt;/p&gt;
&lt;h4 id=&#34;커밋-후-읽기-구현&#34;&gt;커밋 후 읽기 구현&lt;/h4&gt;
&lt;p&gt;커밋 후 읽기는 Oracle 11g, PostgreSQL, SQL Server 2012, MemSQL 등에서 기본 설정으로 쓰고 있는 격리 수준이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;더티쓰기 방지 : 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유한다. 이런 잠금은 커밋 후 읽기 모드에서 데이터베이스에 의해 자동으로 실행된다.&lt;/li&gt;
&lt;li&gt;더티 읽기 방지:  과거의 커밋된 값/ 현재 쓰고 있는 새로운 값을 모두 기억하게 하여 해당 트랜잭션이 실행 중인 동안 과거의 값을 읽게하여 더티 읽기를 방지 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-4.jpg&#34; alt=&#34;그림 7-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-4. 더티 읽기 방지: 사용자 2는 사용자 1의 트랜잭션이 커밋된 후에야 x의 새 값을 보게 된다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;더티 읽기 방지 : 사용자 2는 사용자 1의 트랜잭션이 커밋된 후에야 x의 새 값을 보게 된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;스냅숏-격리와-반복-읽기snapshot-isolation&#34;&gt;스냅숏 격리와 반복 읽기(Snapshot Isolation)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-6.jpg&#34; alt=&#34;그림 7-6&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-6. 읽기 스큐: 앨리스는 일관성이 깨진 상태인 데이터베이스를 본다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;커밋 후 읽기 격리 수준에서도 동시성 버그가 생길 수 있으며 이런 현상을 비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew)라고 한다.&lt;/p&gt;
&lt;p&gt;위와 같은 경우 몇 초 후 새로고침하면 일관성 있는 계좌를 볼 수 있으나 어떤 상황에서는 이런 비일관성을 감내할 수 없는 경우도 있다.&lt;/p&gt;
&lt;p&gt;ex) 백업 (원본과 복사본의 데이터 차이), 분석 질의와 무결성 확인(큰 부분을 스캔하는 질의시 다른 시점의 데이터베이스 일부를 보게되면 잘못된 결과 반환)&lt;/p&gt;
&lt;p&gt;스냅숏 격리 : 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는 구현&lt;/p&gt;
&lt;p&gt;즉 트랜잭션은 시작할 때 데이터베이스에 커밋된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.&lt;/p&gt;
&lt;h4 id=&#34;스냅숏-격리-구현&#34;&gt;스냅숏 격리 구현&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;다중 버전 동시성 제어(multi-version concurrency control, MVCC)&lt;/strong&gt; : 데이터베이스가 객체의 여러 버전을 함께 유지하는 기법&lt;/p&gt;
&lt;p&gt;Q) 커밋 후 읽기도 더티 읽기를 방지하기 위해 버전을 두고 사용하는데 무슨 차이가 있는지?&lt;/p&gt;
&lt;p&gt;A) 커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 차이
즉 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가느냐에 따라 다르다.&lt;/p&gt;
&lt;h4 id=&#34;일관된-스냅숏을-보는-가시성-규칙&#34;&gt;일관된 스냅숏을 보는 가시성 규칙&lt;/h4&gt;
&lt;p&gt;트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07_real-mysql-1.jpg&#34; alt=&#34;Real MySQL 8.0&#34;&gt;&lt;br&gt;
&lt;em&gt;출처: Real MySQL 8.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;동작 방식&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 ID가 더 큰(즉 현재 트랜잭션이 시작한 후에 시작한) 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계 없이 모두 무시된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;색인과-스냅숏-격리&#34;&gt;색인과 스냅숏 격리&lt;/h4&gt;
&lt;p&gt;다중 버전 데이터베이스에서 색인의 동작&lt;br&gt;
하나의 선택지는 색인이 객체의 모든 버전을 가리키게 하고 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내고, 가비지 컬렉션이 어떤 트랜잭션에게도 더 이상 보이지 않는 오래된 객체 버전을 삭제 할때 대응되는 색인 항목도 삭제&lt;/p&gt;
&lt;p&gt;PostgreSQL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동일한 객체의 다른 버전들이 같은 페이지(page)에 저장될 수 있다면 색인 갱신을 회피하는 최적화 실행&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;카우치DB, 데이토믹, LMDB&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;쓸 때 복사되는 (append-only/copy-on-write) 변종을 사용&lt;br&gt;
트리의 페이지가 갱신될 때 덮어쓰는 대신 각 변경된 페이지의 새로운 복사본을 생성한다.&lt;br&gt;
트리의 루트에 이르기까지 존재하는 부모 페이지들은 복사되고 그것들의 자식 페이지들의 새 버전을 가리키도록 갱신된다.&lt;br&gt;
쓰기에 영향을 받지 않는 페이지들은 복사될 필요가 없고 변함 없는 상태로 남는다.&lt;/li&gt;
&lt;li&gt;추가 전용 B트리 사용&lt;br&gt;
쓰기를 실행하는 모든 트랜잭션은 새로운 B 트리 루트를 생성하며 특정 루트는 그것이 생성된 시점에 해당하는 데이터베이스의 일관된 스냅숏이 된다.&lt;br&gt;
나중에 실행되는 쓰기는 새로운 트리 루트만 생성할 수 있고 존재하는 B 트리를 변경할 수 없으므로 트랜잭션 ID를 기반으로 객체를 걸러낼 필요가 없다.&lt;br&gt;
그러나 이 방법도 컴팩션(compaction)과 가비지 컬랙션을 실행하는 백그라운드 프로세스가 필요하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;반복-읽기와-혼란스러운-이름&#34;&gt;반복 읽기와 혼란스러운 이름&lt;/h4&gt;
&lt;p&gt;스냅숏 격리는 읽기 전용 트랜잭션에서 유용하며, SQL 표준에 스냅숏 격리의 개념이 없기 때문에 여러 데이터베이스에서 다른 이름으로 불린다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Oracle: 직렬성(Serializable)&lt;/li&gt;
&lt;li&gt;PostgreSQL, MySQL: 반복 읽기(Repeatable Read)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;갱신-손실-방지&#34;&gt;갱신 손실 방지&lt;/h3&gt;
&lt;p&gt;만약 두 트랜잭션이 작업을 동시에 하면 두번째 쓰기 작업이 첫 번째  변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있음&lt;/p&gt;
&lt;p&gt;해결책&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원자적 쓰기 연산&lt;/li&gt;
&lt;li&gt;명시적인 잠금&lt;/li&gt;
&lt;li&gt;갱신 손실 자동 감지&lt;/li&gt;
&lt;li&gt;Compare-and-set&lt;/li&gt;
&lt;li&gt;충돌 해소와 복제&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;원자적-쓰기-연산&#34;&gt;원자적 쓰기 연산&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 연산에 원사성 (Atomicity) 성질을 부여함으로서 동시성 안전 획득&lt;/li&gt;
&lt;li&gt;exclusive lock 을 획득하여 구현 → 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못함&lt;/li&gt;
&lt;li&gt;or 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;명시적인-잠금&#34;&gt;명시적인 잠금&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것&lt;/li&gt;
&lt;li&gt;다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 첫 번째 read-modify-write 주기가 완료될 때까지 기다리도록 강제됨&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;리스팅개발팀 &amp;gt; 07. 트랜잭션 &amp;gt; 스크린샷 2022-04-01 오후 1.30.42.png&lt;/p&gt;
&lt;p&gt;예제 7-1. 로우를 명시적으로 잠금으로써 갱신 손실 막기&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;BEGIN&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;TRANSACTION&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SELECT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;figures&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;robot&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AND&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;game_id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;222&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;FOR&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UPDATE&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- 이동이 유효한지 확인한 후
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- 이전의 SELECT에서 반환된 것의 위치를 갱신한다.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UPDATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;figures&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SET&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;position&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;4&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1234&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;COMMIT&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;갱신-손실-자동-감지&#34;&gt;갱신 손실 자동 감지&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;여러 트랜잭션의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 abort 시키고, 재시도하도록 강제하는 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;compare-and-set&#34;&gt;Compare-and-set&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;-- 데이터베이스 구현에 따라 안전할 수도 안전하지 않을 수도 있다
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;UPDATE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;wiki_pages&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SET&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;new content&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1234&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AND&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;old content&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;충돌-해소와-복제&#34;&gt;충돌 해소와 복제&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;잠금과 compare-and-set 연산은 데이터의 최신 복사본이 하나만 있다고 가정함&lt;/li&gt;
&lt;li&gt;다중 리더 또는 리더 없는 복제를 사용하는 데이터베이스는 일반적으로 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용함&lt;/li&gt;
&lt;li&gt;따라서 데이터의 최신 복사본이 하나만 있으리라고 보장할 수 없음&lt;/li&gt;
&lt;li&gt;복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고, 추후에 충돌을 해소하고 이 버전들을 병합함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;쓰기-스큐와-팬텀&#34;&gt;쓰기 스큐와 팬텀&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;거의 동시에 두 트랜잭션이 시작되었다고 가정&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-8.png&#34; alt=&#34;그림 7-8&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-8. 애플리케이션 버그를 유발하는 쓰기 스큐의 예&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 스냅숏 격리를 사용하므로 둘 다 2를 반환해서 두 트랜잭션 모두 다음 단계로 진행함&lt;/li&gt;
&lt;li&gt;최소 한 명의 의사가 호출 대기해야 한다는 요구사항 위반&lt;/li&gt;
&lt;li&gt;이러한 현상을 쓰기 스큐 (wirte skew) 라고 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;쓰기-스큐를-특정-짓기&#34;&gt;쓰기 스큐를 특정 짓기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;쓰기 스큐는 두 트랜잭션이 같은 객체들을 읽어서 그 중 일부를 갱신할 때 나타날 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;쓰기-스큐를-유발하는-팬텀&#34;&gt;쓰기 스큐를 유발하는 팬텀&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07_transaction.png&#34; alt=&#34;쓰기 스큐를 유발하는 팬텀8&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 것을 팬텀(Phantom) 이라고 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;충돌-구체화&#34;&gt;충돌 구체화&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;충돌 구체화? → 최초의 select 시 잠글 수 있는 객체가 없기 때문이었음 → 인위적으로 데이터베이스에 잠금 객체를 추가하자&lt;/li&gt;
&lt;li&gt;대상 row 를 미리 만들고 lock 을 건다 → 트랜잭션 대상이 되는 특정 범위의 모든 조합에 대해 미리 row 를 만들어 둠 (ex, 회의실 예약의 경우 다음 6개월 동안에 해당되는 양)&lt;/li&gt;
&lt;li&gt;예약을 하는 트랜잭션은 테이블에서 원하는 대상 row 를 잠글 수 있음 (위에서 미리 생성했기 때문에)&lt;/li&gt;
&lt;li&gt;여기서 생성된 row 는 단지 동시에 변경되는 것을 막기 위한 잠금의 모음일 뿐임 (실제 사용되는 데이터가 아님)&lt;/li&gt;
&lt;li&gt;단점? → 동시성 제어 메커니즘이 애플리케이션 데이터모델로 새어 나오는 것은 보기 좋지 않음, 다른 대안이 불가능할 때 최후의 수단으로 고려&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;직렬성&#34;&gt;직렬성&lt;/h3&gt;
&lt;p&gt;DB의 동시성을 관리하는 방식의 문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없음&lt;/li&gt;
&lt;li&gt;애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는게 안전한지 알기 어려움, 특히 동시에 일어나는 모든 일을 알지 못할 수도 있는 거대한 애플리케이션이라면 더욱.&lt;/li&gt;
&lt;li&gt;동시성 문제는 보통 비결정적(간헐적) 이라서 테스트하기 어려움. 운이 나쁠 때만 문제가 발생하게 됨&lt;/li&gt;
&lt;li&gt;대안은 직렬성 격리 사용&lt;/li&gt;
&lt;li&gt;직렬성 격리는 보통 가장 강력한 경리 수준이라고 여겨짐&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;여러 트랜잭션이 병렬로 실행되더라도, 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;직렬성을 제공하는 3가지 기법&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;말 그대로 트랜잭션을 순차적으로 실행하기&lt;/li&gt;
&lt;li&gt;2단계 잠금&lt;/li&gt;
&lt;li&gt;직렬성 스냅숏 격리 같은 낙관적 동시성 제어 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;실제적인 직렬 실행&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것&lt;/li&gt;
&lt;li&gt;한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 됨&lt;/li&gt;
&lt;li&gt;단점? → 성능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;트랜잭션을 스토어드 프로시저 안에 캡슐화 하기&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 초창기에는 트랜잭션이 사용자의 활동 전체 흐름을 포함할 수 있게 하려는 의도가 있었음&lt;/li&gt;
&lt;li&gt;항공권 예약의 여러 과정 (경로 선택, 요금, 가용 좌석 탐색, 여행 일정표 정하기, &amp;hellip;) 을 하나의 트랜잭션으로 표현하고 원자적으로 커밋하는 것임&lt;/li&gt;
&lt;li&gt;이 방법을 구현하기 위해 데이터베이스 트랜잭션이 사용자의 입력을 기다려야 한다면, 매우 느릴 것으로 예상됨&lt;/li&gt;
&lt;li&gt;대신에 트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 제출함&lt;/li&gt;
&lt;li&gt;트랜잭션에 필요한 데이터는 모두 메모리에 있고, 스토어드 프로시저는 네트워크나 디스크 I/O 없이 매우 빨리 실행된다고 가정함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-9.png&#34; alt=&#34;그림 7-9&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-9. 상호작용식 트랜잭션과 스토어드 프로시저의 차이점(그림 7-8의 예제 트랜잭션을 사용함)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;파티셔닝&lt;/strong&gt;&lt;br&gt;
각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 파티셔닝 할 수 있다면, 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 스레드를 가질 수 있음
이 경우 각 CPU 코어에 각자의 파티션을 할당해서 트랜잭션 처리량을 CPU 코어 개수에 맞춰 선형적으로 확장할 수 있음
그러나 여러 파티션에 접근해야 하는 트랜잭션이 있다면, 코디네이션 오버헤드가 있으므로 단일 파티션 트랜잭션보다 엄청 느림&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직렬 실행 요약&lt;/strong&gt;&lt;br&gt;
트랜잭션 직렬 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 시용적인 방법이 됐음&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 전체 처리를 지연시킬 수 있기 때문.&lt;/li&gt;
&lt;li&gt;활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한됨, 단일 스레드 트랜잭션에서 디스크에 접근한다면 시스템이 매우 느려짐&lt;/li&gt;
&lt;li&gt;쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 함&lt;/li&gt;
&lt;li&gt;여러 파티션에 걸친 트랜잭션도 쓸 수 있지만, 이것을 사용할 수 있는 정도에는 엄격한 제한이 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2단계-잠금2pl&#34;&gt;2단계 잠금(2PL)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기를 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다(이렇게 하면 B가 A 몰래 갑자기 객체를 변경하지 못하도록 보장된다).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는  진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다(그림 7-4에 나왔듯이 2PL을 쓸 때는 객체의 과거 버전을 읽는 게 허용되지 않는다).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vs 스냅숏 격리(읽는 쪽은 ㅅ결코 쓰는 쪽을 막지 않으며, 쓰는 쪽도 결코 읽는 쪽을 막지 않음)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2단계-잠금-구현&#34;&gt;2단계 잠금 구현&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;MySQL, SQL Server 에서 직렬성 격리 수준을 구현하는데 사용됨&lt;/li&gt;
&lt;li&gt;잠금은 공유 모드 (shared mode) 나 독점 모드 (exclusive mode) 로 사용될 수 있음&lt;/li&gt;
&lt;li&gt;잠금이 아주 많이 사용되므로 교착 상태(두 개의 트랜잭션이 서로 기다리는 것)가 매우 쉽게 발생할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2단계-잠금의-성능&#34;&gt;2단계 잠금의 성능&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;가장 큰 약점이 성능&lt;/li&gt;
&lt;li&gt;잠금을 획득하고 해제하는 오버헤드 때문에 느린 것&lt;/li&gt;
&lt;li&gt;더 중요한 원인은 동시성이 줄어들기 때문 (동시성과 성능은 반비례)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;서술-잠금&#34;&gt;서술 잠금&lt;/h3&gt;
&lt;p&gt;조건에 부합하는 모든 객체에 잠금을 획득하는 것&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;SELECT&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;bookings&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;   &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;room_id&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;123&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AND&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;end_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;2018-01-01 12:00&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;AND&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;start_time&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#39;2018-01-01 13:00&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f8f8f8;text-decoration:underline&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;서술 잠금은 오래 걸림 (조건에 부합하는 잠금을 확인하는 데 시간이 오래 걸림)&lt;/li&gt;
&lt;li&gt;이 때문에 2PL 을 지원하는 대부분의 데이터베이스는 실제로는 색인 범위 잠금, 다음 키 잠금을 구현하여 사용함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;색인-범위-잠금&#34;&gt;색인 범위 잠금&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;예를 들어, 정오와 오후 1시 사이에 123번 방을 예약하는 것에 대한 서술 잠금을 → 모든 시간 범위에 123번 방을 예약하는 것으로 근사시켜 잠금 실행&lt;/li&gt;
&lt;li&gt;위의 그림 예시에서 room_id 또는 시간 값에 색인이 걸려있을 것이기에 해당 색인 범위에 lock 을 거는 것임&lt;/li&gt;
&lt;li&gt;색인 범위 잠금은 서술 잠금 보다 정밀하지 않지만(직렬성을 유지하기 위해 반드시 필요한 것보다 더 큰 범위를 잠글 수도 있음) 오버헤드가 낮기 때문에 좋은 타협안이 됨&lt;/li&gt;
&lt;li&gt;범위 잠금을 잡을 수 있는 적합한 색인이 없다면 테이블 전체에 공유 잠금을 잡는 것으로 대체하기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;직렬성-스냅숏-격리-serializable-snapshot-isolation-ssi&#34;&gt;직렬성 스냅숏 격리 (Serializable Snapshot Isolation, SSI)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;직렬성 격리와 좋은 성능은 공존할 수 있을까?&lt;/li&gt;
&lt;li&gt;현재 최고로 유망한 것이 직렬성 스냅숏 격리임&lt;/li&gt;
&lt;li&gt;스냅숏 격리에 비해 약간의 성능 손해만 있을 뿐임&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;비관적 동시성 제어 vs 낙관적 동시성 제어&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2단계 잠금은 비관적 동시성 제어 메커니즘임
&lt;ul&gt;
&lt;li&gt;뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때 까지 기다리는게 낫다는 원칙&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;직렬성 스냅숏 격리는 낙관적 동시성 제어 메커니즘임
&lt;ul&gt;
&lt;li&gt;뭔가 위험한 상황이 발생할 가능성이 있을  때 트랜잭션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다는 뜻&lt;/li&gt;
&lt;li&gt;트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지 확인함&lt;/li&gt;
&lt;li&gt;발생했다면 abort 되고 재시도함&lt;/li&gt;
&lt;li&gt;경쟁이 심하면 abort 비율이 높아지므로 성능 떨어짐&lt;/li&gt;
&lt;li&gt;예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면, 낙관적 동시성 제어 기법이 성능이 좋은 경향이 있음&lt;/li&gt;
&lt;li&gt;SSI = 스냅숏 격리 + 직렬성 충돌 감지 및 abort 시킬 트랜잭션 결정하는 알고리즘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;오래된 읽기 감지하기&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-11.png&#34; alt=&#34;그림 7-10&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-10. 트랜잭션이 MVCC 스냅숏에서 뒤처지 값을 읽었는지 감지하기&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;과거의 읽기에 영향을 미치는 쓰기 감지하기&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/07-11.png&#34; alt=&#34;그림 7-11&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 7-11. 직렬성 스냅숏 격리에서 트랜잭션이 다른 읽은 데이터를 변경하는 경우를 감지하기&lt;/em&gt;&lt;/p&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 08장. 분산 시스템의 골치거리</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/8/</link>
      <pubDate>Fri, 08 Apr 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/8/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 황윤호, 김은택&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다.&lt;br&gt;
엔지니어는 모든 게 잘못되더라도 제 역할을 해내는 시스템을 구축해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;결함과-부분장애&#34;&gt;결함과 부분장애&lt;/h2&gt;
&lt;p&gt;단일 컴퓨터 환경에서는 2가지로 예측이 가능하다.&lt;br&gt;
분산 컴퓨팅 환경에서는 예측할 수 없는 방법으로 고장이 난다. 이를 부분장애라 한다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;단일 컴퓨터 환경&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정상적으로 동작&lt;/li&gt;
&lt;li&gt;안 돌아감
-&amp;gt; &amp;ldquo;가끔 운수 나쁜날&amp;quot;로 보이기도 하지만, 대부분 잘못 작성한 소프트웨어의 결과이다&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;분산 컴퓨터 환경&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;네트워크로 연결된 여러 컴퓨터에서 실행되는 소프트웨어&lt;/li&gt;
&lt;li&gt;분산 시스템에서는 시스템의 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것도 무리가 아니다. 이를 부분 장애(partial failure)라고 한다&lt;/li&gt;
&lt;li&gt;부분장애는 비결정적이라서 다루기 어렵다&lt;/li&gt;
&lt;li&gt;또한 뭔가 성공했는지 아닌지 알지 못하는 경우도 있다&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;클라우드-컴퓨팅과-슈퍼-컴퓨팅&#34;&gt;클라우드 컴퓨팅과 슈퍼 컴퓨팅&lt;/h3&gt;
&lt;p&gt;고성능컴퓨팅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수천개의 CPU를 가진 슈퍼컴퓨터&lt;/li&gt;
&lt;li&gt;보통 일기예보나 분자 동력학처럼 계산 비용이 매우 높은 과학 계산 작업에 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;클라우드 컴퓨팅&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;멀티 테넌트 데이터센터&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP 네트워크(이더넷)로 연결된 상용 컴퓨터 등
전통적인 기업형 데이터센터는 이 두 극단의 중간 지점에 있다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;슈퍼컴퓨터에서 실행되는 작업은 보통 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장한다&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;장애가 발생하면 마지막 체크포인트로부터 계산을 재시작 한다. 단일 노드 컴퓨터에 가깝다&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘을 넣어야 한다.&lt;br&gt;
신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다. 완벽한 신뢰성은 없다.&lt;br&gt;
결함 처리는 소프트웨어 설계의 일부여야 하며 결함이 발생하면 소프트웨어가 어떻게 동작할지 알아야 한다.&lt;/p&gt;
&lt;h2 id=&#34;신뢰성-없는-네트워크&#34;&gt;신뢰성 없는 네트워크&lt;/h2&gt;
&lt;p&gt;책에서 주로 다루는 분산시스템은 비공유 시스템이다. 즉 네트워크로 연결된 다수의 장비이다.&lt;br&gt;
비공유가 시스템 구축하는 유일한 방법은 아니지만, 몇가지 이유로 인터넷 서비스를 구축하는 주된 방법이 되었다.&lt;/p&gt;
&lt;p&gt;특별한 하드웨어가 필요하지 않아서 상대적으로 저렴하고, 상품화된 클라우드 서비스를 활용할 수 있으며, 지리적으로 분산된 여러 데이터센터에 중복 배치함으로써 높은 신뢰성을 확보할 수 있다.&lt;br&gt;
각 노드들은 서로 다른 장비의 메모리나 디스크엔 접근할 수 없다. 네트워크가 유일한 통신수단이다.&lt;br&gt;
이런 종류의 네트워크에서 노드는 다른 노드로 메시지(패킷)을 보낼 수 있지만 네트워크는 메시지가 도착할 것인지는 보장하지 않는다.&lt;/p&gt;
&lt;p&gt;보장되지 않는 원인은 다양하다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;요청이 손실&lt;/li&gt;
&lt;li&gt;요청이 큐에서 대기하다 나중에 전송&lt;/li&gt;
&lt;li&gt;원격 노드에 장애 발생&lt;/li&gt;
&lt;li&gt;원격 노드가 일시적으로 응답을 멈췄지만 나중에 다시 응답 시작&lt;/li&gt;
&lt;li&gt;응답이 네트워크상에서 유실&lt;/li&gt;
&lt;li&gt;응답이 지연되다가 나중에 전송&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;전송 측은 패킷이 전송됐는지 아닌지조차 구변할 수 없다.&lt;br&gt;
그러므로 수신측에서 응답 메시즈를 보내는 것이지만 응답 메시지도 손실되거나 지연될 수 있다.&lt;br&gt;
이 문제를 다루는 흔한 방법은 &lt;strong&gt;타임아웃&lt;/strong&gt;이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;현실의 네트워크 결함&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아직 신뢰성 있는 네트워크를 만드는 완전한 방법은 없다.&lt;br&gt;
한 회사의 제어된 환경에서도 네트워크 문제는 놀랄만큼 흔하게 발생한다.&lt;br&gt;
또한, 공개된 클라우드 서비스에서도 네트워크 결함은 자주 발생한다.&lt;br&gt;
네트워크 결함이 드물더라도 결함이 일어날 수 있다는 사실은 인지하고 소프트웨어가 이를 처리할 수 있도록 설계 해야 한다.&lt;/p&gt;
&lt;p&gt;오류 처리가 정의되고 테스트되지 않는다면 나쁜 일이 제멋대로 생길 수 있다.&lt;br&gt;
반드시 네트워크 결함을 견뎌내도록 처리할 필요는 없다.&lt;br&gt;
네트워크가 믿을 만하다면 문제가 있을 때 그냥 사용자에게 오류 메시지를 보여주는 것도 타당한 방법이다.&lt;/p&gt;
&lt;p&gt;그러나 SW가 네트워크 문제에 어떻게 반응하는지 알고 시스템이 그로부터 복구할 수 있도록 보장해야 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결함 감지&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.&lt;/li&gt;
&lt;li&gt;단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더로 승격되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;타임아웃과-기약-없는-지연&#34;&gt;타임아웃과 기약 없는 지연&lt;/h3&gt;
&lt;p&gt;타임아웃만이 결함을 감지하는 확실한 수단이라면 타임아웃은 얼마나 길어야 할까? 유감스럽게도 간단한 답은 없다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;타임아웃이 길면 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다&lt;/li&gt;
&lt;li&gt;타임아웃이 짧으면 결함을 빨리 발견하지만 응답이 일시적으로 느려졌어도 죽었다고 선언할 위험이 높아진다&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;노드가 죽었다고 선언되면 그 노드의 책무는 다른 노드로 전달돼야 해서 다른 노드와 네트워크에 추가적인 부하를 준다.&lt;br&gt;
특히 노드가 실제로는 죽지 않았고 과부하 때문에 응답이 느릴 뿐일 수도 있다. 그 부하를 다른 노드로 전달하면 연쇄 장애를 유발할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;네트워크 혼잡과 큐 대기&lt;/strong&gt;&lt;br&gt;
네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;여러 노드가 동시에 같은 목적지로 패킷을 보내려고 하면 네트워크 스위치는 패킷을 큐에 넣고 한번에 하나씩 네트워크 링크로 넘겨준다.&lt;/li&gt;
&lt;li&gt;네트워크 링크가 붐비면 패킷은 슬롯을 얻을 수 있을때까지 잠시 기다릴 수도 있다. 이를 네트워크 혼잡이라고 한다.&lt;/li&gt;
&lt;li&gt;TCP는 흐름 제어를 수행하며 혼잡회피나 배압을 조절하여 과부하고 되지 않도록 송신을 제한하기도 한다.&lt;/li&gt;
&lt;li&gt;TCP는 타임아웃 안에 확인 응답을 받지 않으면 패킷이 손실됐다고 간주하고 재전송한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;지연 시간에 민감한 애플리케이션은 TCP 대신 UDP를 사용한다&lt;/p&gt;
&lt;p&gt;UDP는 흐름 제어를 하지 않고 손실된 패킷을 재전송하지 않으므로 네트워크 지연이 크게 변하게 하는 원인 중 일부를 제거한다&lt;/p&gt;
&lt;p&gt;UDP는 지연된 데이터의 가치가 없는 상황에서 선택하면 좋다&lt;/p&gt;
&lt;p&gt;이처럼 신뢰성과 지연 변동성 사이에 트레이드 오프 관계가 있다&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;동기 네트워크 대 비동기 네트워크&lt;/strong&gt;&lt;br&gt;
전화 네트워크는 극단적인 신뢰성을 지닌다. 종단 지연시간이 낮아야 하며 목소리의 음성 샘플을 전송할 대역폭이 충분해야 한다. 통화를 할 때는 회선이 만들어진다.&lt;br&gt;
두 명 사이에 있는 전체 경로를 따라서 그 통화에 대해 고정되고 보장된 양의 대역폭이 할당된다. ISDN 네트워크는 초당 4000프레임의 고정된 비율로 실행된다.&lt;br&gt;
이런 종류의 네트워크는 동기식이다. 데이터가 여러 라우터를 거치더라도 큐 대기 문제를 겪지 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그냥 네트워크 지연을 예측 가능하게 만들 수는 없을까?&lt;/strong&gt;&lt;br&gt;
데이터센터 네트워크와 인터넷이 circuit-switch 네트워크라면 왕복 시간의 최대치를 보장할 수 있다. 이더넷과 IP는 큐 대기의 영향을 받는 packet-switch 프로토콜이고 따라서 네트워크에 기약 없는 지연이 있다. 이 프로토콜에는 회선의 개념이 없다.&lt;/p&gt;
&lt;p&gt;왜 데이터센터 네트워크와 인터넷은 패킷을 교환을 사용할까? 순간적으로 몰리는 트래픽에 최적화됐기 때문이다. 순간적으로 몰리는 데이터 전송에 회선을 쓰면 네트워크 용량을 낭비하고 전송이 불필요하게 느려진다. TCP는 가용한 네트워크 용량에 맞춰 데이터 전송률을 동적으로 조절한다.&lt;/p&gt;
&lt;p&gt;타임아웃에 올바른 값은 없다. 실험을 통해 결정해야 한다.&lt;/p&gt;
&lt;h2 id=&#34;신뢰성-없는-시계&#34;&gt;신뢰성 없는 시계&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;이 요청이 타임아웃됐나?&lt;/li&gt;
&lt;li&gt;이 서비스의 99분위 응답 시간은 어떻게 되나?&lt;/li&gt;
&lt;li&gt;이 서비스는 지난 5분 동안 평균 초당 몇 개의 질의를 처리했나?&lt;/li&gt;
&lt;li&gt;사용자가 우리 사이트에서 시간을 얼마나 보냈나?&lt;/li&gt;
&lt;li&gt;이 기사가 언제 게시됐나?&lt;/li&gt;
&lt;li&gt;며칠 몇 시에 미리 알림 이메일을 보내야 하나?&lt;/li&gt;
&lt;li&gt;이 캐시 항목은 언제 만료되나?&lt;/li&gt;
&lt;li&gt;로그 파일에 남은 이 오류 메시지의 타임스탬프는 무엇인가?&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;단조-시계-대-일-기준-시계&#34;&gt;단조 시계 대 일 기준 시계&lt;/h3&gt;
&lt;p&gt;일 기준 시계
날짜와 시간을 반환&lt;/p&gt;
&lt;p&gt;NTP (Network Time Protocal) 로 동기화 - 신뢰성이 높지 않음&lt;/p&gt;
&lt;p&gt;방화벽
네트워크 지연시간 (최대 1초)
윤초 발생 - 1분의 길이가 59초나 61초가 됨 - NTP 서버에서 하루에 걸쳐 서서히 수행함
모바일 / 임베디드 장치는 신뢰성이 없음
단조 시계
지속시간을 재는데 적합&lt;/p&gt;
&lt;p&gt;다른 단조 시계와의 비교는 의미가 없음&lt;/p&gt;
&lt;p&gt;동기화된 시계에 의존하기 - 문제점
문제의 원인: 시계가 잘못된다는 것을 눈치채지 못함&lt;/p&gt;
&lt;p&gt;확연한 오류 보다는 미묘한 데이터의 손실
시계가 차이나는 노드는 죽은 것으로 선언되고 제거되어야 함
최종 쓰기 승리 (Last write wins, LWW)&lt;/p&gt;
&lt;p&gt;리더 없는 데이터베이스 (다중 리더 복제, 카산드라, 리악)&lt;/p&gt;
&lt;p&gt;데이터베이스 쓰기가 불가사의하게 사라짐 - 이 사실을 아는 것이 중요
전역 스냅숏용 동기화된 시계 (구글 케이스)
스패너(spanner) - 구글 트루타임(TrueTime) API&lt;/p&gt;
&lt;p&gt;신뢰 구간을 명시적으로 보고
각각 가장 이른 타임스탬프와 가장 늦은 타임스탬프를 포함하는 구간이 겹치지 않는다면, 분명히 B는 A보다 나중에 실행됐다.
스패너는 인과성을 반영하기 위해 B를 신뢰 구간 만큼 지연 실행한다.
구글은 각 데이터센터간에 GPS / 원자 시계 배치 - 약 7밀리초 이내 동기화
프로세스 중단
파티션마다 리더가 하나씩 있는 데이터베이스가 있다고 가정, 리더만 쓰기를 받아들임&lt;/p&gt;
&lt;p&gt;질문) 리더 노드가 여전히 리더인지 어떻게 알 수 있을까?&lt;/p&gt;
&lt;p&gt;한 가지 방법은 리더가 다른 노드들로부터 임차권(lease)을 얻는 것 - 특정 시점에 오직 하나의 리더만 존재&lt;/p&gt;
&lt;p&gt;시나리오
리더로 남아있으려면 주기적으로 갱신해야 함
장애가 난 경우, 임차권 갱신을 멈추므로 만료 시 다른 노드가 리더 역할을 넘겨 받음
while (true) {
request = getIncomingRequest();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 항상 임차권이 적어도 10초는 남아 있게 보장한다. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if (lease.expiryTimeMillis - System.currentTimeMillis() &amp;lt; 10_000) {
lease = lease.renew();
}&lt;/p&gt;
&lt;p&gt;if (lease.isValid()) {
process(request);
}
}
문제점은 무엇인가?&lt;/p&gt;
&lt;p&gt;동기화된 시계에 의존함
시간을 확인하는 시점과 요청이 처리되는 시점 사이에 매우 짧은 시간이 흐른다고 가정
만약 중간에 프로그램이 멈춘다면?
리더를 다른 노드가 넘겨 받음
이 쓰레드가 멈춰있었다고 누구도 알려주지 않음 ⇒ 계속 작업이 처리됨 (안전하지 않은 처리)
시스템이 멈추는 경우
stop-the-word : GC 중단
가상환경에서 suspend 발생 ⇒ 메모리 내용 저장 ⇒ 이후 재개 (노트북인 경우 동면 중에도 발생)
쓰레드의 컨텍스트 스위칭
느린 디스크 I/O 연산
유닉스인 경우 SIGSTOP (^Z) 명령
💡 단일 장비에서 유용한 도구&lt;/p&gt;
&lt;p&gt;뮤텍스 (mutex)
세마포어 (semaphore)
원자적 카운터 (atomic counter)
잠금없는 (lock-free) 자료구조
블로킹 큐 (blocking queue)&lt;/p&gt;
&lt;p&gt;응답시간 보장
실시간 운영체계 (real-time operating system, RTOS) - 항공기, 로켓, 로봇, 자동차 산업 등&lt;/p&gt;
&lt;p&gt;최악의 실행시간 명시
동적 메모리 할당이 금지될 수 있음
막대한 양의 테스트 필요
⇒ 프로그래밍 언어, 라이브러리, 도구의 범위를 엄격히 제한함&lt;/p&gt;
&lt;h2 id=&#34;지식-진실-그리고-거짓말&#34;&gt;지식, 진실, 그리고 거짓말&lt;/h2&gt;
&lt;p&gt;네트워크는 신뢰할 수 없는 구간이다. 결국 부분 장애, 신뢰성 없는 시계, 프로세스 중단에 시달릴 수 있다.&lt;br&gt;
신뢰성 있는 소프트웨어를 만드는 방법에 도움을 주는 개념을 소개한다.&lt;/p&gt;
&lt;h3 id=&#34;진실은-다수결로-결정된다&#34;&gt;진실은 다수결로 결정된다.&lt;/h3&gt;
&lt;p&gt;하나의 노드만 보고 정상 운영 중인지 판단하기 힘들다.&lt;/p&gt;
&lt;p&gt;예) full GC 로 중단된 서비스로 인해 죽었다고 판단했는데 다시 살아나서 하던 작업을 계속함&lt;/p&gt;
&lt;p&gt;대신 정족수, 즉 노드 사이의 투표에 의존한다 - 특정한 노드 하나에 대한 의존을 줄이기 위해 결정을 하려면 여러 노드들로부터 어떤 최소 개수의 투표를 받아야 한다.&lt;/p&gt;
&lt;p&gt;노드의 과반수 이상을 정족수로 삼는 것이 가장 흔하다. (3대 중 1대 오류, 5대 중 2대 오류 시라도 정상 동작)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리더와 잠금&lt;/strong&gt;
시스템이 단독으로 움직여야 할 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스플릿 브레인을 피하기 위해 오직 한 노드만 데이터베이스 파티션의 리더가 될 수 있다.&lt;/li&gt;
&lt;li&gt;특정한 자원이나 객체에 동시에 쓰거나 오염시키는 것을 방지하기 위해 오직 하나의 트랜잭션이나 클라이언트만 어떤 자원 이나 객체의 잠금을 획득할 수 있다.&lt;/li&gt;
&lt;li&gt;사용자명으로 사용자를 유일하게 식별할 수 있어야 하므로 오직 한 명의 사용자만 특정한 사용자명으로 등록할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;hellip; 이미지 &amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;펜싱 토큰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;hellip; 이미지 &amp;hellip;&lt;/p&gt;
&lt;p&gt;잠금 서비스로 주키퍼를 사용하면 트랜잭션 ID zxid나 노드 버전 eversion을 펜싱 토큰으로 사용할 수 있다. 이들은 단조 증가가 보장되므로 필요한 속성을 지닌다.&lt;/p&gt;
&lt;h3 id=&#34;비잔틴-결함&#34;&gt;비잔틴 결함&lt;/h3&gt;
&lt;p&gt;분산 시스템 문제는 노드가 &amp;ldquo;거짓말&amp;rdquo;(임의의 결함이 있거나 오염된 응답을 보냄)을 할지도 모른다는 위험이 있다면 훨씬 더 어려워진다.
이런 동작을 비잔틴 결함(Byzantine fault) 이라고 하며 이렇게 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 비잔틴 장군 문제(Byzantine Generals Problem) 라고 한다.
일부 노드가 오작동하고 프로토콜을 준수하지 않거나 악의적인 공격자가 네트워크를 방해하더라도 시스템이 계속 올바르게 동작한다면 이 시스템은 비잔틴 내결함성을 지닌다(Byzantine fault-tolerant) 라고 한다.
대체로 현실적이지 않으므로 전통적인 메커니즘(인증, 접근 제어, 암호화, 방화벽 등)이 여전히 공격자로부터 보호하는 수요 수단으로 사용되고 있다.&lt;/p&gt;
&lt;h3 id=&#34;약한-형태의-거짓말&#34;&gt;약한 형태의 거짓말&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 패킷에 대한 오염 (하드웨어 문제, 운영체제, 드라이버, 라우터 버그로 인함)&lt;/li&gt;
&lt;li&gt;보통 TCP / UDP 체크섬으로 검출됨&lt;/li&gt;
&lt;li&gt;어플리케이션에서 체크섬 사용하여 문제 해결&lt;/li&gt;
&lt;li&gt;공개적 어플리케이션은 사용자 입력을 신중하게 살균해야 함&lt;/li&gt;
&lt;li&gt;값에 대한 범위 확인, 적절한 메모리 할당을 위한 입력값 크기 제한, 기본적인 정상 점검 확인&lt;/li&gt;
&lt;li&gt;NTP 클라이언트는 여러 서버 주소를 설정하는 것이 도움이 됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시스템-모델과-현실&#34;&gt;시스템 모델과 현실&lt;/h3&gt;
&lt;p&gt;시스템 모델: 시스템에서 발생할 것으로 예상되는 결함의 종류를 어떻게든 정형화한 것&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;타이밍 가정&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정한다.&lt;/li&gt;
&lt;li&gt;부분 동기식 모델: 부분 동기는 시스템이 대부분의 시간에는 동기식 시스템처럼 동작하지만 때때로 네트워크 지연, 프로세스 중단, 시계 드리프트의 한계치를 초과한다는 뜻이다&lt;/li&gt;
&lt;li&gt;비동기식 모델: 이 모델에서 알고리즘은 타이밍에 대한 어떤 가정도 할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;노드 장애&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;죽으면 중단하는(crash-stop) 결함: 노드가 어느 순간에 갑자기 응답하기를 멈추면 이후로 그 노드는 영원히 사용할 수 없고 결코 되돌아오지 않는다는 뜻이다.&lt;/li&gt;
&lt;li&gt;죽으면 복구하는(crash-recovery) 결함: 노드가 어느 순간에 죽을 수 있지만 알려지지 않은 시간이 흐른 후에는 아마도 다시 응답하기 시작할 것이라고 가정한다.&lt;/li&gt;
&lt;li&gt;죽으면 복구하는 모델에서 노드는 메모리에 있는 상태는 손실되지만 죽어도 데이터가 남아 있는 안정된 저장소(즉 비휘발성 디스크 저장소)가 있다고 가정한다.&lt;/li&gt;
&lt;li&gt;비잔틴(임의적인) 결함: 노드는 지난 절에서 설명한 것처럼 다른 노드를 속이거나 기만하는 것을 포함해 전적으로 무슨 일이든 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;알고리즘의 정확성&lt;/strong&gt;&lt;br&gt;
속성을 기술하여 항상 만족하는지 확인한다.&lt;/p&gt;
&lt;p&gt;예) 펜싱 토큰&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유일성: 펜싱 토큰 요청이 같은 값을 반환하지 않는다.&lt;/li&gt;
&lt;li&gt;단조 일련번호: 요청 x 가 토큰 tx 를, 요청 y가 토큰 ty를 반환했고 y가 시작하기 전에 x가 완료됐다면 tx &amp;lt; ty 를 만족한다.&lt;/li&gt;
&lt;li&gt;가용성: 펜싱 토큰을 요청하고 죽지 않은 노드는 결국에는 응답을 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;안전성(safety)과 활동성(liveness)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;안전성
&lt;ul&gt;
&lt;li&gt;안전성 속성이 위반되면 그 속성이 깨진 특정 시점을 가리킬 수 있다(예를 들어 유일성 속성이 위반되면 중복된 펜싱 토큰 을 반환한 특정 연산을 식별할 수 있다).&lt;/li&gt;
&lt;li&gt;안전성 속성이 위반된 후에는 그 위반을 취소할 수 없다. 이미 손상된 상태다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;활동성
&lt;ul&gt;
&lt;li&gt;활동성 속성은 반대로 동작한다. 어떤 시점을 정하지 못할 수 있지만(예를 들어 노드가 요청을 보냈지만 아직 응답을 받지 못했을 수도 있다) 항상 미래에 그 속성을 만족시킬 수 있다는 희망이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;안전성 ⇒ 항상 만족되기를 요구 (모든 노드나 네트워크 전체 오류 시에도 잘못된 결과를 반환하지 않는다)&lt;/p&gt;
&lt;p&gt;활동성 ⇒ 경고를 하는 것이 허용 (네트워크 단절이 있다면 단절 기간의 한계를 둔다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;현실 대응&lt;/strong&gt;&lt;br&gt;
분산 시스템의 정확성을 따져보는 데 매우 유용, 다만 한계성은 명확하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;죽으면 복구되는 모델: 노드가 죽어도 데이터는 남아있다고 가정함
&lt;ul&gt;
&lt;li&gt;디스크 오염&lt;/li&gt;
&lt;li&gt;하드웨어 오류&lt;/li&gt;
&lt;li&gt;잘못된 설정으로 인한 데이터 유실&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;컴퓨터 과학과 컴퓨터 공학의 차이&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제 구현에는 불가능하다고 가정했던 일이 발생하는 경우를 처리해야할 수 있다.
&lt;ul&gt;
&lt;li&gt;printf(&amp;ldquo;너라서 짜증나&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;exit(666)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그럼에도 추상 시스템 모델은 중요하다!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현실 시스템의 복잡함 ⇒ 추론할 수 있는 관리 가능한 결함의 집합 추출 ⇒ 문제를 이해하고 체계적으로 해결&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;정리&#34;&gt;정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;네트워크 패킷은 언제나 손상되거나 지연될 수 있다.&lt;/li&gt;
&lt;li&gt;노드의 시계는 시간을 신뢰할 수 없다.&lt;/li&gt;
&lt;li&gt;프로세스는 실행 도중 stop-the-world 를 맞이할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;부분 실패는 분산 시스템의 뚜렷한 특성&lt;/p&gt;
&lt;p&gt;감지부터가 어려움의 시작 (타임아웃을 쓰긴 하지만 이는 네트워크 장애와 노드 장애를 구별하지 못함)&lt;br&gt;
엄격한 실시간 응답 보장과 네트워크 지연 제한을 두는 것은 가능하지만 비용이 매우 크고 자원 사용률이 낮아짐&lt;/p&gt;
&lt;p&gt;다음장은 모든 분산 시스템의 문제에 대처하는 해결책이다!&lt;/p&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 09장. 일관성과 합의</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/9/</link>
      <pubDate>Fri, 15 Apr 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/9/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 이호준, 조성직&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이번 장에서는 내결함성을 지닌 분산 시스템을 구축하기 위해 사용하는 알고리즘과 프로토콜을 알아본다.&lt;/p&gt;
&lt;h2 id=&#34;일관성-보장&#34;&gt;일관성 보장&lt;/h2&gt;
&lt;p&gt;약한보장&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복제 데이터 베이스는 대부분 최소한 최종적 일관성을 제공하나, 언제 수렴될지 모른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;강한보장&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 시스템이 선택적으로 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;올바르게 사용하기 쉬우나 시스템 성능이 나쁘거나 내결함성이 약할수도 있다.&lt;/p&gt;
&lt;h2 id=&#34;선형성&#34;&gt;선형성&lt;/h2&gt;
&lt;p&gt;공통적으로 사용되는 가장 강한 일관성 모델 중 하나
단 하나의 DB 복제본만 있다고 가정 (원자적 일관성 - atomic consistency)
최신성 보장 (recency guarantee) - read 시 최신 값을 보장&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;비선형 시스템의 예&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-1.png&#34; alt=&#34;그림 9-1&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-1. 이 시스템은 비선형이라서 축구팬들을 혼란스럽게 한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시스템에 선형성을 부여하는 것&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-2.png&#34; alt=&#34;그림 9-2&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-2. 읽기 요청이 쓰기 요청과 동시에 실행되면 과거의 값을 반환할 수도 있고 새로운 값을 반환할 수도 있다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트는 자신의 요청이 언제 처리됐는지는 알지 못하고 요청, 응답 시간 사이에 처리됐다는 것만 앎&lt;/li&gt;
&lt;li&gt;클라이언트 C의 쓰기 요청 전의 읽기 요청은 0, 쓰기 요청이 끝난 후의 읽이 요청은 1을 반환해야 하는 것은 명백함&lt;/li&gt;
&lt;li&gt;쓰기 요청 중 읽기 요청에서는 0 또는 1이 반환될 수 있는데 선형 시스템에 기대하는 바가 아님&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;선형적 시스템을 위한 제약 조건 추가&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-3.png&#34; alt=&#34;그림 9-3&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-3. 읽기가 새로운 값을 반환한 적이 있은 후에는 모든 후속 읽기(같은 클라이언트에서 실행되든 다른 클라이언트에서 실행되든)도 반듯이 새로운 값을 반환해야 한다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;읽기가 새로운 값을 반환하면 그 이후 모든 읽기는 새로운 값을 반환해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개별 연산 시각화를 위한 시점 연산 추가&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-4.png&#34; alt=&#34;그림 9-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-4. 읽기와 쓰기의 영향이 나타나는 것으로 보이는 시점을 시각화하기, B의 마지막 읽기는 선형적이지 않다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;연산 표시를 모은 선들은 항상 시간순으로 진행돼야 하고 이를 통해 최신성이 보장됨&lt;/li&gt;
&lt;li&gt;cas - 클라이언트가 원자적 compare-and-set 연산을 요청&lt;/li&gt;
&lt;li&gt;→ cas(x, v1, v2) =&amp;gt; r : 레지스터 x의 현재 값이 v1과 같으면 v2로 설정, 아니면 오류 반환&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;→ 선형성은 레지스터(개별 객체)에 실행되는 읽기, 쓰기에 대한 최신성 보장&lt;/p&gt;
&lt;h3 id=&#34;잠금과-리더-선출&#34;&gt;잠금과 리더 선출&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 복제에서는 리더가 하나만 존재해야 함&lt;/li&gt;
&lt;li&gt;잠금은 리더를 선출하는 방법&lt;/li&gt;
&lt;li&gt;선형적으로 모든 노드가 시작할 때 잠금 획득을 시도하고, 성공한 노드가 리더가 됨&lt;/li&gt;
&lt;li&gt;아파치 주키퍼, etcd 등 코디네이션 서비스 사용되기도 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;채널-간-타이밍-의존성&#34;&gt;채널 간 타이밍 의존성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;시스템의 통신 채널에 의한 경쟁 조건 발생 가능&lt;/li&gt;
&lt;li&gt;크기 변경 모듈이 과거 버전 이미지를 처리해 저장하면 파일저장소의 원래 이미지와 영구적으로 불일치&lt;/li&gt;
&lt;li&gt;선형성으로 이러한 경쟁 조건을 회피 할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-4.png&#34; alt=&#34;그림 9-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-5. 웹 서버와 이미지 크기 변경 모듈은 파일 저장소와 메세지 큐를 모두 써서 통신하므로 갱쟁 조건이 발생할 가능성이 열려 있다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;→ 메시지 큐와 파일 저장소가 선형적으로 동작하면 경쟁 조건의 위험에서 벗어날 수 있다&lt;/p&gt;
&lt;h2 id=&#34;선형성-시스템-구현하기&#34;&gt;선형성 시스템 구현하기&lt;/h2&gt;
&lt;h3 id=&#34;선형성-시맨틱을-제공하는-시스템-구현&#34;&gt;선형성 시맨틱을 제공하는 시스템 구현&lt;/h3&gt;
&lt;p&gt;선형성은 근본적으로 &amp;ldquo;데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적&amp;rdquo;
실제로 그러면 결함을 견뎌낼 수 없다.
내결함성을 지니기 위해 복제를 사용함&lt;/p&gt;
&lt;h3 id=&#34;복제-방법들&#34;&gt;복제 방법들&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 복제(선형적일 수 있음)&lt;/li&gt;
&lt;li&gt;합의 알고리즘(선형적)&lt;/li&gt;
&lt;li&gt;다중 리더 복제(비선형적)&lt;/li&gt;
&lt;li&gt;리더 없는 복제(아마도 비선형적)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선형성과-정족수&#34;&gt;선형성과 정족수&lt;/h2&gt;
&lt;p&gt;다이나모 모델에서 엄격한 정족수를 사용한 읽기 쓰기는 선형적으로 보이지만 경쟁 조건이 생길 수 있음&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-5.png&#34; alt=&#34;그림 9-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-5. 웹 서버와 이미지 크기 변경 모듈은 파일 저장소와 메세지 큐를 모두 써서 통신하므로 갱쟁 조건이 발생할 가능성이 열려 있다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;n(복제 서버) = 3, w(쓰기 노드) = 3, r(읽기 노드) = 2 → 정족수 조건 만족 (w + r &amp;gt; n) 이지만&lt;/li&gt;
&lt;li&gt;선형적이지 않음&lt;/li&gt;
&lt;li&gt;성능상 불이익이나 선형성을 만족시킬 수 없기 떄문에 다이나모 스타일의 복제를 하는 리더 없는 시스템은 비선형적임&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선형성의-비용&#34;&gt;선형성의 비용&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-7.png&#34; alt=&#34;그림 9-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-7. 네트워크가 끊기면 선형성과 가용성 사이에서 선택해야만 한다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;선형성-1&#34;&gt;선형성&lt;/h3&gt;
&lt;p&gt;단일 리더 경우로 네트워크 중단 시 팔로워 DC로 접속한 Client 는 사용에 문제가 있다.&lt;br&gt;
허나 리더 DC로 직접 접속이 가능하면 정상 동작할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;가용성&#34;&gt;가용성&lt;/h3&gt;
&lt;p&gt;다중 리더 경우로 비선형적이지만 DC간 네트워크 중단에도 정상 동작은 가능하다.&lt;br&gt;
네트워크 복구 시 복제 요청이 전달됨&lt;/p&gt;
&lt;h2 id=&#34;cap-정리&#34;&gt;CAP 정리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Consistency(일관성), Availability(가용성), Partition tolerance(분단 내성)&lt;/li&gt;
&lt;li&gt;선형성 데이터베이스라면 이러한 선형성과 가용성의 트레이드오프 문제가 있음&lt;/li&gt;
&lt;li&gt;오직 하나의 일관성 모델(=선형성) 과 한 종류의 결함(네트워크 분단 or 연결이 끊긴 살아있는 노드) 만 고려함&lt;/li&gt;
&lt;li&gt;다른 부분인 네트워크 지연, 트레이드 오프 등에 대해 고려하지 않으므로 시스템 설계 시 고려할 실용적인 가치가 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;선형성과-네트워크-지연&#34;&gt;선형성과 네트워크 지연&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;최신 다중코어 CPU의 RAM조차 선형적이지 않을 정도로 선형적인 시스템은 드물다.&lt;/li&gt;
&lt;li&gt;이러한 트레이드 오프는 내결함성 대신 성능을 선택했기 떄문이다.&lt;/li&gt;
&lt;li&gt;여러 분산 데이터 베이스도 마찬가지이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;순서화-보장&#34;&gt;순서화 보장&lt;/h2&gt;
&lt;h3 id=&#34;순서화&#34;&gt;순서화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 복제에서는 팔로워 쓰기 순서를 결정하는게 리더의 목적이였음&lt;/li&gt;
&lt;li&gt;트랜잭션의 직렬성은 어떤 순서에 따라 실행됨을 보장하는 것&lt;/li&gt;
&lt;li&gt;분산 시스템의 타임스탬프, 시계 사용은 시간을 통해 순서를 결정하기 위한 방법들
→ 순서화, 선형성, 합의 사이에 연관 관계를 통해 시스템이 무엇을 하고 할 수 없는지 이해할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;순서화와-인과성&#34;&gt;순서화와 인과성&lt;/h2&gt;
&lt;h3 id=&#34;인과성&#34;&gt;인과성&lt;/h3&gt;
&lt;p&gt;→ 결과가 나타나기 전에 원인이 발생한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;순서화가 인과성을 보존하는데 도움을&lt;/li&gt;
&lt;li&gt;시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적(causally consistent) 라고 함&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;선형성은-인과적-일관성보다-강하다&#34;&gt;선형성은 인과적 일관성보다 강하다&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;선형성은 인과성을 내포하기에 선형적 시스템은 인과성도 올바르게 유지함&lt;/li&gt;
&lt;li&gt;다만 성능, 가용성에 해가 될 수 있음 (네트워크 지연 등으로 인한)&lt;/li&gt;
&lt;li&gt;절충을 통해 성능 손해 없이 인과적 일관성을 만족 시킬 수 있고, 연구 중&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인과적-의존성-담기-비선형성-시스템&#34;&gt;인과적 의존성 담기 (비선형성 시스템)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;두 연산의 인과관계를 파악해야 함&lt;/li&gt;
&lt;li&gt;데이터베이스는 애플리케이션이 어떤 데이터 버전을 읽었는지 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;일련번호-순서화&#34;&gt;일련번호 순서화&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;모든 인과적 의존성을 추적하는건 실용성이 떨어지고, 오버헤드가 큼&lt;/li&gt;
&lt;li&gt;따라서 일련번호, 타임스탬프로 이벤트 순서를 정하는 방법이 있음&lt;/li&gt;
&lt;li&gt;크기가 작고, 고유해서 전체 순서를 알 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;비인과적-일련번호-생성기&#34;&gt;비인과적 일련번호 생성기&lt;/h2&gt;
&lt;h3 id=&#34;노드-별-일련번호&#34;&gt;노드 별 일련번호&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;각 노드 개별로 독립적인 일련번호 집합 생성&lt;/li&gt;
&lt;li&gt;ex) node A = {2, 4, 6, 8..} , node B = {1, 3, 5, 7&amp;hellip;}&lt;/li&gt;
&lt;li&gt;but, 노드마다 초당 연산 수가 다를 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;고해상도-타임스탬프&#34;&gt;고해상도 타임스탬프&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;각 연산에 일 기준 시계의 타임스탬프를 붙임&lt;/li&gt;
&lt;li&gt;ex) X = 40.00001, Y = 40.00003&lt;/li&gt;
&lt;li&gt;but, 노드 간 타임스탬프 불일치&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;노드에-일련번호-블록-할당&#34;&gt;노드에 일련번호 블록 할당&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일련번호들을 노드에 미리 할당&lt;/li&gt;
&lt;li&gt;ex) node A = {1 ~ 1000}, node B = {1001 ~ 2000}&lt;/li&gt;
&lt;li&gt;but, 블록 일련번호 간 일관성 불일치&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;잘 동작하나, 인과성에 일관적이지 않음&lt;/p&gt;
&lt;h2 id=&#34;램포트-타임스탬프&#34;&gt;램포트 타임스탬프&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;인과성에 일관적인 일련번호를 생성하는 간단한 방법&lt;/li&gt;
&lt;li&gt;현재 분산 시스템 분야에서 가장 많이 인용된 논문에 나온 방법&lt;/li&gt;
&lt;li&gt;각 노드는 처리한 연산의 갯수인 카운터, 타임스탬프를 가지는 노드 ID 를 가짐&lt;/li&gt;
&lt;li&gt;두 타임스탬프에서 카운터가 큰 것이, 그리고 노드 ID가 큰 값이 타임 스탬프가 큼&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-8.png&#34; alt=&#34;그림 9-8&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-8. 컴포트 타임스탬프는 인과성에 일관적인 전체 순서화를 제공한다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;→ 모든 노드, 클라이언트는 최댓값을 가지는 카운터를 추적하고 요청, 응답에 따라 최댓값 갱신&lt;/p&gt;
&lt;h2 id=&#34;타임스탬프-순서화로는-불충분&#34;&gt;타임스탬프 순서화로는 불충분&lt;/h2&gt;
&lt;p&gt;일관적 인과성을 갖는 연산의 전체 순서를 정의하지만 분산 시스템의 공통 문제를 해결하는데 불충분
연산들을 사후에 결정하는게 아닌, 요청을 받는 즉시 결정해야 할 때 문제가 생김
→ 연산의 전체 순서를 모든 연산을 모은 후에 결정되는 것이 원인
전체 순서를 언제 확정할 것인지 전체 순서 브로드캐스트를 통해 다룸&lt;/p&gt;
&lt;h2 id=&#34;전체-순서-브로드캐스트&#34;&gt;전체 순서 브로드캐스트&lt;/h2&gt;
&lt;p&gt;(* 참고 : 전체 순서, 부분 순서)&lt;/p&gt;
&lt;p&gt;전체 순서 브로드캐스트는 노드 사이에 메시지를 교환하는 프로토콜로 기술된다.&lt;br&gt;
비공식적으로 두 가지 안전성 속성을 항상 만족해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;신뢰성 있는 전달
&lt;ul&gt;
&lt;li&gt;어떤 메시지도 손실되지 않는다.&lt;/li&gt;
&lt;li&gt;메시지가 하나의 노드에 전달되면 모든 노드에 전달되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;전체 순서가 정해진 전달
&lt;ul&gt;
&lt;li&gt;메시지는 모든 노드에 같은 순서로 전달된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;참고 : &lt;a href=&#34;https://en.wikipedia.org/wiki/Atomic_broadcast&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://en.wikipedia.org/wiki/Atomic_broadcast&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이 두 속성은 노드나 네트워크 결함이 있어도 항상 만족되어야 한다.&lt;br&gt;
물론 네트워크가 끊긴 순간에는 메시지가 전달되지 못하지만 결국 복구될 것이고 메시지 전송을 계속하여 재시도하면 이를 만족할 수 있을 것이다.&lt;br&gt;
메시지가 전달되는 순서가 곧 시스템에서 연산의 전체 순서를 의미한다.&lt;br&gt;
전체 순서 브로드캐스트의 중요한 측면은 메시지가 전달되는 시점에 순서가 고정된다는 것이다.&lt;br&gt;
후속 메시지가 이미 전달된 경우 그 앞의 순서에 메시지를 끼워넣는 것을 허용하지 않는다.&lt;/p&gt;
&lt;h2 id=&#34;전체-순서-브로드캐스트-사용하기&#34;&gt;전체 순서 브로드캐스트 사용하기&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;합의&lt;/strong&gt;
주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.&lt;br&gt;
전체 순서 브로드캐스트와 합의는 서로 크게 연관되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;데이터베이스 복제&lt;/strong&gt;
전체 순서 브로드캐스트는 데이터베이스 복제에도 사용된다.&lt;br&gt;
모든 메시지가 데이터베이스의 쓰기를 나타내고 모든 노드에 메시지가 동일한 순서로 전달된다면 각 노드는 메시지를 받은 순서대로 처리하면 모든 노드가 서로 일관성 있는 상태를 유지할 수 있다.&lt;br&gt;
이 원리를 상태 기계 복제(state machine replication)라 하고 11장에서 이 주제를 다룬다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직렬성 트랜잭션&lt;/strong&gt;
직렬성 트랜잭션에도 전체 순서 브로드캐스트가 사용될 수 있다.&lt;br&gt;
‘실제적인 직렬 실행’에서 모든 메시지가 스토어드 프로시저로 실행되는 결정적 트랜잭션을 나타내고 모든 노드가 메시지를 동일한 순서로 처리하면 데이터베이스의 파티션과 복제본은 일관된 상태를 유지한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;로그&lt;/strong&gt;
전체 순서 브로드캐스트를 로그를 만드는 데에 사용할 수도 있다.&lt;br&gt;
메시지 전달은 로그에 추가하는 것과 비슷하다.&lt;br&gt;
모든 노드가 같은 메시지를 같은 순서로 전달 받는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;펜싱 토큰&lt;/strong&gt;
펜싱 토큰을 제공하는 잠금 서비스를 구현하는 데에도 유용하다.&lt;br&gt;
잠금을 획득하는 모든 요청은 메시지로 로그에 추가된 후 일련번호를 받는다.&lt;br&gt;
일련번호는 단조증가하므로 이를 펜싱 토큰으로 사용할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;전체-순서-브로드캐스트-사용해-선형성-저장소-구현하기&#34;&gt;전체 순서 브로드캐스트 사용해 선형성 저장소 구현하기&lt;/h2&gt;
&lt;p&gt;선형성 시스템에서도 연산의 전체 순서가 있었다.
전체 순서 브로드캐스트와 선형성은 같은 의미인가?
완전히 같다고 볼 수 없으나 두 개념은 서로 밀접한 관계가 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;비동기 vs 최신성 보장&lt;/strong&gt;
전체 순서 브로드캐스트는 비동기식이다. 메시지는 고정된 순서로 신뢰성 있게 전달되는 것을 보장한다.&lt;br&gt;
그러나 언제 메시지가 전달될 지는 보장하지 않는다.&lt;br&gt;
선형성은 최신성 보장이다. 읽기가 최근에 쓰여진 값을 보는 것이 보장된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전체 순서 브로드캐스트로 선형성 저장소 구현하기&lt;/strong&gt;
전체 순서 브로드캐스트 구현을 기반으로 선형성 저장소를 만들 수 있다.&lt;br&gt;
사용자명으로 사용자 계정을 유일하게 식별하도록 보장하는 경우를 보자.&lt;/p&gt;
&lt;p&gt;사용자명의 획득은 원자적 compare-and-set(이하 cas) 연산을 통해 이루어진다.&lt;br&gt;
연산 실행 시 값이 null(누구도 점유하지 않은 사용자명)인 경우 cas 연산이 성공한다.&lt;br&gt;
이미 할당된 경우라면 선형성에 의해 null이 아닌 값을 조회할 것이고, cas 연산이 실패한다.&lt;br&gt;
전체 순서 브로드캐스트를 추가 전용 로그로 사용하여 선형성 cas 연산을 다음과 같이 구현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지를 로그에 추가하여 점유를 원하는 사용자명을 가리킨다.&lt;/li&gt;
&lt;li&gt;로그를 읽고, 추가한 메시지가 되돌아오기를 기다린다.&lt;/li&gt;
&lt;li&gt;원하는 사용자명을 점유하려는 메시지가 있는지 확인한다.&lt;/li&gt;
&lt;li&gt;첫 번째 메시지가 자신의 메시지라면 점유에 성공한다.&lt;/li&gt;
&lt;li&gt;그러나 첫 번째 메시지가 다른 사용자의 것이라면 연산을 취소한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 항목은 모든 노드에 같은 순서로 전달된다.&lt;br&gt;
모든 노드가 어떤 쓰기가 먼저 실행된 것인지 동의한다.&lt;br&gt;
충돌하는 쓰기 중 첫 번째 것을 승자로 하고 나머지는 어보트된다.&lt;br&gt;
이러한 절차는 선형성 쓰기를 보장하지만 선형성 읽기는 보장하지 않는다.&lt;br&gt;
각 노드는 로그로부터 비동기로 쓰기 내역이 갱신되기 때문이다. 그래서 오래된 값을 읽을 수 있다.&lt;br&gt;
그래서 이 절차는 엄밀히 말하면 선형성이 아닌, (그보다 조금 약한) 순차적 일관성 또는 타임라인 일관성 보장을 제공한다.&lt;/p&gt;
&lt;h2 id=&#34;선형성-저장소를-사용해-전체-순서-브로드캐스트-구현하기&#34;&gt;선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기&lt;/h2&gt;
&lt;p&gt;반대로 선형성 저장소를 기반으로 전체 순서 브로드캐스트를 구현하는 것도 가능하다.&lt;br&gt;
가장 쉬운 방법은 원자적 increment-and-get(이하 iag) 연산을 사용하는 것이다. (원자적 compare-and-set 연산을 사용해도 된다)&lt;br&gt;
알고리즘은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지에 선형성 정수로 iag 연산을 수행하고 얻은 값을 일련번호로 포함한다.&lt;/li&gt;
&lt;li&gt;그 후 메시지를 모든 노드에 전송한다.&lt;/li&gt;
&lt;li&gt;수신자들은 일련번호 순서대로 메시지를 전달한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;선형성 레지스터로 얻은 숫자는 틈이 없는 순열을 형성한다.&lt;br&gt;
따라서 어떤 노드가 메시지 4를 전달하고 6을 받았다면 6을 전달하기 전에 5를 기다려야 한다는 것을 알 수 있다.&lt;br&gt;
반면 램포트 타임스탬프에서는 그렇지 않았다. 이것이 전체 순서 브로드캐스트와 타임스탬프 순서화의 핵심적인 차이다.&lt;/p&gt;
&lt;p&gt;원자적 iag 연산을 만드는 것은 쉬워보인다. 결함이 발생하지 않으면 실제로 쉽다.&lt;br&gt;
그러나 노드가 죽거나 네트워크 연결이 끊긴 상황 등을 고려하면 쉬운 문제가 아니다.&lt;br&gt;
선형성 일련번호 생성기에 대해 고민하다보면 필연적으로 합의 알고리즘에 도달한다.&lt;br&gt;
&lt;strong&gt;선형성 iag(또는 cas) 레지스터와 전체 순서 브로드캐스트는 합의와 동등하다.&lt;/strong&gt;
이 문제 중 하나를 해결할 수 있으면 다른 문제도 해결할 수 있다는 것이다.&lt;/p&gt;
&lt;h2 id=&#34;분산-트랜잭션과-합의&#34;&gt;분산 트랜잭션과 합의&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;합의의 목적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;여러 노드들이 무언가에 동의하게 만드는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;노드가 동의하는 것이 중요한 상황&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리더 선출
&lt;ul&gt;
&lt;li&gt;단일 리더 복제의 경우 리더가 어떤 노드인지 합의가 필요&lt;/li&gt;
&lt;li&gt;스플릿 브레인 현상을 방지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;분산 트랜잭션의 원자적 커밋
&lt;ul&gt;
&lt;li&gt;여러 노드나 파티션에 걸친 트랜잭션이 노드 별로 성공, 실패의 결과가 다를 수 있음&lt;/li&gt;
&lt;li&gt;성공이든 실패든 모든 노드가 트랜잭션의 하나의 결과에 동의해야 함&lt;/li&gt;
&lt;li&gt;트랜잭션의 원자성 유지를 위함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;원자적-커밋과-2단계-커밋-2pc&#34;&gt;원자적 커밋과 2단계 커밋 (2PC)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;단일 노드에서 분산 원자적 커밋으로 단일 노드에서 커밋은 어떻게 결정되는가?&lt;/strong&gt;&lt;br&gt;
디스크에 있는 트랜잭션 로그에 커밋 레코드가 추가되어야 커밋이 된다.&lt;br&gt;
이후 데이터베이스가 죽더라도 디스크에 기록된 로그로 트랜잭션이 커밋된 것을 알 수 있다.&lt;br&gt;
노드에 부착된 특정 디스크 드라이브의 컨트롤러가 커밋을 원자적으로 만든다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;여러 노드가 관여하는 경우는 이야기가 다르다.&lt;/strong&gt;&lt;br&gt;
예를 들면, 다음과 같은 경우다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파티셔닝된 데이터베이스에 다중 객체 트랜잭션을 사용&lt;/li&gt;
&lt;li&gt;보조 색인을 사용하는 경우. 주 색인과 보조 색인이 서로 다른 노드에 존재한다.
각 노드에서 독립적으로 트랜잭션을 커밋 하면 어떤 노드는 성공, 어떤 노드는 실패할 가능성이 다분하다.&lt;br&gt;
이는 부분적인 성공, 실패를 의미하므로 원자성을 위반하며 이를 허용하면 노드 간의 일관성도 없어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;일단 커밋 후 문제가 있으면 취소하면 되지 않을까?&lt;/strong&gt;
그러나 직후 발생한 또 다른 트랜잭션에서 커밋된 데이터에 의존할 가능성이 있다.&lt;br&gt;
이러한 트랜잭션도 모두 취소 되어야 한다. 그래서 커밋 후 취소하는 방법은 적절하지 않다.&lt;br&gt;
따라서 트랜잭션 커밋은 되돌릴 수 없다.&lt;br&gt;
노드가 트랜잭션을 커밋 하려면 다른 노드에서도 이 트랜잭션이 커밋되리라는 확신을 갖고 있어야 한다.&lt;/p&gt;
&lt;h2 id=&#34;2단계-커밋2pc-2-phase-commit-소개&#34;&gt;2단계 커밋(2PC, 2-phase commit) 소개&lt;/h2&gt;
&lt;p&gt;2단계 커밋은 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하는 알고리즘이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-9.png&#34; alt=&#34;그림 9-9&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-9. 2단계 커밋(2PC)의 성공적인 실행&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;코디네이터와 참여자&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코디네이터
&lt;ul&gt;
&lt;li&gt;트랜잭션 관리자라고도 한다.&lt;/li&gt;
&lt;li&gt;애플리케이션 프로세스 내에서 라이브러리 형태로 구현되거나&lt;/li&gt;
&lt;li&gt;분리된 프로세스 또는 서비스로 제공될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;참여자
&lt;ul&gt;
&lt;li&gt;트랜잭션을 커밋하는 각 데이터베이스 노드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2단계 커밋의 절차&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션이 여러 노드에 데이터를 기록한다.&lt;/li&gt;
&lt;li&gt;애플리케이션이 커밋할 준비가 되면 코디네이터가 1단계를 시작한다. 각 노드에 준비 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;모든 참여자가 커밋 준비가 완료되면 2단계에서 커밋 요청을 한다.&lt;/li&gt;
&lt;li&gt;커밋 준비가 되지 않은 참여자가 있다면 2단계에서 어보트 요청을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;약속에-관한-시스템&#34;&gt;약속에 관한 시스템&lt;/h2&gt;
&lt;p&gt;위에서 설명한 내용 만으로는 2단계 커밋이 원자성을 어떻게 보장하는 지 명확하지 않다.&lt;/p&gt;
&lt;p&gt;준비 요청과 커밋 요청은 2단계에서 손실될 가능성이 있기 때문이다.&lt;/p&gt;
&lt;p&gt;과정을 더 자세히 보자.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션은 분산 트랜잭션을 시작하기를 원할 때 코디네이터에게 트랜잭션 ID를 요청한다. 이 트랜잭션 ID는 전역적으로 유일하다.&lt;/li&gt;
&lt;li&gt;애플리케이션은 발급받은 트랜잭션 ID를 가지고 각 참여자에서 단일 노드 트랜잭션을 시작한다. 읽기와 쓰기는 이 과정에서 실행된다.
&lt;ul&gt;
&lt;li&gt;이 단계에서 노드가 죽거나 타임아웃 등의 문제가 발생하면 코디네이터나 참여자 중 누군가 어보트할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이후 코디네이터가 준비 요청을 한다. 참여자가 준비 요청을 받으면 트랜잭션 커밋이 가능한지 점검한다.
&lt;ul&gt;
&lt;li&gt;가능하다고 판단이 되면 코디네이터에게 ‘네&amp;rsquo;라고 응답을 한다.&lt;/li&gt;
&lt;li&gt;이 응답은 이후 어떤 상황(노드가 죽거나, 디스크 공간이 부족한 경우 등)에서도 절대 번복될 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코디네이터가 준비 요청에 대한 응답을 받은 후, 트랜잭션을 커밋할지 어보트 할지 최종적으로 결정한다.
&lt;ul&gt;
&lt;li&gt;모든 참여자가 ‘네&amp;rsquo;라고 응답해야 커밋으로 결정한다.&lt;/li&gt;
&lt;li&gt;코디네이터가 추후 죽을 수도 있으므로 결정을 디스크의 트랜잭션 로그에 기록한다. 이를 커밋 포인트라 한다.&lt;/li&gt;
&lt;li&gt;완료된 결정은 절대 되돌릴 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코디네이터가 최종 결정을 완료하였으니, 모든 참여자에게 커밋 또는 어보트 요청을 전송한다.
&lt;ul&gt;
&lt;li&gt;이 요청이 실패하거나 타임아웃이 발생하면 성공할 때 까지 영원히 재시도한다.&lt;/li&gt;
&lt;li&gt;참여자가 죽은 경우라면 복구된 후에 커밋을 요청한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;트랜잭션 커밋을 결정하는 참여자의 응답과 코디네이터의 결정은 번복될 수 없다.&lt;/p&gt;
&lt;p&gt;이러한 약속이 2PC의 원자성을 보장한다.&lt;/p&gt;
&lt;h2 id=&#34;코디네이터-장애&#34;&gt;코디네이터 장애&lt;/h2&gt;
&lt;p&gt;앞에서 2PC 과정 중 문제가 발생하면 어떻게 진행되는 지 설명했다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1단계에서 문제가 발생하면 코디네이터가 트랜잭션을 어보트한다.&lt;/li&gt;
&lt;li&gt;2단계에서 문제가 발생하면 코디네이터가 요청을 무한히 재시도한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;그런데 코디네이터가 죽으면 어떻게 되는가?&lt;br&gt;
코디네이터가 준비 요청을 보내기 전에 장애가 발생하면 참여자가 트랜잭션을 어보트할 수 있다.&lt;br&gt;
그런데 준비 요청에 ‘네&amp;rsquo;라고 대답을 보낸 이후는 참여자가 일방적으로 어보트할 수 없다.&lt;br&gt;
코디네이터로부터 2단계 요청을 받을 때 까지 기다려야 한다.&lt;br&gt;
이런 상태의 트랜잭션을 의심스럽다 또는 &lt;strong&gt;불확실하다&lt;/strong&gt;고 한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/09-10.png&#34; alt=&#34;그림 9-10&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 9-10. 참여자들이 &amp;ldquo;네&amp;quot;라고 투표한 후 코디네이터가 죽는다. 데이터베이스 1은 커밋할지 어보트할지 알지 못한다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;데이터베이스1은 코디네이터의 커밋 요청을 대기하고 있다.&lt;br&gt;
이러한 경우 코디네이터가 복구되는 것을 기다릴 수 밖에 없다.&lt;br&gt;
다행이 코디네이터는 요청을 보내기 전에 커밋 로그를 기록했다.&lt;br&gt;
코디네이터가 복구되면 트랜잭션 로그를 읽어 의심스러운 트랜잭션들의 상태를 결정한다.&lt;br&gt;
커밋 레코드가 없는 트랜잭션은 어보트된다. 있다면 커밋 요청을 재시도할 것이고 2단계 과정도 완료될 것이다.&lt;br&gt;
2단계 커밋은 코디네이터가 복구될 때 까지 중단되므로 블로킹 원자적 커밋 프로토콜이라 한다.&lt;/p&gt;
&lt;h2 id=&#34;3단계-커밋&#34;&gt;3단계 커밋&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3단계 커밋&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2PC의 대안으로 제안된 알고리즘&lt;/li&gt;
&lt;li&gt;지연에 제한이 있는 네트워크, 응답 시간에 제한이 있는 노드를 전제로 한다. (→ 현실과 동떨어짐)&lt;/li&gt;
&lt;li&gt;따라서 현실적인 분산 시스템에서 3PC를 적용하기는 어렵다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;현실의-분산-트랜잭션&#34;&gt;현실의 분산 트랜잭션&lt;/h2&gt;
&lt;h3 id=&#34;분산-트랜잭션에-대한-엇갈린-평판&#34;&gt;분산 트랜잭션에 대한 엇갈린 평판&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;긍정적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분산 시스템에서 원자적 커밋을 달성하여 안전성 보장을 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;부정적&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;운영상의 문제 유발&lt;/li&gt;
&lt;li&gt;성능 이슈의 원인
&lt;ul&gt;
&lt;li&gt;장애 복구에 필요한 부가적인 디스크 강제 쓰기(fsync), 부가적인 네트워크 왕복 시간을 강요&lt;/li&gt;
&lt;li&gt;ex. MySQL : 분산 트랜잭션이 단일 노드 트랜잭션보다 10배 이상 느리다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;분산 트랜잭션이 제공해주는 이점에 비해 비용이 너무 큰 것 아닌가?&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;두-가지-종류의-분산-트랜잭션&#34;&gt;두 가지 종류의 분산 트랜잭션&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;데이터베이스 내부 분산 트랜잭션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분산 시스템(복제, 파티셔닝)을 지원하는 데이터베이스는 노드 사이의 내부 트랜잭션을 지원&lt;/li&gt;
&lt;li&gt;트랜잭션에 참여하는 모든 노드는 동일한 데이터베이스 소프트웨어를 실행한다.&lt;/li&gt;
&lt;li&gt;다른 시스템과 호환될 필요가 없어 프로토콜 선택, 구현이 자유롭고 최적화가 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이종 분산 트랜잭션&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;참여자들이 각기 다른 기술을 기반으로 하는 경우&lt;/li&gt;
&lt;li&gt;두 가지 서로 다른 벤더의 데이터베이스가 참여하는 경우&lt;/li&gt;
&lt;li&gt;메시지 브로커와 같은 비데이터베이스 시스템이 참여하는 경우&lt;/li&gt;
&lt;li&gt;서로 다른 시스템 간의 원자적 커밋을 보장해야 함&lt;/li&gt;
&lt;li&gt;다양한 시스템들이 강력한 방법으로 통합될 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이종 분산 트랜잭션의 절차와 제약&lt;/strong&gt;&lt;br&gt;
이종 분산 트랜잭션의 한 가지 예시를 살펴보자.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;예시 : 메시지 브로커와 메시지를 처리하는 데이터베이스&lt;/strong&gt;&lt;br&gt;
메시지 브로커에서 메시지를 데이터베이스로 전송하고, 데이터베이스가 이를 처리하는 상황이다.&lt;br&gt;
분산 트랜잭션의 커밋과 어보트는 다음과 같이 진행되어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;커밋
&lt;ul&gt;
&lt;li&gt;메시지 브로커에서 데이터베이스로 메시지 전달이 성공&lt;/li&gt;
&lt;li&gt;메시지를 처리하는 데이터베이스 트랜잭션이 성공&lt;/li&gt;
&lt;li&gt;이 두 과정이 모두 성공해야 분산 트랜잭션을 커밋한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어보트
&lt;ul&gt;
&lt;li&gt;위 커밋의 두 과정 중 하나라도 실패하면 어보트해야 한다.&lt;/li&gt;
&lt;li&gt;진행 과정에서 발생한 부수 효과도 모두 폐기되어야 한다.&lt;/li&gt;
&lt;li&gt;이렇게 함으로써 모든 메시지는 결과적으로 한 번만 처리되도록 보장할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;이종 분산 트랜잭션의 제약&lt;/strong&gt;&lt;br&gt;
트랜잭션의 영향을 받는 시스템이 모두 동일한 원자적 커밋 프로토콜을 사용할 수 있어야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지 처리가 이메일을 전송하는 부수 효과를 유발하는 경우 이메일 서버도 2단계 커밋을 지원해야 한다.&lt;/li&gt;
&lt;li&gt;지원하지 않으면 트랜잭션 재시도 과정에서 이메일이 두 번이상 전송될 수 있음&lt;/li&gt;
&lt;li&gt;트랜잭션 어보트 시 부수효과도 같이 폐기되어야 안전한 재시도를 보장할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xa-트랜잭션&#34;&gt;XA 트랜잭션&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;XA&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X/Open XA(eXtended Architecture)&lt;/li&gt;
&lt;li&gt;이종 분산 트랜잭션을 2단계 커밋으로 구현하는 표준&lt;/li&gt;
&lt;li&gt;여러 관계형 데이터베이스와 메시지 브로커에서 지원된다.&lt;/li&gt;
&lt;li&gt;트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API
&lt;ul&gt;
&lt;li&gt;네트워크 프로토콜이 아니다.&lt;/li&gt;
&lt;li&gt;자바의 경우 JTA(Java Transaction API)로 XA를 구현&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;드라이버&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;애플리케이션이 네트워크 드라이버나 클라이언트 라이브러리를 사용해 데이터베이스, 메시징 서비스와 통신한다고 가정한다.&lt;/li&gt;
&lt;li&gt;드라이버가 XA를 지원한다면 연산이 분산 트랜잭션에 속하는 지를 판단하기 위해 XA API를 호출한다. 분산 트랜잭션인 경우 데이터베이스 서버로 필요한 정보를 보낸다.&lt;/li&gt;
&lt;li&gt;추가로 드라이버는 코디네이터가 준비, 커밋, 어보트 요청을 할 수 있도록 코디네이터에게 콜백을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;코디네이터&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XA API를 구현한다.&lt;/li&gt;
&lt;li&gt;보통 트랜잭션을 시작하는 애플리케이션과 같은 프로세스에 로딩되는 단순한 라이브러리
&lt;ul&gt;
&lt;li&gt;참여자에게 요청은 드라이버의 콜백을 통해 전송한다.&lt;/li&gt;
&lt;li&gt;결정을 기록하기 위해 로컬 디스크의 로그를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;복구 : 애플리케이션 프로세스가 죽거나 장비가 죽는 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코디네이터도 같이 죽고 몇몇 트랜잭션들이 의심스러운 상태가 된다.&lt;/li&gt;
&lt;li&gt;복구 과정은 이전의 2PC와 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;의심스러운-상태에-있는-동안-잠금을-유지하는-문제&#34;&gt;의심스러운 상태에 있는 동안 잠금을 유지하는 문제&lt;/h2&gt;
&lt;p&gt;트랜잭션이 의심스러운 상태에 있는 동안 트랜잭션과 관련된 객체에 잠금이 설정될 수 있다.&lt;br&gt;
잠금은 트랜잭션이 커밋, 어보트 되기 전까지 해제가 불가능하다. (그림 9-9의 음영 처리 영역 참고)&lt;br&gt;
코디네이터의 로그가 손실된 경우 관리자가 수동으로 잠금을 해제해야 하는 경우도 있다.&lt;br&gt;
잠금이 유지되면 다른 트랜잭션 실행에 지장을 초래하여 애플리케이션에도 치명적이다.&lt;/p&gt;
&lt;h2 id=&#34;코디네이터-장애에서-복구하기&#34;&gt;코디네이터 장애에서 복구하기&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;고아가 된 의심스러운 트랜잭션&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이론과 달리 현실에서는 코디네이터가 복구 과정에서 결과를 결정할 수 없는 트랜잭션이 존재&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션 로그가 손실된 경우&lt;/li&gt;
&lt;li&gt;소프트웨어 버그&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 트랜잭션에 의한 잠금은 자동으로 해소되지 않아 관리자의 개입을 필요로 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 서버 재부팅을 해도 잠금이 유지된다.&lt;/li&gt;
&lt;li&gt;잠금이 자동으로 해소되면 원자성이 깨질 위험이 있기 때문&lt;/li&gt;
&lt;li&gt;관리자가 참여자의 상태를 조사하고 커밋, 롤백을 수동으로 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;경험적 결정(heuristic decision)&lt;/strong&gt;
관리자가 개입하여 해결하는 것은 많은 수작업을 요구하고 (심각한 상황이므로) 높은 스트레스를 유발한다.&lt;br&gt;
그래서 여러 XA 구현에서 참여자가 코디네이터의 결정 없이 트랜잭션의 커밋 여부를 일방적으로 결정할 수 있도록 하는 경험적 결정이라는 비상 탈출구를 제공한다.&lt;br&gt;
그런데 이는 2PC의 약속을 깨뜨리기 때문에 원자성을 위반할 위험이 있다.&lt;br&gt;
따라서 경험적 결정은 평상시에 사용하는 것이 아닌, 큰 장애 상황을 벗어나기 위한 용도로 의도된 것이다.&lt;/p&gt;
&lt;h2 id=&#34;분산-트랜잭션의-제약&#34;&gt;분산 트랜잭션의 제약&lt;/h2&gt;
&lt;p&gt;XA 트랜잭션은 여러 참여 데이터 시스템이 서로 일관성을 유지하는 문제를 해결해준다.&lt;br&gt;
그러나 다음과 같은 운영상 문제를 유발한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;코디네이터가 전체 시스템의 단일 장애점(single point of failure)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;코디네이터가 복제되지 않고 단일 장비에서만 실행되면 전체 시스템의 단일 장애점이 된다.&lt;/li&gt;
&lt;li&gt;코디네이터에 장애가 생기면 결과적으로 애플리케이션 전체에 영향을 주기 때문&lt;/li&gt;
&lt;li&gt;그럼에도 불구하고 여러 코디네이터 구현은 고가용성을 제공하지 않거나 기본적인 복제만 지원&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;애플리케이션 서버가 상태를 갖게(stateful) 된다&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;서버 애플리케이션은 영속적인 상태를 데이터베이스에 저장한다.&lt;/li&gt;
&lt;li&gt;이는 서버가 무상태성(stateless)이어야 확장성에 유리하기 때문&lt;/li&gt;
&lt;li&gt;코디네이터가 애플리케이션 서버의 일부가 되면 트랜잭션 로그가 서버의 로컬 디스크에 저장된다.&lt;/li&gt;
&lt;li&gt;따라서 서버가 상태를 갖게 되는 문제가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;XA에서 제공할 수 있는 기능에도 제약이 존재&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XA는 여러 데이터 시스템과 호환되는 만큼 공통 분모에 해당하는 기능만 제공할 수 있음&lt;/li&gt;
&lt;li&gt;여러 시스템에 걸친 교착상태를 감지할 수 없음
&lt;ul&gt;
&lt;li&gt;이러한 기능을 제공하려면 서로 다른 시스템이 각 트랜잭션이 대기중인 잠금에 대한 정보를 교환할 수 있는 프로토콜을 필요로 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;직렬성 스냅숏 격리(SSI)를 지원하지 못함
&lt;ul&gt;
&lt;li&gt;SSI를 지원하려면 여러 시스템에 걸친 충돌을 식별할 수 있는 프로토콜이 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;시스템이 결함에 취약해지는 문제&lt;/strong&gt;
XA가 아닌 데이터베이스 내부 분산 트랜잭션은 제약이 그리 크지 않다.&lt;br&gt;
가령 분산 환경에서의 SSI를 지원한다. 2PC가 성공적으로 트랜잭션을 커밋하려면 모든 참여자가 응답해야 한다.&lt;br&gt;
즉, 시스템의 어떤 부분이라도 고장이 나면 트랜잭션이 실패한다.&lt;br&gt;
따라서 분산 트랜잭션은 장애를 증폭시키는 경향이 있어 시스템이 내결함성을 보장하지 못하게 한다.&lt;/p&gt;
&lt;h2 id=&#34;내결함성을-지닌-합의&#34;&gt;내결함성을 지닌 합의&lt;/h2&gt;
&lt;p&gt;비공식적으로 합의는 여러 노드가 어떤 것에 동의하는 것을 의미한다.&lt;br&gt;
여러 사용자가 동시에 동일한 좌석 예약을 하는 경우 처럼 공존할 수 없는 연산들 중 어떤 것이 승자가 되는 지를 결정하기 위해 합의 알고리즘을 사용할 수 있다.&lt;br&gt;
하나 또는 그 이상의 노드들이 값을 제안하고 합의 알고리즘이 값 중 하나를 결정한다.&lt;/p&gt;
&lt;h3 id=&#34;합의-알고리즘의-속성&#34;&gt;합의 알고리즘의 속성&lt;/h3&gt;
&lt;p&gt;이 때 합의 알고리즘은 다음 속성을 만족해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;균일한 동의&lt;/strong&gt; : 어떤 두 노드도 다르게 결정하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;무결성&lt;/strong&gt; : 어떤 노드도 두 번 결정하지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;유효성&lt;/strong&gt; : 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;종료&lt;/strong&gt; : 죽지 않은 노드는 결국 어떤 값을 결정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;균일한 동의, 무결성, 유효성&lt;/strong&gt;
균일한 동의와 무결성 속성은 합의의 핵심 아이디어를 정의한다.&lt;br&gt;
모두 같은 결과로 결정하며 한 번 결정하면 결정을 번복 할 수 없다.&lt;br&gt;
유효성 속성은 뻔한 해결책을 배제하기 위해 존재한다.&lt;br&gt;
가령 무엇을 제안하든 상관 없이 항상 null로 결정하는 알고리즘도 있을 수 있다.&lt;br&gt;
이러한 알고리즘은 균일한 동의와 무결성을 만족하지만 유효성을 만족하지는 못한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;종료&lt;/strong&gt;
종료는 내결함성과 관련된 속성이다.&lt;br&gt;
내결함성을 만족시킬 필요가 없으면 종료를 제외한 세 개의 속성을 만족하는 것은 간단하다.&lt;br&gt;
한 노드를 ‘독재자&amp;rsquo;로 결정하여 그 노드가 모든 결정을 내리게 하면 된다.&lt;br&gt;
그러나 ‘독재가&amp;rsquo; 노드에 장애가 발생하면 시스템은 어떤 결정도 내릴 수 없다.&lt;br&gt;
2단계 커밋에서 코디네이터가 죽는 경우와도 같다.&lt;/p&gt;
&lt;p&gt;종료 속성에 의해 합의 알고리즘에서 합의는 중단될 수 없다. 반드시 진행되어야 한다.&lt;br&gt;
일부 노드에 장애가 발생해도 나머지 노드는 반드시 결정을 내려야 한다.&lt;br&gt;
종료는 활동성 속성이고 다른 세 개는 안전성 속성이다.&lt;/p&gt;
&lt;h3 id=&#34;합의-알고리즘의-가정&#34;&gt;합의 알고리즘의 가정&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;죽은 노드는 돌아오지 않는다&lt;/strong&gt;&lt;br&gt;
합의 시스템 모델은 어떤 노드가 죽는 경우 그 노드가 돌아오지 않는다고 가정한다.&lt;br&gt;
지진과 같은 자연재해로 인해 노드가 파괴되는 경우를 고려하면 노드가 돌아온다고 가정할 수 없다.&lt;br&gt;
이런 상황에서 노드가 복구되기를 기다리는 알고리즘은 절대로 종료 속성을 만족할 수 없다.&lt;br&gt;
가령 코디네이터의 복구를 전제로 하는 2PC는 종료 속성을 만족하지 못한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;과반수의 노드는 존재해야 한다&lt;/strong&gt;
모든 노드가 죽으면 결정 자체가 불가능하다.&lt;br&gt;
어떤 합의 알고리즘이든 노드의 과반수 이상이 올바르게 동작해야 합의를 달성할 수 있다.&lt;br&gt;
과반수의 노드에 장애가 발생하여도 안전성 속성(균일한 동의, 무결성, 유효성)은 항상 만족한다.&lt;br&gt;
결정을 내리진 못하더라도 유효하지 않은 결정을 내려서 합의 시스템을 오염시키지는 않는다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;비잔틴 결함은 없다고 가정한다&lt;/strong&gt;&lt;br&gt;
(* 참고 : 비잔틴 결함)&lt;br&gt;
비잔틴 결함을 가정하면 합의 알고리즘의 안전성 속성을 위반할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;합의-알고리즘과-전체-순서-브로드캐스트&#34;&gt;합의 알고리즘과 전체 순서 브로드캐스트&lt;/h2&gt;
&lt;p&gt;내결함성을 지닌 합의 알고리즘의 대다수는 합의의 형식적 모델을 직접 사용하지 않는다.&lt;br&gt;
&lt;em&gt;(합의의 형식적 모델 : 합의의 네 개의 속성을 만족하면서 하나의 값을 제안하고 결정)&lt;/em&gt;&lt;br&gt;
대신 값의 순차열에 대해 결정하여 전체 순서 브로드캐스트 알고리즘을 구현한다.&lt;br&gt;
각 노드는 매 회마다 다음에 보낼 메시지를 제안하고, 결정한다.&lt;br&gt;
전체 순서 브로드캐스트는 합의를 여러 번 반복하는 것과 동일하다.&lt;/p&gt;
&lt;p&gt;각 합의 결정이 하나의 메시지 전달에 해당한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;균일한 동의 : 모든 노드는 같은 메시지를 같은 순서로 전달한다.&lt;/li&gt;
&lt;li&gt;무결성 : 메시지는 중복되지 않는다.&lt;/li&gt;
&lt;li&gt;유효성 : 메시지는 조작되거나, 오염되지 않는다.&lt;/li&gt;
&lt;li&gt;종료 : 메시지는 반드시 전달되며, 손실되지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단일-리더-복제와-합의&#34;&gt;단일 리더 복제와 합의&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;단일 리더 복제는 합의 알고리즘의 속성을 만족하는가?&lt;/strong&gt;&lt;br&gt;
단일 리더 복제는 모든 쓰기를 리더에서 처리하고 이를 같은 순서로 모든 팔로워에게 적용한다.&lt;br&gt;
본질적으로 전체 순서 브로드캐스트와 동일해보인다. 그런데 단일 리더 복제에서는 합의를 고려하지 않았다.&lt;/p&gt;
&lt;p&gt;합의를 고려할 필요가 없었던 것일까? 이는 리더가 어떻게 선택되는 지와 관련이 있다.&lt;br&gt;
만약 운영 측에서 리더를 수동으로 설정한다면 이는 ‘독재자’ 노드가 모든 것을 결정하는 합의와 같다.&lt;br&gt;
이 방식은 합의의 안전성 속성을 만족하지만, 종료 속성을 만족하지 못한다고 앞서 언급했다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;합의를 해결하기 위해 합의가 필요하다?&lt;/strong&gt;
단일 리더 복제에서 리더가 죽으면 새로운 리더를 선출하는 장애 복구 과정이 수행될 수 있다.&lt;br&gt;
장애 복구가 수행되는 것을 가정하면 단일 리더 복제는 내결함성을 지닌 전체 순서 브로드캐스트와 동일해 보인다.&lt;br&gt;
전체 순서 브로드캐스트와 합의의 동등성에 대해 앞서 언급했다.&lt;br&gt;
내결함성을 지닌 전체 순서 브로드캐스트를 구현하면 합의의 문제를 해결할 수 있어 보인다.&lt;/p&gt;
&lt;p&gt;그런데 한 가지 문제가 있다. 리더를 선출하는 과정에서 합의가 필요하다.&lt;br&gt;
이 과정이 잘못되면 둘 이상의 노드가 자신을 리더로 생각하는 스플릿 브레인 현상이 발생할 수 있다.&lt;br&gt;
합의는 전체 순서 브로드캐스트 문제와 동등하고, 전체 순서 브로드캐스트는 단일 리더 복제와 동일해 보인다.&lt;br&gt;
단일 리더 복제는 리더가 필요하다. 리더를 선출하기 위해 리더가 필요하다는 결론으로 이어진다.&lt;br&gt;
합의를 해결하기 위해 합의가 필요하다는 난제에 부딪히게 된다.&lt;/p&gt;
&lt;h2 id=&#34;에포크-번호-붙이기와-정족수&#34;&gt;에포크 번호 붙이기와 정족수&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;에포크 번호와 리더 선출&lt;/strong&gt;&lt;br&gt;
지금까지 설명한 합의 프로토콜은 리더가 유일함을 보장하지는 않는다.&lt;br&gt;
대신에 특정 시점에 진행된 투표에서 선출된 리더가 유일함을 보장하는 것은 가능하다.&lt;br&gt;
이 특정 시점을 구별하기 위해 번호를 매기는데, 이를 에포크 번호라 한다.&lt;/p&gt;
&lt;p&gt;현재의 리더가 죽었다고 판단되면 새 리더를 선출하기 위해 노드 사이에서 투표가 시작된다.&lt;br&gt;
이 선출은 에포크 번호를 증가시킨다. 에포크 번호는 전체 순서가 있으며 단조 증가한다.&lt;br&gt;
스스로 리더라 생각하는 둘 이상의 노드에 의견 충돌이 있는 경우 에포크 번호가 높은 리더가 승리한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;리더는 자신이 유효한 리더임을 어떻게 확신할 수 있나?&lt;/strong&gt;
리더의 입장에서는 자신보다 에포크 번호가 높은 리더가 있는지 확신할 수 없다.&lt;br&gt;
다른 노드도 자신을 리더로 생각할까? 리더는 결정을 내리기 전에 이를 먼저 확인해야 한다.&lt;br&gt;
리더는 모든 결정 마다 제안한 값에 대해 다른 노드에게 찬반 요청을 보낸다.&lt;br&gt;
요청을 받은 노드는 요청을 보낸 노드보다 에포크 번호가 높은 리더를 알지 못한다면 찬성한다.&lt;br&gt;
그리고 리더는 정족수의 찬성 표를 얻어야 한다.&lt;/p&gt;
&lt;p&gt;노드 정족수의 찬성표를 얻으면 결정할 수 있는 것일까? 한 가지 조건이 더 필요하다.&lt;br&gt;
찬성에 투표한 노드 중에서 최소 하나의 노드는 가장 최근에 진행된 리더 선출에 참여했어야 한다.&lt;br&gt;
그 노드가 찬성했다는 것은 에포크 번호가 더 높은 리더가 없다는 것을 의미하고, 따라서 리더 스스로 자신이 여전히 유효한 리더라고 확신할 수 있음을 의미한다.&lt;br&gt;
유효한 리더라고 확신한 이후, 리더는 자신있게 결정을 내릴 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2단계 커밋과 내결함성 합의 알고리즘의 차이&lt;/strong&gt;
방금 살펴본 알고리즘이 내결함성을 지닌 합의 알고리즘의 대표적인 방식이다.&lt;br&gt;
내결함성을 지닌 합의 알고리즘과 2단계 커밋은 다소 비슷해 보이지만 다르다.&lt;br&gt;
2단계 커밋은 모든 참여자로부터 ‘네&amp;rsquo;라는 응답을 요구한다.&lt;br&gt;
내결함성을 지닌 합의 알고리즘은 노드의 과반수로부터만 투표를 받으면 된다.&lt;br&gt;
그리고 합의 알고리즘은 새로운 리더가 선출된 이후 노드를 일관적인 상태로 만들어주는 복구 과정을 정의한다.&lt;br&gt;
복구 과정을 통해 안전성 속성이 항상 만족되도록 보장한다.&lt;br&gt;
이러한 차이점이 합의 알고리즘의 정확성과 내결함성의 핵심이다.&lt;/p&gt;
&lt;h2 id=&#34;합의의-제약&#34;&gt;합의의 제약&lt;/h2&gt;
&lt;p&gt;합의 알고리즘을 통해 분산 시스템에서 일관성과 내결함성을 모두 달성할 수 있다. 그러나 합의 알고리즘을 유지하기 위한 비용이 적지 않다.&lt;/p&gt;
&lt;h3 id=&#34;동기식-복제가-강제됨&#34;&gt;동기식 복제가 강제됨&lt;/h3&gt;
&lt;p&gt;제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제다.&lt;br&gt;
동기식 복제가 비동기 복제보다 일관성, 지속성 측면에서 안전함에도 불구하고 성능을 이유로 선호되지 않는다.&lt;/p&gt;
&lt;h3 id=&#34;과반수에-대한-제약&#34;&gt;과반수에 대한 제약&lt;/h3&gt;
&lt;p&gt;합의 시스템은 항상 엄격한 과반수가 동작하는 것을 요구한다.&lt;br&gt;
노드 한 대의 장애를 견디려면 최소한 세 대의 노드, 두 대의 장애를 견디려면 최소 다섯 대의 노드가 필요하다.&lt;br&gt;
네트워크 장애로 일부 노드가 다른 노드와 연결이 끊기면 과반수의 부분만 동작이 가능하고 나머지는 차단된다.&lt;/p&gt;
&lt;h3 id=&#34;노드-수-변경에-대한-제약&#34;&gt;노드 수 변경에 대한 제약&lt;/h3&gt;
&lt;p&gt;대부분 합의 알고리즘은 투표에 참여하는 노드 집합이 고정되어 있다고 가정한다.&lt;br&gt;
따라서 클러스터에 노드를 그냥 추가하거나 제거할 수 없다.&lt;br&gt;
합의 알고리즘의 동적 멤버십 확장은 클러스터에 있는 노드 집합이 시간이 지남에 따라 바뀌는 것을 허용하지만 정적 멤버십 알고리즘보다 훨씬 이해하기 어렵다.&lt;/p&gt;
&lt;h3 id=&#34;네트워크-문제에-민감&#34;&gt;네트워크 문제에 민감&lt;/h3&gt;
&lt;p&gt;합의 시스템은 장애를 감지하기 위해 타임아웃에 의존한다.&lt;br&gt;
타임아웃은 노드의 문제와 네트워크 문제를 구별하지 못해 네트워크 문제 시에도 노드가 죽었다고 판단할 수 있다.&lt;br&gt;
이러한 오류로 인해 리더가 자주 새로 선출되면 시스템이 본연의 일이 아닌 리더를 선출하는 데 더 집중하게 된다.&lt;br&gt;
이러한 현상은 성능 문제로 연결된다.&lt;/p&gt;
&lt;h2 id=&#34;멤버십과-코디네이션-서비스&#34;&gt;멤버십과 코디네이션 서비스&lt;/h2&gt;
&lt;p&gt;주키퍼나 etcd 같은 프로젝트는 종종 ‘분산 키-값 저장소&amp;rsquo;나 ‘코디네이션 설정 서비스&amp;rsquo;라고 설명된다.&lt;br&gt;
주키퍼와 etcd는 메모리에 적재가 가능한 작은 양의 데이터를 보관하도록 설계되었다.&lt;br&gt;
이 소량의 데이터는 내결함성을 지닌 전체 순서 브로드캐스트를 통해 모든 노드에 걸쳐 복제된다.&lt;br&gt;
주키퍼는 구글의 처비(Chubby) 잠금 서비스를 모델로 삼아 전체 순서 브로드캐스트 뿐만 아니라 분산 시스템을 구축 시 유용한 다른 기능들도 구현한다. 그 기능들은 다음과 같다.&lt;/p&gt;
&lt;h3 id=&#34;선형성-원자적-연산&#34;&gt;선형성 원자적 연산&lt;/h3&gt;
&lt;p&gt;원자적 compare-and-set 연산을 사용해 잠금을 구현할 수 있다.&lt;br&gt;
여러 노드가 동시에 같은 연산을 수행하려고 하면 그것들 중 하나만 성공한다.&lt;br&gt;
합의 프로토콜은 노드에 장애가 나거나 어느 시점에 네트워크가 끊기더라도 그 연산이 원자적이고 선형적일 것을 보장한다.&lt;br&gt;
분산 잠금을 보통 클라이언트에 장애가 난 경우 결국에는 해제되도록 만료 시간이 있는 임차권(lease)으로 구현된다.&lt;/p&gt;
&lt;h3 id=&#34;연산의-전체-순서화&#34;&gt;연산의 전체 순서화&lt;/h3&gt;
&lt;p&gt;어떤 자원이 잠금이나 임차권으로 보호될 때는 프로세스가 중단되는 경우 클라이언트들이 서로 충돌하는 것을 막기 위해 펜싱 토큰이 필요하다.&lt;br&gt;
펜싱 토큰은 잠금을 획득할 때마다 단조 증가하는 어떤 숫자다.&lt;br&gt;
주키퍼는 모든 연산에 전체 순서를 정하고 각 연산에 단조 증가하는 트랜잭션 ID(zxid)와 버전 번호(cversion)를 할당하여 이를 제공한다.&lt;/p&gt;
&lt;h3 id=&#34;장애-감지&#34;&gt;장애 감지&lt;/h3&gt;
&lt;p&gt;클라이언트는 주키퍼 서버에 수명이 긴 세션을 유지하고 클라이언트와 서버는 주기적으로 하트비트(heartbeat)를 교환해서 다른 쪽이 여전히 살아 있는지 확인한다.&lt;br&gt;
연결이 일시적으로 끊기거나 주키퍼 노드에 장애가 나더라도 세션은 살아있다.&lt;br&gt;
그러나 세션 타임아웃보다 긴 기간 동안 하트비트가 멈추면 주키퍼는 세션이 죽었다고 선언한다.&lt;br&gt;
세션에서 획득한 잠금은 세션이 타임아웃 되었을 때 자동으로 해제되도록 설정할 수 있다.&lt;br&gt;
주키퍼에서는 이를 단명 노드(ephemeral node)라 한다.&lt;/p&gt;
&lt;h3 id=&#34;변경-알림&#34;&gt;변경 알림&lt;/h3&gt;
&lt;p&gt;클라이언트는 다른 클라이언트가 생성한 잠금과 값을 읽을 수 있을 뿐만 아니라 거기에 변경이 있는지 감시할 수도 있다.&lt;br&gt;
따라서 클라이언트는 다른 클라이언트가 언제 클러스터에 합류했는지 혹은 다른 클라이언트에 장애가 났는지 알아챌 수 있다.&lt;br&gt;
알림을 구독함으로써 클라이언트는 변경을 발견하기 위해 주기적으로 폴링해야 하는 필요를 피할 수 있다.&lt;/p&gt;
&lt;p&gt;방금 살펴본 기능들 중 오직 선형성 원자적 연산만 실제로 합의가 필요하다.&lt;br&gt;
그러나 주키퍼를 분산 코디네이션에 매우 유용하게 만들어주는 것은 이러한 기능들의 조합이다.&lt;/p&gt;
&lt;h2 id=&#34;작업을-노드에-할당하기&#34;&gt;작업을 노드에 할당하기&lt;/h2&gt;
&lt;p&gt;주키퍼/처비 모델이 잘 동작하는 경우가 몇 가지 있다.
하나는 여러 개의 프로세스나 서비스가 있고 그 중 하나가 리더 혹은 주 구성요소로 선택되어야 하는 경우다.&lt;br&gt;
리더에 장애가 발생하면 다른 노드 중 하나가 넘겨 받아야 한다. 이는 단일 리더 설정에서 유용하다.&lt;br&gt;
또 다른 경우는 파티셔닝된 자원이 있고 어떤 파티션을 어떤 노드에 할당해야 할 지 결정하는 경우다.&lt;br&gt;
새 노드들이 클러스터에 합류하면서 부하의 재균형화를 위해 어떤 파티션들은 새로운 노드로 이동해야 한다.&lt;br&gt;
혹은 노드가 제거되거나 장애가 나면 다른 노드들이 장애가 난 노드의 작업을 넘겨받아야 한다.&lt;/p&gt;
&lt;p&gt;이런 종류의 작업은 주키퍼에서 원자적 연산, 단명 노드, 알림을 신중하게 사용하면 잘 수행할 수 있다.&lt;br&gt;
심지어 사람의 개입이 없이도 애플리케이션이 결함에서 자동으로 복구되도록 할 수 있다.&lt;br&gt;
물론 쉽지는 않지만 합의 알고리즘을 밑바닥 부터 직접 구현하는 방법보다는 훨씬 낫다.&lt;/p&gt;
&lt;p&gt;애플리케이션은 처음에는 단일 노드에서 실행될 지 모르지만 이후 수천 대의 노드로 늘어날 수도 있다.&lt;br&gt;
매우 많은 노드에서 과반수 투표를 수행하는 것은 비효율적이다.&lt;br&gt;
주키퍼는 대신 고정된 수의 노드에서 실행되고 이 노드들 사이에서 과반수 투표를 수행한다.&lt;br&gt;
주키퍼는 노드들을 코디네이트 하는 작업의 일부를 외부 서비스에 위탁하는 방법을 제공한다.&lt;/p&gt;
&lt;h2 id=&#34;서비스-찾기&#34;&gt;서비스 찾기&lt;/h2&gt;
&lt;p&gt;주키퍼, etcd, 콘술(Consul)은 서비스 찾기 용도로도 자주 사용된다.&lt;br&gt;
(* 서비스 찾기(service discovery) : 특정 서비스에 연결하기 위해 IP 주소를 알아내는 것)&lt;br&gt;
서비스 찾기가 실제로 합의가 필요한 지는 명확하지 않다.&lt;br&gt;
DNS의 경우도 선형성을 보장하지 않지만 이것이 보통 문제가 되지는 않는다.&lt;/p&gt;
&lt;p&gt;리더 선출의 경우는 합의가 필요하고, 합의 시스템이 리더가 누구인지를 알면 다른 서비스들이 리더가 누구인지 찾는데 그 정보를 사용하는 것도 타당하다.&lt;br&gt;
어떤 합의 시스템은 읽기 전용 캐시 복제 서버를 지원한다.&lt;br&gt;
이 복제 서버는 합의 알고리즘의 모든 결정에 대한 로그를 비동기로 받지만 능동적으로 투표에 참여하지는 않는다.&lt;br&gt;
이 복제 서버는 선형성을 보장하지 않아도 되는 읽기 요청을 서비스할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;멤버십-서비스&#34;&gt;멤버십 서비스&lt;/h2&gt;
&lt;p&gt;주키퍼와 유사 프로젝트들은 오랜 멤버십 서비스 연구 역사의 일부로 볼 수 있다.&lt;br&gt;
멤버십 서비스는 클러스터에서 어떤 노드가 현재 살아있는 멤버인지 결정한다.&lt;br&gt;
장애 감지를 합의와 연결하여 노드들이 어떤 노드가 살아있고 죽었는지에 동의할 수 있다.&lt;br&gt;
물론 기약 없는 네트워크 지연 때문에 노드에 장애가 발생한 것인지 확실히 알 수는 없고, 잘못 판단할 수 있다.&lt;br&gt;
그럼에도 불구하고 합의는 시스템에서 어떤 노드가 현재 멤버십을 구성하는 지 동의하는데 매우 유용하다.&lt;/p&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 10장. 일괄 처리</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/10/</link>
      <pubDate>Fri, 22 Apr 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/10/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 김정수, 박수민&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.devkuma.com/docs/data-intensive-application/10_ppt.pdf&#34;&gt;발표자료&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;일괄처리-대안&#34;&gt;일괄처리 대안&lt;/h2&gt;
&lt;p&gt;맵리듀스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점: 분산 파일 시스템 상에서 상당히 단순 명료하게 추상화된 모델&lt;/li&gt;
&lt;li&gt;단점: 복잡한 연산은 매우 힘듬&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;맵리듀스-중간-상태-구체화&#34;&gt;맵리듀스 중간 상태 구체화&lt;/h3&gt;
&lt;p&gt;일괄처리 워크플로우에서 &lt;strong&gt;각 태스크&lt;/strong&gt;의 &lt;strong&gt;output&lt;/strong&gt;(&lt;strong&gt;중간상태&lt;/strong&gt;)을 &lt;strong&gt;분산 파일 시스템&lt;/strong&gt;에 &lt;strong&gt;파일&lt;/strong&gt;로 저장(구체화)해두는 방법&lt;/p&gt;
&lt;p&gt;(복잡한 연산을 여러 맵리듀스로 분할하여 처리)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분산 파일 시스템: 태스크의 output을 파일로 저장하는 장치
&lt;ul&gt;
&lt;li&gt;이 파일은 다른 태스크의 input으로 사용 (주로 태스크 간의 데이터 전달을 위한 용도)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;중간 상태: 이러한 파일로 저장되어 있는 상태
&lt;ul&gt;
&lt;li&gt;복잡한 워크플로우에서는 매우 많은 중간 상태가 존재&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;구체화: 중간 상태를 파일로 저장하는 과정
&lt;ul&gt;
&lt;li&gt;요청이 왔을 때 결과를 생성하는 것이 아니라 &lt;strong&gt;미리 특정 연산 결과를 생성&lt;/strong&gt;해 두는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(유닉스 파이프 대비) 단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;선행 작업이 완료되어야 후행 작업 시작 가능
&lt;ul&gt;
&lt;li&gt;유닉스 파이프는 동시에 작업이 진행
&lt;ul&gt;
&lt;li&gt;데이터의 생성과 동시에 소비가 이루어짐&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;워크플로우의 전체 수행 시간이 느리다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;매퍼 중복
&lt;ul&gt;
&lt;li&gt;매퍼는 리듀서가 생성한 파일을 읽어 파티셔닝과 정렬을 수행
&lt;ul&gt;
&lt;li&gt;불필요한 IO 발생&lt;/li&gt;
&lt;li&gt;리듀서가 매퍼의 기능도 가지게 함으로써 해결 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;분산 파일 시스템의 모든 장비에 중간 상태 파일들의 복제가 발생
&lt;ul&gt;
&lt;li&gt;중간 상태 파일들은 임시 데이터임에 불구하고, 복제는 분산 파일 시스템을 사용함으로써 발생하는 과도한 비용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터플로우-엔진dataflow-engine&#34;&gt;데이터플로우 엔진(Dataflow Engine)&lt;/h3&gt;
&lt;p&gt;맵리듀스의 문제를 해결하기 위한 분산 일괄 처리 연산을 수행하는 엔진 등장&lt;/p&gt;
&lt;p&gt;데이터의 흐름을 명시적으로 모델링 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스파크(Spark) : 프레임워크&lt;/li&gt;
&lt;li&gt;테즈(Tez) : 가벼운 라이브러리&lt;/li&gt;
&lt;li&gt;플링크(Flik) : 프레임워크&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;프레임워크 : 자체 네트워크 통신 계층, 스케줄러, API 등을 갖춤&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://trends.google.com/trends/explore?cat=32&amp;amp;q=Spark,Tez,Flink&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://trends.google.com/trends/explore?cat=32&amp;q=Spark,Tez,Flink&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/10_treands.png&#34; alt=&#34;스트림 테이블 조인&#34;&gt;&lt;/p&gt;
&lt;p&gt;특징&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;워크플로우를 독립된 하위 작업으로 나누지 않고 하나의 작업으로 다룬다.&lt;/li&gt;
&lt;li&gt;(맵리듀스처럼) 단일 스레드에서 사용자 정의 함수를 호출해 레코드 하나씩 처리&lt;/li&gt;
&lt;li&gt;입력 데이터를 파티셔닝하여 병렬 처리&lt;/li&gt;
&lt;li&gt;네트워크 복사를 통해 어느 함수의 output이 다른 함수의 input으로 전달된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;연산자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 처리에 사용되는 여러 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;맵리듀스 모델 대비 장점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;정렬 등의 high cost 작업은 필요한 경우에만 수행할 수 있다.
&lt;ul&gt;
&lt;li&gt;맵리듀스는 기본적으로 map과 reduce 사이에서 정렬이 항상 발생&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;지역성 최적화가 가능하다.
&lt;ul&gt;
&lt;li&gt;워크플로우가 명시적이므로 어느 데이터가 어느 시점에 필요한지 알 수 있다.&lt;/li&gt;
&lt;li&gt;함수간의 데이터 전달을 네트워크 복사가 아닌 메모리 공유로 전달할 수 있다. (네트워크 IO 감소)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;중간상태는 로컬 디스크에 저장한다. (IO 소비 감소)
&lt;ul&gt;
&lt;li&gt;HDFS(Hadoop Distributed File System)에 저장할 경우 여러 서버에 복제가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;연산자들은 input이 발생하는 즉시 수행한다.
&lt;ul&gt;
&lt;li&gt;선행 함수의 전체 종료를 기다리지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;연산자 실행 시 마다 JVM을 띄우지 않아도 된다.
&lt;ul&gt;
&lt;li&gt;맵리듀스는 각 태스크마다 JVM을 새로 구동한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터플로우 엔진은 맵리듀스의 워크플로우와 동일한 연산을 구현할 수 있고 여러 최적화를 통해 일반적으로 수행속도가 &lt;strong&gt;훨씬 빠르다.&lt;/strong&gt;&lt;br&gt;
연산자는 맵과 리듀스를 일반화한 것이라 맵리듀스의 워크플로우를 수정없이 간단하게 데이터플로우로 전환할 수 있다. (전환 전에 호환여부를 살펴볼 것)&lt;/p&gt;
&lt;h4 id=&#34;내결함성&#34;&gt;내결함성&lt;/h4&gt;
&lt;p&gt;맵리듀스는 중간 상태를 모두 구체화하기 때문에 내결함성(내구성)을 쉽게 확보할 수 있다.&lt;br&gt;
데이터플로우 엔진은 HDFS에 중간 상태를 구체화하지 않기 때문에 다른 방법을 사용한다. (HDFS를 사용하지 않는 것은 아니다. 원본 데이터는 HDFS에 있다.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로컬에 input 데이터가 남아있으면 다시 연산을 한다. 없으면 HDFS에서 원본 데이터를 가져와서 연산한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;재연산을 하기 위한 연산 추적을 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어느 입력 파티션을 사용했는지 어떤 연산자를 사용했는지 추적해야 한다.&lt;/li&gt;
&lt;li&gt;스파크는 RDD(Resilient Distributed Dateset) 추상화를 사용한다.
&lt;ul&gt;
&lt;li&gt;RDD: 데이터의 여러 요소를 모은 immutable 분산형 컬렉션&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;플링크는 연산자 상태를 체크포인트로 남겨둔다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;재연산 시 &lt;strong&gt;멱등성&lt;/strong&gt;이 보장되어야 한다.&lt;/p&gt;
&lt;p&gt;멱등성 보장을 위해 주의해야할 사항&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 검색 등을 위해 해시 테이블을 사용하는 경우 → 해시 테이블은 특정 순서를 보장하지 않는다.&lt;/li&gt;
&lt;li&gt;연산의 로직이 난수에 의존하는 경우 → 난수가 필요할 경우 고정된 시드 사용 등의 방법으로 난수를 제어&lt;/li&gt;
&lt;li&gt;시스템 시간, 외부 데이터를 사용하는 경우 → 멱등성을 보장하지 못하는 원인은 제거
그러나 만약 중간 데이터의 크기가 작거나 연산이 CPU 리소스를 많이 사용한다면 재연산보다 중간 데이터를 생성하는 것이 효과적일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;구체화에-대한-논의&#34;&gt;구체화에 대한 논의&lt;/h4&gt;
&lt;p&gt;내용 요약&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;선행 작업의 완료를 기다리지 않아도 된다. (파이프라인 방식으로 실행이 가능)&lt;/li&gt;
&lt;li&gt;모든 중간 상태를 HDFS에 저장하지 않아도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;그래프와-반복-처리&#34;&gt;그래프와 반복 처리&lt;/h4&gt;
&lt;p&gt;그래프 데이터 모델에 대한 일괄 처리의 필요성이 확대되고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;페이지 랭크 : 웹 페이지 인기도 측정 알고리즘&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터플로우 엔진에서 데이터 자체는 전형적인 &lt;strong&gt;관계형 튜플&lt;/strong&gt;로 구성된다. 한 연산자에서 다른 연산자로 가는 데이터 흐름이 그래프로 구성된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 연산자를 비순환 방향 그래프로 배열한다.&lt;/li&gt;
&lt;li&gt;데이터&amp;rsquo;플로우&amp;rsquo; 라고 이름을 잘못지어(그래프가 아닌 것 처럼) 혼란을 초래한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터는 관계형 튜플(간선-정점)로 구성될 수 있어서 알고리즘(어떠한 데이터 처리하는 방법) 를 반복적인 형태로 구현할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;맵리듀스로도 구현이 가능하지만 비효율적이다.&lt;/li&gt;
&lt;li&gt;맵리듀스는 알고리즘의 반복적 속성을 고려하지 않는다.
&lt;ul&gt;
&lt;li&gt;데이터를 일회성으로 처리한다.&lt;/li&gt;
&lt;li&gt;예: &amp;lsquo;어떤 조건에 만족할 때까지 해당 태스크를 반복한다&amp;rsquo; 와 같은 형식으로 구현할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;프리글-처리-모델&#34;&gt;프리글 처리 모델&lt;/h4&gt;
&lt;p&gt;일괄 처리 그래프를 최적화하는 방법으로 벌크 동기식 병렬(BSP, Bulk Synchronous Parallel) 연산 모델이 널리 사용된다.&lt;/p&gt;
&lt;p&gt;BSP 구현체&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아파치 지라프(Apache Giraph)&lt;/li&gt;
&lt;li&gt;스파크 그래프 X(Graph X)&lt;/li&gt;
&lt;li&gt;플링크 젤리(Gelly) API
또한 BSP는 프리글(Pregel) 모델로도 불린다. (구글의 프리글 논문에서 그래프 처리 방법론으로 소개되었고 널리 보급되었다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;프리글 = 그래프 병렬/분산 처리 프레임워크&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Large-scale의 그래프를 다루는 것은 매우 어렵다. (최적의 알고리즘을 선택해도 processing cost가 지수적으로 증가하는 것이 일반적)&lt;/li&gt;
&lt;li&gt;그래프의 분산 처리를 위해 사용&lt;/li&gt;
&lt;li&gt;(프리글 자체만으로도 내용이 매우 방대하여 프리글에 대한 자세한 설명 및 책의 내용은 생략)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;고수준-api와-언어&#34;&gt;고수준 API와 언어&lt;/h4&gt;
&lt;p&gt;분산 일괄 처리 엔진의 발전&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;수만 대의 장비로 구성된 클러스터에서 PB(페타바이트, 1PB = 1,000TB)의 데이터를 저장하고 처리하는데 충분하고 견고해졌다.&lt;/li&gt;
&lt;li&gt;기술의 성숙으로 기술로 해결할 수 있는 문제의 범위를 확장하는데 노력&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스파크와 플링크도 자체 고수준 데이터플로우 API를 가지고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;고수준 API를 통해 구현할 연산의 코드를 적게 작성할 수 있다.&lt;/li&gt;
&lt;li&gt;대화식 사용도 지원하여 코드의 동작을 바로 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;결론: 고수준 API를 사용하여 시스템의 생산성을 향상시킬 수 있고, 작업을 더욱 효율적으로 수행할 수 있다.&lt;/p&gt;
&lt;h4 id=&#34;선언형-질의-언어로-전환&#34;&gt;선언형 질의 언어로 전환&lt;/h4&gt;
&lt;p&gt;조인이 필요한 연산의 경우, 조인을 수행하는 코드를 작성하는 것 보다 관계형 연산자로 조인을 표현하면 프레임워크가 조인에 사용할 어떤 알고리즘이 적절한지 자동으로 결정할 수 있다는 장점이 있다. (RDB의 join과 비슷)&lt;/p&gt;
&lt;p&gt;하이브, 스파크, 플링크는 이러한 질의 최적화기를 내장하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 다양한 조인 알고리즘을 모두 알고 있을 필요도, 어떤 알고리즘을 사용할지 고민할 필요도 없다.&lt;/li&gt;
&lt;li&gt;선언적인 방법을 통하여 optimizer가 최적의 수행 방법을 결정한다.&lt;/li&gt;
&lt;li&gt;맵리듀스의 경우 사용자가 직접 코드를 작성할 수 있다는 장점이 있다. (그러나 CPU 리소스의 오버헤드 등의 단점도 있다. 맵리듀스, 데이터플로우 엔진 각각의 특징으로 이해하자.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;다양한-분야를-지원하기-위한-전문화&#34;&gt;다양한 분야를 지원하기 위한 전문화&lt;/h3&gt;
&lt;p&gt;표준화된 처리 패턴이 계속 나타나는 공통 사례가 많다. 그렇기 때문에 재사용 가능한 공통 빌딩 블록을 구현은 중요하다.&lt;/p&gt;
&lt;p&gt;통계학, 수치 알고리즘 분야에서도 일괄 처리의 중요성이 증가하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;통계학, 수치 알고리즘 분야는 분류, 추천 시스템과 같은 머신러닝 애플리케이션을 구축하는데 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위의 분야에서 재사용 가능한 구현을 한 기술&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;머하웃(Mahaou): 맵리듀스, 스파크, 플링크에서 실행되는 다양한 머신러닝용 알고리즘 구현을 가지고 있다.&lt;/li&gt;
&lt;li&gt;매드립(MADlib): 관계형 MPP(Massive Parallel Processing) 데이터베이스에 머신러닝 기능을 추가할 수 있는 오픈소스 라이브러리&lt;/li&gt;
&lt;li&gt;K 최근접 이웃(k-nearest neighbor) 알고리즘: 다차원 공간에 주어진 아이템과 근접한 아이템들을 찾는 일종의 유사도 검색 알고리즘
&lt;ul&gt;
&lt;li&gt;유전자 분석 알고리즘에서 중요하게 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;일괄 처리 시스템은 내장 기능과 고수준 선언적 연산자를 모두 가지고 있어 광범위한 영역에서 필요한 알고리즘을 분산 수행하는데 사용된다.&lt;/p&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
    <item>
      <title>데이터 중심 애플리케이션 설계 | 11장. 스트림 처리</title>
      <link>https://www.devkuma.com/docs/data-intensive-application/11/</link>
      <pubDate>Fri, 29 Apr 2022 00:00:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/data-intensive-application/11/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;발표자 : 김경철, 김민규&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;스트림 : 시간 흐름에 따라 점진적으로 생산된 데이터&lt;br&gt;
스트림 처리 : 일괄 처리와 다르게, 단순히 이벤트가 발생할 때마다 처리한다.&lt;br&gt;
이벤트 스트림 : 점진적인 처리, 시간별로 정렬된 일련의 비즈니스 이벤트&lt;/p&gt;
&lt;h2 id=&#34;이벤트-스트림-전송&#34;&gt;이벤트 스트림 전송&lt;/h2&gt;
&lt;p&gt;이벤트&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;특정 시점에 일어난 사건에 대한 세부 사항을 포함&lt;/li&gt;
&lt;li&gt;일반적으로 일기준 시계를 따르는 이벤트 발생 타임스탬프 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 예제&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;웹페이지를 보거나 상품을 구입하는 일 같은 사용자가 취한 행동&lt;/li&gt;
&lt;li&gt;온도 센서 주기적으로 측정한 값이나 CPU 사용률 지표와 같이 같이 장비에서 발생한 것&lt;/li&gt;
&lt;li&gt;웹 서버 로그의 각줄을 이벤트 하나로 취급&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트의 부호화, 저장, 전송&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;텍스트 문자열이나 JSON 또는 이진 형태 등으로 부호화 가능&lt;/li&gt;
&lt;li&gt;파일 및 관계형 테이블에 삽입 및 문서 데이터베이스로 기록하거나 저장 가능&lt;/li&gt;
&lt;li&gt;다른 노드에서 처리하게끔 네트워트를 통해 전송 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생산자와 소비자&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자(producer), 발생자(pubisher), 발송자(sender)는 &lt;strong&gt;이벤트를 만든다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;소비자(consumer), 구독자(subscriber), 수신자(recipient)는 &lt;strong&gt;이벤트를 처리한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;스트림 시스템에서는 토픽(topic)이나 스트림으로 관련 &lt;strong&gt;이벤트를 묶는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스트림 처리와 일괄 처리 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스트림 처리
&lt;ul&gt;
&lt;li&gt;생산자는 만들어낸 모든 이벤트를 데이터스토어 기록한다.&lt;/li&gt;
&lt;li&gt;각 소비자는 주기적으로 데이터스토어에 폴링해 마지막에 처리한 이후에 새로 발생한 이벤트가 있는지 확인하고 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일괄 처리
&lt;ul&gt;
&lt;li&gt;매일 마지막에 그날 데이터 분량을 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;차이점
&lt;ul&gt;
&lt;li&gt;스트림 처리 발생할 때마다 확인하고 처리한다.&lt;/li&gt;
&lt;li&gt;일괄 처리 모와서 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;공통점
&lt;ul&gt;
&lt;li&gt;마지막 처리된 이후로 이어서 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메시징-시스템&#34;&gt;메시징 시스템&lt;/h3&gt;
&lt;p&gt;메시징 시스템(messaging system) 역할&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 일방적인 방법으로 &lt;strong&gt;메시징 시스템&lt;/strong&gt;을 사용한다.&lt;/li&gt;
&lt;li&gt;생산자는 이벤트를 포함한 메시지 전송한다.&lt;/li&gt;
&lt;li&gt;소비자는 그 메시지를 전달 받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;생산자와 소비자 연결&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;유닉스 파이프, TCP 연결
&lt;ul&gt;
&lt;li&gt;생산자와 소비자 사이를 직접 통신 채널을 사용하는 방법
&lt;ul&gt;
&lt;li&gt;메시지 시스템을 구축하는 가장 간단한 방법&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;전송자 하나를 정확히 수신자 하나에 연결&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메시징 시스템
&lt;ul&gt;
&lt;li&gt;다수의 생산자 노드가 같은 토픽(topic)으로 메시지를 전송한다.&lt;/li&gt;
&lt;li&gt;다수의 소비자 노드가 토픽(topic) 하나에서 메시지를 받아 간다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;발생/구독(publish/subscribe, pub/sub) 모델에서의 시스템들의 다양한 접근법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 메시지를 전송한다면 어떻게 될까?
&lt;ul&gt;
&lt;li&gt;3가지 선택지
&lt;ul&gt;
&lt;li&gt;시스템 메시지를 버린다.&lt;/li&gt;
&lt;li&gt;큐에 메시지를 버퍼링한다.&lt;/li&gt;
&lt;li&gt;배압(backpressure)을 적용한다.
&lt;ul&gt;
&lt;li&gt;흐름 제어(flow control)이라고 한다.&lt;/li&gt;
&lt;li&gt;생산자가 메시지를 더 보내지 못하게 막는다.&lt;/li&gt;
&lt;li&gt;유닉스 파이프와 TCP을 배압을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메시지가 큐에 버퍼링될 때, 큐 크기가 증가하게 된다면?
&lt;ul&gt;
&lt;li&gt;큐 크기가 메모리 크리보다 더 커지면 시스템이 중단되는가?&lt;/li&gt;
&lt;li&gt;메시지를 디스크에 쓰는가?
&lt;ul&gt;
&lt;li&gt;쓴다면 메시징 시스템의 성능에 어떤 영향을 주는가?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;노드가 죽거나 일시적으로 오프라인이 된다면 어떻게 될까? 손실되는 메시지가 있을까?
&lt;ul&gt;
&lt;li&gt;지속성을 갖추려면? 비용 발생
&lt;ul&gt;
&lt;li&gt;디스크에 기록&lt;/li&gt;
&lt;li&gt;복제본 생성&lt;/li&gt;
&lt;li&gt;둘 다 필요&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메시지를 읽어도 된다면? 비용 절약
&lt;ul&gt;
&lt;li&gt;하드웨어 처리량을 높일 수 있다.&lt;/li&gt;
&lt;li&gt;지연 시간을 낮출 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;메시지의 유실&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지가 유실된다면, 애플리케이션에 따라 다르다.
&lt;ul&gt;
&lt;li&gt;주기적으로 전송되는 데이터(센서 판단값, 지표)
&lt;ul&gt;
&lt;li&gt;가끔 누락되면 문제가 없다.&lt;/li&gt;
&lt;li&gt;단, 많이 누락되면 정확성이 떨어지고 인식하기 어렵다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이벤트 수가 데이터인 경우
&lt;ul&gt;
&lt;li&gt;누락으로 인해 카운터가 잘못되었다는 것을 의미하기에 신뢰성이 떨어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;생산자에서-소비자로-메시지를-직접-전달하기&#34;&gt;생산자에서 소비자로 메시지를 직접 전달하기&lt;/h4&gt;
&lt;p&gt;중간 노드를 통하지 않고, 생산자와 소비자를 네트워크로 직접 통신&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP 멀티캐스트
&lt;ul&gt;
&lt;li&gt;낮은 지연이 필수인 주식 시장과 같은 금융 산업에서 널리 사용된다.&lt;/li&gt;
&lt;li&gt;UDP 자체는 신뢰성이 낮아도 애플리케이션 단의 프로토콜은 읽어버린 패킷을 복구 할 수 있다.
&lt;ul&gt;
&lt;li&gt;생성자는 필요할 때 패킷을 재전송할 수 있게 전송한 패킷을 기억해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ZeroMQ, 나노메시지(nanomsg)
&lt;ul&gt;
&lt;li&gt;유사한 접근법 사용한다.
&lt;ul&gt;
&lt;li&gt;TCP 또는 IP 멀티캐스트 상에서 발행/구독 메시징을 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zeromq.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ZeroMQ&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;분산/동시성 애플리케이션에 사용하도록 개발된 고성능 비동기 메시지 라이브러리이다.&lt;/li&gt;
&lt;li&gt;메시지 큐를 제공하지만 메시지 지향 미들웨어와 달리 메시지 브로커 없이 동작 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://nanomsg.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;나노메시지(nanomsg)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;일반적인 통신 패턴을 제공하는 소켓 라이브러리이다.&lt;/li&gt;
&lt;li&gt;네트워크 계층에 빠르고 확장 가능하며 사용하기 쉽게 만드는 것을 목표로 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;StatsD, BruBeck
&lt;ul&gt;
&lt;li&gt;네트워크 상의 모든 장비로부터 지표를 수집하고 모니터링하는데 UDP 메시징을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소비자가 네트워크 서비스를 노출하면 생산자는 직접 HTTP나 RPC 요청&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;직접 메시징 시스템의 한계&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지가 유실 될 수 있는 가능성을 고려하여 애플리케이션 코드를 작성해야 한다.&lt;/li&gt;
&lt;li&gt;소비자가 오프라인이라면 메시지를 전달하지 못하는 상태에서 있는 동안 전송된 메시지는 잃어 버릴 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-브로커&#34;&gt;메시지 브로커&lt;/h4&gt;
&lt;p&gt;메시지 브로커(메시지 큐)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;직접 메시징 시스템의 대안으로 메시지 브로커를 통해 메시지를 보내는 방법이 있다.&lt;/li&gt;
&lt;li&gt;메시지 스트림을 처리하는데 최적화된 데이터베이스의 일종이다.&lt;/li&gt;
&lt;li&gt;메시지 브로커는 서버로 구동되고, 생성자와 서비자는 서버의 클라이언트로 접속한다.
&lt;ul&gt;
&lt;li&gt;생성자는 브로커로 메세지 전송한다.&lt;/li&gt;
&lt;li&gt;소비자는 브로커에서 메세지를 읽어 전송받는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_message-broker.png&#34; alt=&#34;Message broker&#34;&gt;&lt;/p&gt;
&lt;p&gt;메세지 브로커의 이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트의 상태 변경(접속, 접속 해제, 장애)에 쉽게 대처할 수 있다.&lt;/li&gt;
&lt;li&gt;브로커가 장애로 중단됐을 때도 메시지를 디스크에 기록하게 되면 유실되지 않는다.
&lt;ul&gt;
&lt;li&gt;메모리에만 메시지를 보관하는 브로커는 유실될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;소비 속도가 느리면 브러커는 큐에 제한 없이 계속 늘어나게 한다.
&lt;ul&gt;
&lt;li&gt;메시지를 버리거나 배압을 하지 않는다. 다만, 이는 설정으로 변경할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;큐에 대기하게 되면 소비자는 비동기로 동작&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자는 메시지를 브로커에 보내면 해당 메시지는 버퍼에 쌓이게 되고, 소비가 될 때까지 기다리지 않는다.&lt;/li&gt;
&lt;li&gt;소비자는 메시지를 바로 소비할도 있지만, 늦게 소비할 수도 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-브로커와-데이터베이스-비교&#34;&gt;메시지 브로커와 데이터베이스 비교&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터 보관
&lt;ul&gt;
&lt;li&gt;데이터베이스 : 데이터가 삭제될 때까지 보관&lt;/li&gt;
&lt;li&gt;메시지 브로커 : 소비자에게 데이터가 전달되면 자동으로 삭제&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 크기
&lt;ul&gt;
&lt;li&gt;메시지 브로커: 대부분의 메시지 빨리 지우기 때문에 작업 집합이 상당히 작다고 가정한다.
&lt;ul&gt;
&lt;li&gt;소비자가 많은 메시지를 버퍼링해야 한다면 처리량이 저하된다.&lt;/li&gt;
&lt;li&gt;작업 집합이란? 현재 실제 메모리에 상주하는 프로세스의 가상 주소 공간을 있는 페이지 집합이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 검색
&lt;ul&gt;
&lt;li&gt;데이터베이스 : 색인 등 다양한 검색 방법을 지원&lt;/li&gt;
&lt;li&gt;메시지 브로커 : 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식 지원&lt;/li&gt;
&lt;li&gt;메커니즘을 다르지만 둘 다 본질적으로 클라이언트가 데이터에서 필요한 부분만 선택하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 질의
&lt;ul&gt;
&lt;li&gt;데이터베이스 : 질의할 때 그 결과는 질의 시점의 데이터 스냅숏을 기준으로 한다.
&lt;ul&gt;
&lt;li&gt;데이터 변경되면 다시 질의하거나 풀링하지 않으면 변경되었다는 것을 알 수가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메시지 브로커 : 임의 질의를 지원하지 않지만, 변경되면 클라이언트에게 알려 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이것은 메시지 브로커의 전통적인 관점으로 JMS, AMQP 같은 표준으로 캡슐화 되어 다음과 같은 소프트웨어로 구현되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RabitMQ, ActivceMQ, 큐피드(Qpid), 호빗Q(HornetQ), TIBCO Enterprice Message Service, IBM MQ, Azure Service Bus, 구글 클라우드 Pub/Sub&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JMS(Java Message Service)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java EE에서 기반한 애플리케이션 구성요서에서 메시지를 작성, 전송, 수신하고 읽을 수 있도록 하는 API이다.&lt;/li&gt;
&lt;li&gt;서버 구성을 통해 큐, 주제, 연결, 기타 자원을 작성 및 관리하는 관리 모드로 실행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AMQP(Advanced Message Queuing Protocal)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메시지지향 미들웨어를 위한 개방형 표준 응용 계층 프로토콜이다.&lt;/li&gt;
&lt;li&gt;메시지지향, 큐잉, 라우팅(P2P 및 발행-구독), 신뢰성, 보안 기능이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;복수-소비자&#34;&gt;복수 소비자&lt;/h4&gt;
&lt;p&gt;여러 소비자가 같은 토픽에서 메시지를 읽을 때 사용하는 주요 패턴 2가지&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로드 밸런싱
&lt;ul&gt;
&lt;li&gt;각 메시지는 소비자 중 하나로 전달된다.&lt;/li&gt;
&lt;li&gt;브로커는 메시지를 전달할 소비자를 임의로 지정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;팬 아웃(fan-out)
&lt;ul&gt;
&lt;li&gt;각 메시지는 모든 소비자에게 전달된다.&lt;/li&gt;
&lt;li&gt;여러 독립적인 소비자가 브로드캐스팅된 동일한 메시지를 서로 간섭 없이 전달 받을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-1.png&#34; alt=&#34;그림 11-1&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-1. (a) 로드 밸런싱: 여러 소비자가 하나의 토픽을 소비하는 작업을 공유 (b) 팬 아웃: 각 메시지를 복수 개의 소비자로 전달&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;Fan In, Fan Out&lt;/div&gt;


팬 아웃(영어: fan out)은 논리 회로에서 하나의 논리 게이트의 출력이 얼마나 많은 논리 게이트의 입력으로 사용되는지에 대해 서술할 때에 쓰인다. (출처: 위키 백과)

Fan In : 자신을 사용하는 모듈의 수 (A:0, B:1, C:1, D:1, E: 1, F:2, G:1, H:2, I:1, J:1)  
Fan Out: 자신이 호출하는 모듈의 수(A:3, B:2, C:2, D:1, E:1, F:1, G:1, H:0, I:0, J:0)

![프로그램의 계층적 구조](/docs/data-intensive-application/11_hierarchical.png)  
*프로그램의 계층적 구조*

출처: https://ehclub.co.kr/1851 [언제나 휴일]
&lt;/div&gt;

&lt;p&gt;이 두가지 패턴을 함께 사용 가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;두 개의 소비자 그룹에서 하나의 토픽을 구독한다.&lt;/li&gt;
&lt;li&gt;각 그룹은 모든 메시지를 받지만, 그룹 내에서는 각 메시지를 하나의 노드만 받게 하는 식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_publisher-subscriber.png&#34; alt=&#34;발행과 구독&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;확인-응답과-재전송&#34;&gt;확인 응답과 재전송&lt;/h4&gt;
&lt;p&gt;소비자 장애&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브로커가 메시지를 소비자에게 전달을 했지만, 처리하지 못하거나 부분적으로만 처리 후에 장애가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;이럴 때는 메시지가 유실 될 수 있기 때문에 브로커는 확인 응답을 사용한다.&lt;/li&gt;
&lt;li&gt;클라이언트는 메시지 처리가 끝났을 때, 브로커에게 명시적으로 알려주고 브로커는 해당 메시지를 제거한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;확인 응답이 안되면&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;확인 응답을 받지 전에 클라이언트가 연결이 되지 않거나, 타임아웃이 발생하면 브로커는 처리가 되지 않았다고 간주하고 다른 소비자에게 다시 전송한다.&lt;/li&gt;
&lt;li&gt;메시지 처리가 되었는데도 불가하고 확인 응답 되지 않았다면, 원자적 커밋 프로세스가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;&lt;div class=&#34;h4 alert-heading&#34; role=&#34;heading&#34;&gt;원자적 커밋(atomic commit)이란?&lt;/div&gt;


원자적 커밋(atomic commit)은 구별되는 여러 변경사항들을 하나의 운용 단위로 적용하는 것이다. 변경사항이 적용되면 원자적 커밋은 성공하였다고 이야기된다. 원자적 커밋이 끝나기 전에 실패한 것이 하나라도 있다면 원자적 커밋에서 완수되는 모든 변경사항들이 되돌려진다. 
&lt;/div&gt;

&lt;p&gt;부하 균형 분산과 결합할 때 이런 재전송 행위는 메시지 순서에 영향을 미친다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소비자1이 m4를 처리하고 있을 때, 소비자2가 m3를 처리할 시에 장애 발생한다.&lt;/li&gt;
&lt;li&gt;m3의 확인 응답을 받지 못해 소비자1로 재전송하게 된다.&lt;/li&gt;
&lt;li&gt;소비자1은 m4, m3, m5순으로 메시지를 처리하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-2.png&#34; alt=&#34;그림 11-2&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-2. 소비자 2가 m2을 처리하던 도중 장애가 발생해서 이후 m3을 소비자 1로 재전송한다&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;메시지 브로커는 순서를 유지하려고 노력하더라도 이렇게 변경될 수도 있다.&lt;br&gt;
부하 균형 분산 기능을 사용하지 않는다면 이 문제를 피할할 수 잇다.&lt;br&gt;
메시지 간에 인관성이 있다면 순서는 중요하다. (이 문제는 후반부에서 다룬다.)&lt;/p&gt;
&lt;h3 id=&#34;파티션닝된-로그&#34;&gt;파티션닝된 로그&lt;/h3&gt;
&lt;p&gt;기록을 남지지 않는 메시지 브로커&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;패킷을 전송하거나 서비스에 요청하는 작업은 보통 영구적 추적을 남기지 않는 일시적 연산이다.&lt;/li&gt;
&lt;li&gt;메시지 브로커도 디스크에 지속성 있기 기록을 하지만, &lt;strong&gt;소비자가 전달될 후 즉시 삭제한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;메시지 브로커는 일시적 보관 개념으로 만들어 졌다.&lt;/li&gt;
&lt;li&gt;메시지 브로커는 메시지가 전달을 하게 되면, 확인 응답을 받고 삭제한다. 이는 &lt;strong&gt;복구되지 않는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기록하는 데이터 베이스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스나 파일에 저장하는 모든 데이터는 누군가 삭제하지 않으면 영구적으로 보관된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스의 지속성 있는 저장 방법과 메시징 시스템 지연 시간이 짧은 알림 기능의 조합이 &lt;strong&gt;로그 기반 메시지 브로커(log-based message broker)&lt;/strong&gt; 이다.&lt;/p&gt;
&lt;h4 id=&#34;로그를-사용한-메시지-저장소&#34;&gt;로그를 사용한 메시지 저장소&lt;/h4&gt;
&lt;p&gt;로그란?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단순히 디스크에 저장된 추가 전용 레코드의 연속이다.&lt;/li&gt;
&lt;li&gt;로그 구조화 저장 엔진과 쓰기 전 로그, 복제본의 로그와 같은 맥락&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;브로커에서 로그는?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;생산자가 보낸 메시지는 로그 끝에 추가한다.&lt;/li&gt;
&lt;li&gt;소비자는 로그를 순차적으로 읽어 메시지를 받는다. 로그 끝에 도달하면 새 메시지가 추가됐다는 알림을 기다린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 파티셔닝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;디스크 하나를 쓸 때보다 로그 처리량을 높이기 위해 파티셔닝을 하는 방법이다.&lt;/li&gt;
&lt;li&gt;다른 피티션은 다른 장비에서 서비스할 수 있다.
&lt;ul&gt;
&lt;li&gt;각 파티션은 다른 파티션과 독립적으로 읽고 쓰기가 가능한 로그가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;오프셋(offset)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;각 파티션 내에서 브로커는 모든 메시지에 단순히 증가하는 순번인 오프셋을 부여한다.&lt;/li&gt;
&lt;li&gt;다른 파티션 간 메시지의 순서는 보장하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-3.png&#34; alt=&#34;그림 11-3&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-3. 생산자가 메시지를 전송하면 메시지는 토픽 파티션 파일에 추가된다. 그러면 소비자는 순서대로 파티션 파일을 읽는다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;이 방식은&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;아파치 카프카, 아마존 키네스티 시스템, 트위터의 분산 로그가 이런 방식으로 동작하는 로그 기반 메시지 브로커이다.&lt;/li&gt;
&lt;li&gt;구글 클라우드 Pub/Sub은 비슷하지만, 다른 방식이다. (JMS 형식)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 기반 메시지 브로커의 이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;초당 수백만 개의 메시지를 처리할 수 있다.&lt;/li&gt;
&lt;li&gt;메시지를 복제함으로써 장애에 대비할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;로그-방식과-전통적인-메시지-방식의-비교&#34;&gt;로그 방식과 전통적인 메시지 방식의 비교&lt;/h4&gt;
&lt;p&gt;로그 기반 접근법&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;팬 아웃 메시징 방식을 제공한다.&lt;/li&gt;
&lt;li&gt;소비자가 서로 영향 없이 독립적으로 로그를 읽을 수 있고, 메시지를 읽어도 로그에서 삭제되지 않는다.&lt;/li&gt;
&lt;li&gt;개별 메시지를 소비자 클라이언트에 할당하지 않고, 소비자 그룹 간 로드 밸런싱한다.
&lt;ul&gt;
&lt;li&gt;브로커는 소비자 그룹의 노드들에 전체 파티션을 할당할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 기반 접근법의 장단점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;메시지 처리 속도가 빠르다.&lt;/li&gt;
&lt;li&gt;메시지 순서가 중요하다면 효과적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;메시지 처리 비용이 비싸다.&lt;/li&gt;
&lt;li&gt;메시지 순서가 중요하지 않다면 JMS/AMQP 방식의 메시지 브로커가 더 적합하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;소비자-오프셋&#34;&gt;소비자 오프셋&lt;/h4&gt;
&lt;p&gt;오프셋의 이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파티션 하나를 순서대로 처리하면 메시지를 어디까지 처리했는지 알기 쉽다.&lt;/li&gt;
&lt;li&gt;메시지마다 보내는 확인 응답을 추적할 필요가 없다.&lt;/li&gt;
&lt;li&gt;추척 오버헤드가 감소하고 일괄 처리와 파이프라이닝을 수행 할 수 있는 기회를 제공하여 처리량을 늘리는데 도움을 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스와 유사점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 데이터베이스 복제에서 널리 쓰이는 로그 순차 번호와 상당히 유사하다.&lt;/li&gt;
&lt;li&gt;데이터베이스 복제에서 팔로워가 리더와 연결이 끊어졌다가 다시 접속할 때, 로그 순자 번호를 사용한다.&lt;/li&gt;
&lt;li&gt;로그 순차 번호를 사용하면 기록을 누락하지 않고 복제를 재개할 수 있다.&lt;/li&gt;
&lt;li&gt;메시지 브로커는 데이터베이스의 리더처럼 동작하고, 소비자는 팔로워처럼 동작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;소비자 노드 장애 발생시 문제점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소비자 노드가 장애가 발생하면 그룹내 다른 노드가 오프셋부터 메시지를 처리한다.&lt;/li&gt;
&lt;li&gt;장애가 발생한 소비자가 처리하였지만, 오프셋이 기록되지 않았다면 두번 처리하게 된다. (이 문제는 후반부에서 다룬다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;디스크-공간-사용&#34;&gt;디스크 공간 사용&lt;/h4&gt;
&lt;p&gt;로그가 점차 쌓이게 되면, 결국 디스크를 전부 사용하게 된다.&lt;br&gt;
디스크를 재사용하기 위해서는 로그를 여러 조각으로 나누고 오래된 조각은 삭제하거나 보관 저장소로 이동한다.&lt;/p&gt;
&lt;p&gt;소비자 처리 속도가 느려 생산되는 속도를 따라 잡지 못하면 소비자의 오프셋은 이미 삭제한 조각을 가리킬 수 있다. 즉, 메시지 일부를 잃어버릴 가능성 있다는 뜻이다.&lt;br&gt;
로그는 크기가 제한 된 버퍼로 구현하고 오래된 메시지는 순서대로 버린다. 이를 원형 버퍼(circuler buffer), 링 버퍼(ring buffer)라고 한다.&lt;/p&gt;
&lt;h4 id=&#34;소비자가-생성자를-따라갈-수-없을-때&#34;&gt;소비자가 생성자를 따라갈 수 없을 때&lt;/h4&gt;
&lt;p&gt;소비자가 로그의 헤드로부터 얼마나 떨어졌는지 모니터링하면 눈에 띄게 뒤쳐지는 경우에는 이를 경고를 한다.&lt;br&gt;
운영자는 소비자 처리가 느린 문제를 고쳐 메시지를 잃기 전에 따라 잡을 시간을 충분히 벌 수 있다.&lt;/p&gt;
&lt;p&gt;어떤 소비자가 너무 뒤쳐져서 메시지를 읽기 시작해도 해당 소비자만 영향을 받고 다른 소비들의 서비스를 망치지는 않는다.&lt;/p&gt;
&lt;h3 id=&#34;오래된-메시지-재생&#34;&gt;오래된 메시지 재생&lt;/h3&gt;
&lt;p&gt;메시지 브로커 비교&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AMQP, JMS 유형의 메시지 브로커
&lt;ul&gt;
&lt;li&gt;메시지를 처리하고 확인 응답하는 작업은 브로커에서 메시지를 제거하기 때문에 파괴 연산을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;로그 기반 메시지 브로커
&lt;ul&gt;
&lt;li&gt;메시지를 소비하는게 오히려 파일을 읽는 작업과 더 유사한데 로그를 변화시키지 않는 읽기 전용 연산을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 기반의 이점&lt;br&gt;
메시지 재처리는 몇번이든지 처리 코드를 변경해 재처리가 가능하다.&lt;/p&gt;
&lt;h2 id=&#34;데이터베이스와-스트림&#34;&gt;데이터베이스와 스트림&lt;/h2&gt;
&lt;p&gt;메시지 브로커 데이터베이스의 관계&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;로그 기반 브로커는 데이터베이스에서 아이디어를 얻어, 메시징에 적용하는데 성공&lt;/li&gt;
&lt;li&gt;로그 기반 브로커의 메시징 스트림에서 아이디어를 얻어 데이터베이스에 적용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;시스템-동기화-유지하기&#34;&gt;시스템 동기화 유지하기&lt;/h3&gt;
&lt;p&gt;이중 기록(dual write)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주기적으로 데이터베이스 전체를 덤프하는 작업이 너무 느리면 대안으로 사용하는 방법&lt;/li&gt;
&lt;li&gt;이중 기록을 사용하면 데이터가 변할 때마다 애플리케이션 코드에서 명시적으로 각 시스템에 기록
&lt;ul&gt;
&lt;li&gt;데이터베이스에 기록&lt;/li&gt;
&lt;li&gt;검색 색인을 갱신&lt;/li&gt;
&lt;li&gt;캐시 엔트리 무효화&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이중 기록의 심각한 문제&lt;br&gt;
각 클라이언트가 동시에 아이템 X를 업데이트하려고 할때, 타이밍 문제로 데이터가 맞지 않게 될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-4.png&#34; alt=&#34;그림 11-4&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-4. 데이터베이스에서 X를 먼저 A로 설정했다가 B로 바꿨다. 반면 색인에는 쓰기 요청이 반대 순서로 도착했다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동시성 문제
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;동시 쓰기 감지&amp;quot;에서 설명한 버전 벡터와 같은 동시성 감지 매커니즘을 따로 사용하지 않으면 동시에 쓰기 발생해도 알아 차리지 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;내결함성 문제
&lt;ul&gt;
&lt;li&gt;한쪽 쓰기가 성공할 때 다른 쪽 쓰기는 실패할 수 있다.&lt;/li&gt;
&lt;li&gt;두 시스템 간에 불일치가 발생하는 현상이 발생한다.&lt;/li&gt;
&lt;li&gt;동시성 또는 동시 실패 보장하는 방식은 원자적 커밋 문제다.
11- 이 문제를 해결하는 데는 비용이 많이 든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;각 시스템의 단일 리더&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;단일 리더 복제 데이터베이스 하나를 사용한다면 리더가 쓰기 순서를 결정한다.&lt;/li&gt;
&lt;li&gt;각각 데이터베이스, 검색 색인에 리더를 만들어도 충돌 발생이 여지가 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;시스템의 통합 리더&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;색인용 인덱스를 데이터베이스의 팔로워로 만들어 실제 리더를 하나만 존재하게 하면 훨씬 낫다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;변경-데이터-캡처&#34;&gt;변경 데이터 캡처&lt;/h3&gt;
&lt;p&gt;예전 데이터베이스&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 복제 내용을 가져오려면 데이터 모델과 질의 언어를 통해서 데이터베이스에 직접 질의한다.
&lt;ul&gt;
&lt;li&gt;데이터 내부 상세 구현으로 생각되어 공개 API 자체를 제공하지 않았다.&lt;/li&gt;
&lt;li&gt;복제 로그를 파싱해서 데이터를 추출하는 방식을 사용하지 못하였다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터 베이스에서 발생하는 데이터 변화를 감지해서 변경된 내용을 다른 저장소에 복제하는데 어려움이 있었다.
&lt;ul&gt;
&lt;li&gt;저장소) 검색 색인, 캐시, 데이터 웨어하우스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;변경 데이터 캡처(change data capture, CDC)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에 기록하는 모든 데이터의 변화를 관찰해 다른 시스템으로 데이터를 복제할 수 있다는 추출 과정이다.
&lt;ul&gt;
&lt;li&gt;데이터가 기록되자마자 변경 내용을 스트림으로 제공에 유용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;데이터베이스의 변경 사항을 캡처해 같은 변경 사항을 검색 색인에 꾸준히 반영할 수 있다.
&lt;ul&gt;
&lt;li&gt;같은 순서로 로그 변경이 반영된다면 데이터베이스의 데이터와 색인이 일치할 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-5.png&#34; alt=&#34;그림 11-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-5. 데이터베이스에 쓰여진 순서대로 데이터를 가져와 다른 시스템에 변경 사항을 같은 순서로 적용한다.&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;변경-데이터-캡처의-구현&#34;&gt;변경 데이터 캡처의 구현&lt;/h4&gt;
&lt;p&gt;파생 테이터 시스템&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;검색 색인과 데이터 웨어하우스에 저장된 데이터는 레코드 시스템에 저장된 데이터의 또 다른 뷰일 뿐이므로 로그 소비자이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;변경 데이터 캡처&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;파생 데이터 시스템이 레코드 시스템의 정확한 데이터 복제본을 가지게 하기 위해 레코드 시스템에 발생하는 모든 변경 사항을 파생 데이터 시스템에 반영하는 것을 보장하는 메커니즘이다.&lt;/li&gt;
&lt;li&gt;본질적으로 변경 사항을 캡처할 데이터베이스 하나를 리더로 하고 나머지를 팔로워로 한다.&lt;/li&gt;
&lt;li&gt;로그 기반 메시지 브로커는 원본 데이터베이스에서 변경 이벤트를 전송하기에 적합하다.
&lt;ul&gt;
&lt;li&gt;메시지를 순서를 유자하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;변경 데이터 캡처의 구현&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 트리거를 사용하는 방식
&lt;ul&gt;
&lt;li&gt;데이터 테이블의 모든 변화를 관찰하는 트리거를 등록하고 변경 로그 테이블에 해당 항목 추가하는 방식이다.&lt;/li&gt;
&lt;li&gt;단점으로, 고장 나기 쉽고 선능 오버헤드가 상당하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;복제 로그를 방식하는 방식
&lt;ul&gt;
&lt;li&gt;단점으로 스키마 변경 대응 등 해결해야 할 문제 있다.&lt;/li&gt;
&lt;li&gt;트리거 방식보다 견고한 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;변경 데이터 캡처의 종류&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PostgreSQL용 CDC
&lt;ul&gt;
&lt;li&gt;보틀드 워터(Bottled Water)는 쓰기 전 로그를 복호화하는 API를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MySQL용 CDC
&lt;ul&gt;
&lt;li&gt;맥스웰(Maxwell), 디비지움(Debezium)은 binlog를 파싱 방식으로 구현한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MongoDB용 CDC
&lt;ul&gt;
&lt;li&gt;몽고리버(Mongoriver)는 oplog를 읽는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;오라클용 CDC
&lt;ul&gt;
&lt;li&gt;골드게이트(GoldenGate)도 oplog를 읽는것과 비슷하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;변경 데이터 캡처의 동작&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;비동기 방식으로 동작한다.&lt;/li&gt;
&lt;li&gt;장점
&lt;ul&gt;
&lt;li&gt;데이터베이스는 변경 사항을 커밋하기 전에 변경 사항이 소비자에게 적용될 때가지 기다리지 않는다.&lt;/li&gt;
&lt;li&gt;느린 소비자가 추가되어도 시스템에 미치는 영향이 적다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;단점
&lt;ul&gt;
&lt;li&gt;복제 지연의 모든 문제가 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;초기-스냅숏&#34;&gt;초기 스냅숏&lt;/h4&gt;
&lt;p&gt;데이터베이스 변경 로그&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스에서 발생한 모든 변경 로그가 있다면 로그를 재현해서 데이터베이스의 전체 상태를 재구축할 수 있다.&lt;/li&gt;
&lt;li&gt;모든 변경 사항을 영구적으로 보관하기에는 디스크 공간이 많이 필요하다.&lt;/li&gt;
&lt;li&gt;모든 로그를 재생하는 작업도 너무 오래 걸린다.&lt;/li&gt;
&lt;li&gt;그래서 로그를 적당히 잘아야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스냅숏의 필요성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;전문 색인을 새로 구축할 때를 예로 들면 전체 데이터베이스 복사본이 필요하다.&lt;/li&gt;
&lt;li&gt;최근한 갱신하지 않은 항목은 로그에 없기 땜누에 최근 변경 사항만 반영하는 것으로는 충분하지 않다.&lt;/li&gt;
&lt;li&gt;이때 일관성 있는 스냅숏을 사용해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;스냅숏의 기능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변경 로그의 위치나 오프셋에 대응돼야 한다.&lt;/li&gt;
&lt;li&gt;그래야 스냅숏 이후에 변경 사항을 적용할 시점을 알 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;로그-컴팩션&#34;&gt;로그 컴팩션&lt;/h4&gt;
&lt;p&gt;로그 히스토리의 양을 제한한다면 새로운 파생 데이터 시스템을 추가할 때마다 스냅숏을 만들어야 한다.&lt;/p&gt;
&lt;p&gt;로그 컴팩션 동작 원리&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;저장 엔진은 주기적으로 같은 키의 로그 레코드를 찾아 중복 제거한다.&lt;/li&gt;
&lt;li&gt;각 키에 대한 가장 최근에 갱신된 내용만 유지한다.&lt;/li&gt;
&lt;li&gt;컴팩션 병합 과정은 백그라운드로 실행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;톰스톰(tombstone, 묘비)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키의 삭제를 의미하고, 컴팩션을 수행할 때 실제로 값을 제거한다.&lt;/li&gt;
&lt;li&gt;키를 덮어쓰거나 삭제하지 않는 한 영구적으로 유지한다.&lt;/li&gt;
&lt;li&gt;현재 데이터베이스에 있는 최신 값이 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;로그 기반 메시지 브로커&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDC 시스템에서 모든 변경에 기본키가 포함되게 하고&lt;/li&gt;
&lt;li&gt;키의 모든 갱신이 해당 키의 이전 값을 교체한다면 특정 키에 대한 최신 쓰기만 유지하면 충분하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;변경-스트림용-api-지원&#34;&gt;변경 스트림용 API 지원&lt;/h4&gt;
&lt;p&gt;변경 스트림 인터페이스 제공하기 시작&amp;hellip;.리버스 엔지니어링 이런거 안함&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리싱크DB(RethinkDB)
&lt;ul&gt;
&lt;li&gt;질의 결과에 변경이 있을 때 알림을 받을 수 있게 구독이 가능한 절의를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;파이어베이스(FireBase)와 카우치DB(CouchDB)
&lt;ul&gt;
&lt;li&gt;애플리케이션에도 사용 가능한 변경 피드 기반의 데이터 동기화를 지원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;미티어(Meteor)
&lt;ul&gt;
&lt;li&gt;몽고DB의 oplog를 사용해 데이터 변경사항을 구독하거나 사용자 인터페이스를 갱신&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;볼트DB(VoltDB)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;스트림 형태로 데이터베이스에세 데이터를 지속적으로 내보내는 트랜잭션을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;카프카 커넥트(Kafka Connect)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;카프카를 광범위한 데이터 시스템용 변경 데이터 캡처 도구로 활용하기 위한 노력의 일환이다.&lt;/li&gt;
&lt;li&gt;변경 이벤트를 스트림하는데 카프카를 사용하면 검색 색인과 같은 파생 데이터 시스템을 갱신하는데 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;이벤트-소싱&#34;&gt;이벤트 소싱&lt;/h3&gt;
&lt;p&gt;이벤트 소싱(event sourcing)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;도메인 주도 설계(domain-driven design, DDD) 커뮤니티에서 개발한 기법이다.&lt;/li&gt;
&lt;li&gt;애플리케이션 상태 변화를 모두 변경 이벤트 로그로 저장한다.
&lt;ul&gt;
&lt;li&gt;변경 데이터 캡처와 유사하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 데이터 캡처와 큰 차이점은 추상화 레벨이 다르다.
&lt;ul&gt;
&lt;li&gt;추상화 레벨이란?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 데이터 캡처와 이벤트 소싱 차이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 데이터 캡처
&lt;ul&gt;
&lt;li&gt;애플리케이션은 데이터베이스를 변경 가능한 방식으로 사용해 레코드를 자유롭게 갱신하고 삭제한다.
&lt;ul&gt;
&lt;li&gt;추가(O) 갱신(O), 삭제(O)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;변경 로그는 데이터베이스에서 추출한 쓰기 순서가 실제로 데이터를 기록한 순서와 일치한다.&lt;/li&gt;
&lt;li&gt;데이터베이스에 기록한 애플리케이션은 CDC가 실행 중인지 알 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이벤트 소싱
&lt;ul&gt;
&lt;li&gt;애플리케이션 로직은 이벤트 로그에 기록된 불변 이벤트를 기반으로 명시적으로 구축한다.이는 단지 추가만 가능하고 갱신이나 삭제는 권장하지 않거나 금지한다는 것의 의미한다.
&lt;ul&gt;
&lt;li&gt;추가(O) 갱신(X), 삭제(X)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이벤트는 저수준에서 상태 변경을 반영하는 것이 아니라 애플리케이션 수준에서 발생한 일을 반영하게끔 설계 됐다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 소싱의 이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 모델링에 쓸 수 있는 강력한 기법이다.&lt;/li&gt;
&lt;li&gt;애플리케이션 관점에서 사용자의 행동을 불변 이벤트로 기록하는 방식&lt;/li&gt;
&lt;li&gt;애플리케이션을 지속해서 개선하기가 매우 유리하다.&lt;/li&gt;
&lt;li&gt;디버깅에 도움이 되고, 애플리케이션 버그를 방지한다.&lt;/li&gt;
&lt;li&gt;이벤트 소싱 접근법을 사용하며 새로 발생한 부수 효과를 기존 이벤트에서 쉽게 분리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;이벤트-로그에서-현재-상태-파생하기&#34;&gt;이벤트 로그에서 현재 상태 파생하기&lt;/h4&gt;
&lt;p&gt;유용하지 않은 이벤트 로그&lt;br&gt;
사용자 시스템의 현재 상태를 보기 원하지, 수정 히스토리를 모두 보고 싶어하지는 않는다.&lt;br&gt;
예를 들면, 쇼핑 사용자는 장바구니의 모든 변경 사항이 아닌 현재 상태만 보고 싶어 한다.&lt;/p&gt;
&lt;p&gt;이벤트 로그 변환 작업&lt;br&gt;
따라서, 시스템에 기록한 데이터를 표현한 이벤트 로그를 가져와 사용자에서 보여주기 &lt;strong&gt;적당히 변화해야 한다.&lt;/strong&gt;
변화 과정은 로직을 자유롭게 사용할 수 있지만, 다시 수행하더라도 이벤트 로그로부터 동일한 애플리케이션 상태를 만들 수 있어야 한다.&lt;/p&gt;
&lt;p&gt;이벤트 로그 컴팩션 불가능&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDC 이벤트
&lt;ul&gt;
&lt;li&gt;기본키의 현재 값은 전적으로 기본키의 가장 최신 이벤트로 결정된다.&lt;/li&gt;
&lt;li&gt;같은 키의 이벤트는 이전 이벤트로 덮어 쓰는것이 가능하기에 로그 캠팩션이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이벤트 소싱
&lt;ul&gt;
&lt;li&gt;마지막 상태를 재구축하기 위해서는 이벤트 전체 히스토리가 필요하다.
&lt;ul&gt;
&lt;li&gt;이벤트는 사용자 행동의 결과로 발생한, 상태 메커니즘이 아닌 사용자 행동 의도를 표현하기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그래서, 로그 컴팩션 불가능 하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 소싱 한계점&lt;br&gt;
이벤트 로그 기반의 현재 상태의 스냅숏을 저장하는 매커니즘이 있기에, 매번 전체 로그를 재처리할 필요는 없다.&lt;br&gt;
그러나, 이는 장애 발생 시 읽고 복구하는 선능을 높여주는 최적화가 불과하다.&lt;br&gt;
이벤트 소싱 시스템은 모든 원시 이벤트를 영원히 저장하고 필요할 때마다 모든 이벤트를 재처리 할 수 있어야 한다.&lt;/p&gt;
&lt;h4 id=&#34;명령과-이벤트&#34;&gt;명령과 이벤트&lt;/h4&gt;
&lt;p&gt;명령(command)이란?&lt;br&gt;
사용자 요청이 처음 도착했을 때 이 요청은 명령이다. 특정 무결성 조건을 위반하면 실패한다.&lt;br&gt;
무결성이 검증되고 명령이 승인 되면 지속성 있는 불변 이벤트가 된다.&lt;/p&gt;
&lt;p&gt;이벤트 불변
이벤트가 한번 생성되면 사실(fact)가 된다.&lt;br&gt;
다시 변경 및 취소가 되었더라고 기존 정보는 여전히 사실로 남아 있으며, 다시 변경 및 취소는 나중에 추가된 독립적인 이벤트가 된다.&lt;/p&gt;
&lt;p&gt;이벤트 스트림 소비자
소비자는 이벤트를 거절 못한다. 이벤트를 받은 시점에는 이벤트는 이미 불변 로그의 일부분이다.
명령 유효성은 이벤트가 되기 전에 동식으로 검증해야 한다.
이를테면 직렬성 트랜잭션을 사용해 원자적으로 명령을 검증하고 이벤트를 발행 할 수 있다.&lt;/p&gt;
&lt;p&gt;사용자 요청 이벤트 두개로 분할하면 비동기 처리를 유효성 검사를 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;예를 들면,
&lt;ul&gt;
&lt;li&gt;사전 예약(가예약)&lt;/li&gt;
&lt;li&gt;예약 확정(유효한 예약)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;상태와-스트림-그리고-불변성&#34;&gt;상태와 스트림 그리고 불변성&lt;/h3&gt;
&lt;p&gt;입력 파일의 불변성이 주는 이점&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;입력 파일에 손상을 주지 않고 기존 입력 파일에 얼마든지 실험적 처리 작업을 수행할 수 있다.&lt;/li&gt;
&lt;li&gt;불변성 원리가 이벤트 소싱과 변경 데이터 캡처를 매우 강력하게 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;불변-이벤트의-장점&#34;&gt;불변 이벤트의 장점&lt;/h4&gt;
&lt;p&gt;회계 장부&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;거래(트랜잭션)가 발생하면 거래 정보를 원장(ledger)에 추가만 하는 방식으로 기록한다.
&lt;ul&gt;
&lt;li&gt;원장은 본질적으로 돈, 상품, 서비스를 교환 정보를 설명한 이벤트 로그다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;실수가 발생해도 원장의 잘못된 거래 내역을 지우거나 고치지 않고, 영원이 남는다.
&lt;ul&gt;
&lt;li&gt;틀린 원장으로부터 만든 수치가 이미 발표됐다면, 다음 회계 기간에 수정한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이는 회계 감사에 중요한 사유가 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;버그로 인해 잘못된 데이터가 발생했을 때,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 : 잘못된 데이터를 기록되었다면, 복구가 매무 어렵다.&lt;/li&gt;
&lt;li&gt;불변 이벤트 로그 : 추가만 하는 로그를 썼다면 문제 상황 진단과 복구가 훨씬 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;불변 이벤트를 통한 유용한 정보&lt;br&gt;
쇼핑 웹사이트에서 고객이 장바구니에 항목 하나를 넣었다가 제거 했을 때&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;주문 이행 관점
&lt;ul&gt;
&lt;li&gt;단순 두번째 이벤트(제거)는 단지 첫번 이벤트(추가)를 취소했을 뿐이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;분석가의 관점
&lt;ul&gt;
&lt;li&gt;고객이 나중에 구매하려고 했거나, 대체제를 찾았을 것을 뜻한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이런 유용한 정보는 이벤트 로그에는 기록되지만, 데이터베이스에서는 장바구니에서 항목을 제거 했을 잃어버리는 정보가 된다.&lt;/p&gt;
&lt;h3 id=&#34;동일한-이벤트-로그로-여러-가지-뷰-만들기&#34;&gt;동일한 이벤트 로그로 여러 가지 뷰 만들기&lt;/h3&gt;
&lt;p&gt;불변 이벤트 로그에서 가변 상태로 분리하면, 동일한 이벤트 로그로 여러 읽기 전용 뷰를 만들 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;분석 데이터베이스 드루이드(Druid) : 카프카로부터 직접 데이터를 읽어 처리&lt;/li&gt;
&lt;li&gt;피스타치오(Pistachio) : 분산 키-값 저장소로 카프카를 커밋 로그처럼 사용&lt;/li&gt;
&lt;li&gt;카프카 커넥트 싱크(Kafka Connect Sink): 카프카에서 여러 데이터베이스와 색인에 데이터를 내보낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;기존 데이터를 새로운 방식으로 표현하는 새 기능을 추가하려면 이벤트 로그를 사용해 신규 기능용으로 분리한 읽기 최적화된 뷰를 구축할 수 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존 시스템을 수정할 필요가 없고 기존 시스템과 함께 운용이 가능하다.&lt;/li&gt;
&lt;li&gt;신구 시스템을 나란히 구동하는 것은 기존 시스템에서 복잡한 스키마 이전을 수행하는 것보다 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;명령 질의 책임의 분리(command query responsibility segregation, CQRS)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 어떻게 질의하고 접근하는지 신경 쓰지 않는다면, 데이터 저장은 상당히 직관적인 작업이다.&lt;/li&gt;
&lt;li&gt;데이터를 쓰는 형식, 읽는 형식을 분리해 다양한 읽기 뷰를 혀용한다면 상당한 유연성을 얻을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_cqrs&#34; alt=&#34;CQRS&#34;&gt;&lt;/p&gt;
&lt;p&gt;기존 아키텍쳐에서 점차 CQRS 패턴이 구현되는 모습. 마지막 단계에서 RDBMS와 NoSQL 간 데이터 이동은 Kafka와 같은 메시지 큐가 적용될 수 있다.&lt;/p&gt;
&lt;p&gt;읽기 최적화된 뷰의 비정규화&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스와 스키마 설계의 전통적인 접근법은 데이터를 질의 받게 될 형식과 같은 형식으로 데이터를 기록해야 한다는 잘못된 생각에 기초한다.&lt;/li&gt;
&lt;li&gt;데이터를 쓰기 최적화된 이벤트 로그에서 읽기 최적화된 애플리케이션 상태로 전환 가능하면 정규화와 비정규화에 관한 논쟁은 의미 없다.&lt;/li&gt;
&lt;li&gt;읽기 최적화된 뷰는 데이터를 비정규화하는 것이 전적으로 합리적이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;동시성-제어&#34;&gt;동시성 제어&lt;/h4&gt;
&lt;p&gt;이벤트 소싱과 변경 데이터 캡처의 가장 큰 단점은 이벤트 로그의 소비가 대개 비동기로 이뤄진다는 점이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사용자가 로그에 이벤트를 기록하고, 이어서 파생된 뷰를 읽어도 기록한 이벤트가 뷰에 반영되지 않았을 가능성이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;해결책으로 하나는 읽기 뷰의 갱신과 로그에 이벤트를 추가하는 작업을 동기식으로 수행하는 방법이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이 방법을 쓰려면 트랜잭션에서 여러 쓰기를 원자적 단위로 결합해야 하므로 이벤트 로그와 읽기 뷰를 같은 저장 시스템에 담아야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반면 이벤트 로그를 현재 상태로 만들면 동시성 제어 측면이 단순해진다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;다중 객체 트랜잭션은 단일 사용자 동작이 여러 다른 장소의 데이터를 변경해야 할 때 필요하다.&lt;/li&gt;
&lt;li&gt;그러면 사용자 동작은 한 장소에서 한 번 쓰기만 필요하다. 즉, 이벤트를 로그에 추가만 하면 되며 원자적으로 만들기 쉽다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 로그와 상태를 같은 방식으로 파티셔닝하면, 간단한 단일 스레드 로그 소비자는 쓰기용 동시성 제어는 필요하지 않다.&lt;/p&gt;
&lt;h4 id=&#34;불변성의-한계&#34;&gt;불변성의 한계&lt;/h4&gt;
&lt;p&gt;데이터 유지는 어디 정도까지 가능할까?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터 셋이 뒤틀리는 양에 따라 다르다.&lt;/li&gt;
&lt;li&gt;매우 비번히 갱신과 삭제를 하는 작업부하는 불변 히스토리가 감당하기 힘들 정도로 커지거나 파편화 문제가 발생할 수도 있다.&lt;/li&gt;
&lt;li&gt;컴팩션과 가비지 컬렉션의 선능 문제가 견고한 운영을 하는데 큰 골치거리가 되기도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터 삭제해야 할 경우가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;선능적인 이유로 데이터를 삭제해야 하는 경우가 있다.&lt;/li&gt;
&lt;li&gt;개인 정보 및 민감한 정보를 삭제해야 하는 경우도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터를 진짜로 삭제하는 작업은 어렵다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;많은 곳에 복제본이 남아 있기 때문이다.&lt;/li&gt;
&lt;li&gt;삭제는 해당 데티러를 &amp;ldquo;찾기 불가능하게끔&amp;quot;하는 문제라기보다는 &amp;ldquo;찾기 어렵게&amp;quot;하는 문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;스트림-처리&#34;&gt;스트림 처리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스트림을 처리하는 방법
&lt;ol&gt;
&lt;li&gt;이벤트에서 데이터를 꺼내 &lt;strong&gt;데이터베이스나 캐시,검색 색인 또는 유사한 저장소 시스템&lt;/strong&gt;에 기록하고, 다른 클라이언트가 이 시스템에 해당 데이터를 질의한다.
&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-5.png&#34; alt=&#34;그림 11-5&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-5. 데이터베이스에 쓰여진 순서대로 데이터를 가져와 다른 시스템에 변경 사항을 같은 순서로 적용한다.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;이벤트를 사용자에게 직접 보낸다.
&lt;ul&gt;
&lt;li&gt;이메일 경고, 푸시 알림, 실시간 대시보드&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;하나 이상의 입력 스트림을 처리해 하나 이상의 출력 스트림을 생산한다.
&lt;ul&gt;
&lt;li&gt;스트림 처리자가 입력 스트림을 소비해 추가 전용 방식으로 다른 곳에 출력을 쓴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;스트림을 처리하는 코드 조각을 연산자(operator)나 작업(job)이라 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스트림-처리의-사용&#34;&gt;스트림 처리의 사용&lt;/h3&gt;
&lt;h4 id=&#34;모니터링-시스템&#34;&gt;모니터링 시스템&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;특정 상황이 발생하면 경고를 해주는 모니터링 목적으로 사용돼 왔다.
&lt;ul&gt;
&lt;li&gt;사기 감시 시스템의 신용카드 사용 패턴&lt;/li&gt;
&lt;li&gt;금융 시장의 가격 변화 감지&lt;/li&gt;
&lt;li&gt;공장의 기계 상태 모니터링: 오작동 감지&lt;/li&gt;
&lt;li&gt;군사 첩보 시스템의 잠재적 침략자의 활동 추적&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;복잡한-이벤트-처리&#34;&gt;복잡한 이벤트 처리&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_event-processor.png&#34; alt=&#34;Event Processor&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;복잡한 이벤트 처리(complex event processing, CEP)
&lt;ul&gt;
&lt;li&gt;특정 이벤트 패턴 검색에 적합&lt;/li&gt;
&lt;li&gt;정규 표현식으로 문자열에서 특정 문자 패턴을 찾는 방식과 유사함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;질의는 처리 엔진에 제출하고 처리 엔진은 입력 스트림을 소비해 필요한 매칭을 수행하는 상태 기계를 내부적으로 유지한다.&lt;/li&gt;
&lt;li&gt;해당 매치를 발견하면 엔진은 감지한 이벤트 패턴의 세부 사항을 포함하는, 글자 그대로 복잡한 이벤트(complex event)를 방출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;데이터베이스와 비교&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;구분&lt;/th&gt;
          &lt;th&gt;데이터베이스&lt;/th&gt;
          &lt;th&gt;CEP&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;데이터 저장 형태&lt;/td&gt;
          &lt;td&gt;영구 저장&lt;/td&gt;
          &lt;td&gt;흘러가면서 이벤트 패턴에 매칭되는 질의를 찾음&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;질의 형태&lt;/td&gt;
          &lt;td&gt;일시적&lt;/td&gt;
          &lt;td&gt;오랜 기간 저장&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;스트림-분석&#34;&gt;스트림 분석&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;스트림 분석은 대량의 이벤트를 집계하고 통계적 지표를 뽑는다.&lt;/li&gt;
&lt;li&gt;특정 유형의 이벤트 빈도 측정&lt;/li&gt;
&lt;li&gt;특정 기간에 걸친 값의 이동 평균(rolling average) 계산&lt;/li&gt;
&lt;li&gt;이전 시간 간격과 현재 통계값의 비교&lt;/li&gt;
&lt;li&gt;통계는 고정된 시간 간격 기준으로 계산한다. 집계 시간 간격을 윈도우(window)라 한다.
&lt;ul&gt;
&lt;li&gt;ex)
&lt;ul&gt;
&lt;li&gt;지난 5분간 서비스에 들어온 초당 질의 수의 평균을 구하거나&lt;/li&gt;
&lt;li&gt;같은 기간 동안의 99분위 응답 시간을 구한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;구체화-뷰-유지하기&#34;&gt;구체화 뷰 유지하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스 변경에 대한 스트림은 파생 데이터 시스템이 원본 데이터베이스의 최신 내용 동기화.
&lt;ul&gt;
&lt;li&gt;파상 데이터 시스템: 캐시, 검색 색인, 데이터 웨어하우스&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;어떤 데이터셋에 대한 또 다른 뷰를 만들어 효율적으로 질의할 수 있게 하고 기반이 되는 데이터가 변경될 때마다 뷰를 갱신한다.&lt;/li&gt;
&lt;li&gt;이벤트 소싱에서 애플리케이션 상태는 이벤트 로그를 적용함으로써 유지된다.
&lt;ul&gt;
&lt;li&gt;애플리케이션 상태는 일종의 구체화 뷰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트림-상에서-검색하기&#34;&gt;스트림 상에서 검색하기&lt;/h4&gt;
&lt;p&gt;복잡한 기준을 기반으로 개별 이벤트를 검색해야 하는 경우&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;부동산 웹사이트의 사용자는 부동산 시장에 사용자가 설정한 검색 기준과 매칭되는 새 부동산이 나오면 알려달라고 요청할 수 있다&lt;/li&gt;
&lt;li&gt;스트림 검색: 질의를 먼저 저장하고 문서는 질의를 지나가면서 실행된다. (CEP)
&lt;ul&gt;
&lt;li&gt;전통적인 검색 엔진: 문서를 색인하고 색인을 통해 질의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;메시지-전달과-rpc&#34;&gt;메시지 전달과 RPC&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;메시지 전달 시스템을 RPC 대안으로 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;아파치 스톰: DRPC(Distributed RPC)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_drpc.png&#34; alt=&#34;DRPC&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;시간에-관한-추론&#34;&gt;시간에 관한 추론&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;분석 목적으로 스트림을 처리하는 경우 시간을 다뤄야 할 때가 있다.
&lt;ul&gt;
&lt;li&gt;ex) 지난 5분 동안 평균(윈도우)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;스트림 처리 프레임워크는 윈도우 시간을 결정할 때 처리하는 장비의 시스템 시계(처리 시간)를 이용한다.
&lt;ul&gt;
&lt;li&gt;이벤트 생성과 처리 사이의 간격을 확인하여 문제 발생을 예측할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일괄 처리는 이벤트에 내장된 타임스탬프 이용&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;이벤트-시간-vs-처리-시간&#34;&gt;이벤트 시간 vs 처리 시간&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;처리가 지연되는 이유&lt;/li&gt;
&lt;li&gt;큐 대기&lt;/li&gt;
&lt;li&gt;네트워크 결함&lt;/li&gt;
&lt;li&gt;메시지 브로커나 처리자에서 경쟁을 유발하는 성능 문제&lt;/li&gt;
&lt;li&gt;스트림 소비자의 재시작&lt;/li&gt;
&lt;li&gt;결함에서 복구하는 도중이나 코드 상의 버그를 고친 후 과거 이벤트의 재처리&lt;/li&gt;
&lt;li&gt;이벤트 발생 시간과 처리 시간을 혼동하면 잘못된 데이터가 생길 수 있다.&lt;/li&gt;
&lt;li&gt;스트림 처리자가 재시작한 상황: 1분간 스트림 처리가 셧다운됐다가 복구되어 백로그 이벤트를 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11-7.png&#34; alt=&#34;그림 11-7&#34;&gt;&lt;br&gt;
&lt;em&gt;그림 11-7. 처리 시간 기준으로 윈도우를 만들면 처리율의 변동 때문에 생기는 허상을 남긴다.&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;준비-여부-인식&#34;&gt;준비 여부 인식&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 시간 기준으로 윈도우를 정의할 때 낙오자(straggler)가 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;낙오자 이벤트를 처리하는 방법
&lt;ol&gt;
&lt;li&gt;낙오자 이벤트는 무시한다. 적은 비율일 때 무시하지만, 비율이 높아지면 알림을 보내는 방법으로 처리&lt;/li&gt;
&lt;li&gt;수정 값을 발행한다. 이벤트가 포함된 윈도우를 기준으로 새로 갱신한 값&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;어떤-시계를-사용할-것인가&#34;&gt;어떤 시계를 사용할 것인가?&lt;/h4&gt;
&lt;p&gt;이벤트가 발생한 머신과 이벤트를 처리하는 서버의 시간을 통해서 이벤트 발생 시간을 추정하는 방법(잘못된 장치 시계를 조정하는 방법)&lt;/p&gt;
&lt;p&gt;세 가지 타임스탬프를 로그로 남긴다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;이벤트가 발생한 시간(장치 시계)&lt;/li&gt;
&lt;li&gt;이벤트를 서버로 보낸 시간(장치 시계)&lt;/li&gt;
&lt;li&gt;서버에서 이벤트를 받은 시간(서버 시계)
두 번째와 세 번째의 차이를 구하면 장치 시계와 서버 시계 간의 오프셋을 추정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;필요한 타임스탬프 정확도에 비해 네트워크 지연은 무시할 만하고 계산한 오프셋을 이벤트 타임스탬프에 적용해 이벤트가 실제로 발생 시간을 추정할 수 있다&lt;/p&gt;
&lt;h3 id=&#34;윈도우-유형&#34;&gt;윈도우 유형&lt;/h3&gt;
&lt;p&gt;이벤트 타임스탬프를 어떻게 결정할지 안다면 다음 단계는 윈도우 기간을 어떻게 정의해야 하는지 결정하는 일이다.&lt;br&gt;
이벤트 수를 세거나 윈도우 내 평균값을 구하는 등 집계할 때 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_window.png&#34; alt=&#34;윈도우&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;텀블링 윈도우(Tumbling window)&lt;/li&gt;
&lt;li&gt;고정 길이&lt;/li&gt;
&lt;li&gt;겹치는 부분 없음&lt;/li&gt;
&lt;li&gt;홉핑 윈도우(Hopping window)&lt;/li&gt;
&lt;li&gt;고정 길이&lt;/li&gt;
&lt;li&gt;겹치는 부분 있음&lt;/li&gt;
&lt;li&gt;슬라이딩 윈도우(Sliding window)&lt;/li&gt;
&lt;li&gt;고정 길이&lt;/li&gt;
&lt;li&gt;이벤트 timestamps 에 따라 겹칠 수도 있고, 겹치지 않을 수도 있음&lt;/li&gt;
&lt;li&gt;세션 윈도우(Session window)&lt;/li&gt;
&lt;li&gt;동적 변동 길이&lt;/li&gt;
&lt;li&gt;데이터 기반 윈도&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;스트림-조인&#34;&gt;스트림 조인&lt;/h3&gt;
&lt;p&gt;일괄 처리 작업과 비슷하다.&lt;br&gt;
하지만, 스트림 상에서 &lt;strong&gt;새로운 이벤트가 언제든 나타날 수 있다는 사실&lt;/strong&gt;은 스트림 상에서 수행하는 조인을 일괄 처리 작업에서 수행하는 조인보다 어렵게 만든다.&lt;/p&gt;
&lt;h4 id=&#34;스트림-스트림-조인윈도우-조인&#34;&gt;스트림 스트림 조인(윈도우 조인)&lt;/h4&gt;
&lt;p&gt;그림. 윈도우 크기: 10초&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_stream-stream-join.jpg&#34; alt=&#34;스트림 조인&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) 웹사이트에 검색 기능이 있고 검색된 URL의 최신 경향을 파악하고 싶다.&lt;/li&gt;
&lt;li&gt;검색 질의 타이핑할 때마다 질의와 반환된 결과가 있는 이벤트를 로깅한다.&lt;/li&gt;
&lt;li&gt;같은 세션 ID로 서로 연관된 검색 활동 이벤트와 클릭 활동 이벤트를 함께 모은다. (F)&lt;/li&gt;
&lt;li&gt;검색은 했지만 클릭이 발생하지 않을 수 있다. (D)&lt;/li&gt;
&lt;li&gt;네트워크 지연도 가변적이기 때문에 클릭 이벤트가 먼저 도착할 수 있다. (E)&lt;/li&gt;
&lt;li&gt;조인을 위한 적절한 윈도우 선택이 필요하다.&lt;/li&gt;
&lt;li&gt;스트림 처리자가 상태(state)를 유지해야 한다.&lt;/li&gt;
&lt;li&gt;ex) 지난 시간에 발생한 모든 이벤트를 세션 ID로 색인한다.&lt;/li&gt;
&lt;li&gt;검색, 클릭 이벤트가 발생할 때마다 해당 색인에 추가하고 스트림 처리자는 같은 세션ID로 이미 도착한 다른 이벤트가 있는지 다른 색인을 확인해야 한다.&lt;/li&gt;
&lt;li&gt;이벤트가 매칭되면 검색한 결과를 클릭했다고 말해주는 이벤트를 방출한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;스트림-테이블-조인스트림-강화&#34;&gt;스트림 테이블 조인(스트림 강화)&lt;/h4&gt;
&lt;p&gt;리스팅개발팀 &amp;gt; 11. 스트림 처리 &amp;gt; stream-table-join.jpg&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_stream-table-join.jpg&#34; alt=&#34;스트림 테이블 조인&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스로부터 데이터를 가져와서 이벤트 스트림과 조인&lt;/li&gt;
&lt;li&gt;네트워크 왕복 없이 스트림 처리자 내부에 데이터베이스 사본을 적재한다.&lt;/li&gt;
&lt;li&gt;사본 용량에 따라 메모리 내 해시테이블 또는 로컬 디스크에 넣을 수도 있다.&lt;/li&gt;
&lt;li&gt;복사본을 최신 상태로 유지: 변경 데이터 캡처(change data capture, CDC)&lt;/li&gt;
&lt;li&gt;스트림 스트림 조인과 비슷하지만, 테이블 변경 로그 스트림쪽은 &amp;ldquo;시작 시간&amp;quot;까지 이어지는 윈도우를 사용하며 레코드의 새 버전으로 오래된 것을 덮어쓴다 (G1, G2)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;테이블-테이블-조인구체화-뷰-유지&#34;&gt;테이블 테이블 조인(구체화 뷰 유지)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/data-intensive-application/11_inner-table-table-join.jpg&#34; alt=&#34;테이블 테이블 조인&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;양쪽 입력 스트림이 모두 데이터베이스의 변경 로그다. 한 쪽의 모든 변경을 다른 쪽의 최신 상태와 조인한다.&lt;/li&gt;
&lt;li&gt;결과를 두 테이블을 조인한 구체화 뷰의 변경 스트림이 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;조인의-시간-의존성&#34;&gt;조인의 시간 의존성&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;하나의 조인 입력을 기반으로 한 특정 상태 유지
&lt;ul&gt;
&lt;li&gt;다른 조인 입력에서 온 메시지에 그 상태를 질의한다.&lt;/li&gt;
&lt;li&gt;상태를 유지하는 이벤트의 순서는 매우 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;시간에 따라 변하는 상태를 조인해야 한다면 어느 시점을 조인에 사용해야 할까?
&lt;ul&gt;
&lt;li&gt;ex) 물건 판매: 세율&lt;/li&gt;
&lt;li&gt;복수 개의 스트림에 걸친 이벤트 순서가 결정되지 않으면 조인도 비결정적이다.&lt;/li&gt;
&lt;li&gt;천천히 변하는 차원(slowly changing dimension, SCD)
&lt;ul&gt;
&lt;li&gt;조인되는 레코드의 특정 버전을 가리키는 데 유일한 식별자(unique identifier)를 사용해 해결한다.&lt;/li&gt;
&lt;li&gt;세율이 바뀔 때마다 새 식별자를 부여하고 송장에는 판매 시점의 세율을 표시하는 식별자를 포함해야 한다.&lt;/li&gt;
&lt;li&gt;이렇게 변경한 조인은 결정적이지만 테이블에 있는 레코드의 모든 버전을 보유해야 하기 때문에 로그 컴팩션이 불가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;내결함성&#34;&gt;내결함성&lt;/h3&gt;
&lt;p&gt;일괄 처리(10장)는 일부 태스크가 실패할지라도 재처리가 가능하다.&lt;br&gt;
스트림 처리는 무한하다. 그래서 처리를 절대 완료할 수 없다.&lt;/p&gt;
&lt;h4 id=&#34;마이크로-일괄-처리와-체크-포인트&#34;&gt;마이크로 일괄 처리와 체크 포인트&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;마이크로 일괄처리(microbatching): 스트림을 작은 블록으로 나누고 각 블록을 소형 일괄 처리와 같이 다루는 방법이다.
&lt;ul&gt;
&lt;li&gt;스파크 스트리밍에서 사용&lt;/li&gt;
&lt;li&gt;처리 크기는 약 1초 정도
&lt;ul&gt;
&lt;li&gt;처리 크기가 작을수록 스케줄링과 코디네이션 비용이 커진다&lt;/li&gt;
&lt;li&gt;처리 크기가 클수록 스트림 처리의 결과를 보기까지 지연시간이 길어진다&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;체크포인트(checkpoint): 주기적으로 상태의 롤링 체크포인트를 생성하고 지속성 있는 저장소에 저장한다.
&lt;ul&gt;
&lt;li&gt;아파치 플링크&lt;/li&gt;
&lt;li&gt;스트림 연산자에 장애가 발생하면 스트림 연산자는 가장 최근 체크포인트에서 재시작하고 해당 체크포인트와 장애 발생 사이의 출력은 버린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;두 가지 접근법만으로는 이 문제를 방지하기에 충분하지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;원자적-커밋-재검토&#34;&gt;원자적 커밋 재검토&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;장애가 발생했을 때 정확히 한 번 처리되는 것처럼 보일려면 처리가 성공했을 때만 모든 출력과 이벤트 처리의 부수 효과가 발생하게 해야 한다.
&lt;ul&gt;
&lt;li&gt;원자적이거나 동기화되어야함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;멱등성idempotence&#34;&gt;멱등성(idempotence)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;결국 목표는 처리 효과가 두 번 나타나는 일 없이 안전하게 재처리하기 위해 실패한 태스크의 부분 출력을 버리는 것&lt;/li&gt;
&lt;li&gt;멱등 연산: 여러 번 수행하더라도 오직 한 번 수행한 것과 같은 효과를 내는 연산&lt;/li&gt;
&lt;li&gt;연산 자체가 멱등적이지 않아도 약간의 여분 메타데이터로 연산을 멱등적으로 만들 수 있다.&lt;/li&gt;
&lt;li&gt;모든 메시지에는 영속적이고 단조 증가하는 오프셋이 있다.&lt;/li&gt;
&lt;li&gt;트리거한 메시지의 오프셋을 함께 포함한다면 이미 갱신이 적용됐는지 확인할 수 있기 때문에 반복해서 같은 갱신이 수행되는 것을 막을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;실패-후에-상태-재구축하기&#34;&gt;실패 후에 상태 재구축하기&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;원격 데이터 저장소에 상태를 유지하고 복제하는 것&lt;/li&gt;
&lt;li&gt;스트림 처리자의 로컬에 상태를 유지하고 주기적으로 복제하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;모든 트레이드오프는 기반 인프라스트럭처의 성능 특성에 달려있다.&lt;/p&gt;
&lt;h2 id=&#34;참조-자료&#34;&gt;참조 자료&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#windowing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;윈도우 : CONFLUENT | Streams DSL | Confluent Documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.confluent.io/ko-kr/blog/crossing-streams-joins-apache-kafka/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;스트림 조인 : CONFLUENT | Crossing the Streams – Joins in Apache Kafka&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>NoSQL</category>
      
      <category>Data</category>
      
      <category>RDB</category>
      
    </item>
    
  </channel>
</rss>
