<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>devkuma – Transaction</title>
    <link>https://www.devkuma.com/tags/transaction/</link>
    <image>
      <url>https://www.devkuma.com/tags/transaction/logo/180x180.jpg</url>
      <title>Transaction</title>
      <link>https://www.devkuma.com/tags/transaction/</link>
    </image>
    <description>Recent content in Transaction on devkuma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <managingEditor>kc@example.com (kc kim)</managingEditor>
    <webMaster>kc@example.com (kc kim)</webMaster>
    <copyright>The devkuma</copyright>
    
	  <atom:link href="https://www.devkuma.com/tags/transaction/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Database Index (인덱스)</title>
      <link>https://www.devkuma.com/docs/rdbms/index/</link>
      <pubDate>Sun, 19 Dec 2021 01:05:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/rdbms/index/</guid>
      <description>
        
        
        &lt;h2 id=&#34;인덱스index란&#34;&gt;인덱스(index)란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이블에 대한 동작 속도를 높여주는 자료 구조를 말한다.&lt;/li&gt;
&lt;li&gt;인텍스는 테이블 내에 1개의 컬럼, 혹은 여러 컬럼을 이용하여 생성될 수 있다.&lt;/li&gt;
&lt;li&gt;빠른 검색 동작뿐 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다.&lt;/li&gt;
&lt;li&gt;인덱스란 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료 구조이다.&lt;/li&gt;
&lt;li&gt;만약 우리가 책에서 원하는 내용을 찾는다고 하면, 책의 모든 페이지를 찾아 보는 것은 오랜 시간이 걸린다. 그렇게 때문에 책의 저자들은 책의 맨 앞 또는 맨 뒤에 색인을 추가하는데, 데이터베이스의 index는 책의 색인과 같다.&lt;/li&gt;
&lt;li&gt;데이터베이스에서도 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.&lt;/li&gt;
&lt;li&gt;만약 index를 적용하지 않은 컬럼을 조회하면, 전체를 탐색하는 Full Scan이 수행된다. Full Scan은 전체를 비교하여 탐색하기 때문에 속도가 떨어진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;데이터베이스에서-자료를-갬색하는-2가지-방법&#34;&gt;데이터베이스에서 자료를 갬색하는 2가지 방법&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FTS(Full Table Scan)
&lt;ul&gt;
&lt;li&gt;테이블을 처음부터 끝까지 검색하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Index Scan
&lt;ul&gt;
&lt;li&gt;인데그를 검색하여 해당 자료의 테이블을 액세스하는 방법이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인덱스의-자료구조&#34;&gt;인덱스의 자료구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;해시 테이블&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.&lt;/li&gt;
&lt;li&gt;시간복잡도 O(1)이라 검색이 매우 빠르다.&lt;/li&gt;
&lt;li&gt;부등호(&amp;lt;, &amp;gt;)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+Tree&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.&lt;/li&gt;
&lt;li&gt;BTree의 리프노드들을 LinekdList로 연결하여 순차 검색을 용이하게 하였다.&lt;/li&gt;
&lt;li&gt;해시 테이블보다 나쁜 O(𝑙𝑜𝑔2𝑛)의 시간 복잡도를 갖지만 해시테이블보다 흔하게 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>RDBMS</category>
      
      <category>Transaction</category>
      
    </item>
    
    <item>
      <title>Database Transaction (트랜잭션)</title>
      <link>https://www.devkuma.com/docs/rdbms/transaction/</link>
      <pubDate>Sun, 19 Dec 2021 01:05:00 +0900</pubDate>
      <author>kc@example.com (kc kim)</author>
      <guid>https://www.devkuma.com/docs/rdbms/transaction/</guid>
      <description>
        
        
        &lt;h2 id=&#34;database-transaction트랜잭션이란&#34;&gt;Database Transaction(트랜잭션)이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이터베이스의 상태를 변화시키기 위해 수행하는 논리적인 작업의 단위이다.&lt;/li&gt;
&lt;li&gt;데이터베이스의 데이터를 조작하는 작업 단위(Unit of work)이다.&lt;/li&gt;
&lt;li&gt;트랜잭션에는 여러가지의 연산이 수행될 수 있다.&lt;/li&gt;
&lt;li&gt;트랜재션은 수행 중에 한 작업이라도 실패를 하면 전부 롤백이 이루어지고, 모두 성공하면 commit을 수행한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transaction-acid란&#34;&gt;Transaction ACID란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;원자성(Atomicity)
&lt;ul&gt;
&lt;li&gt;하나의 트랜잭션이 작업이 그중에 일부분만 실행되거나 중단되지 않는 것을 보장해주는 것을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;일관성(Consistency)
&lt;ul&gt;
&lt;li&gt;트랜잭션이 작업이 성공적으로 완료가 되더라도 작업 이전과 같이 같은 상태를 유지하는 것을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;격리성(Isolation)
&lt;ul&gt;
&lt;li&gt;Trasaction 작업이 수행되고 있을 때 다른 작업이 끼어들지 못하도록 보장해주는 것을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;지속성(Durability)
&lt;ul&gt;
&lt;li&gt;성공적으로 수행된 트랜잭션이 대해서는 영구히(Persistent) 반영되어야 함을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transaction을-사용시-주의할-점&#34;&gt;Transaction을 사용시 주의할 점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;트랜잭션의 범위는 최소화한다.
&lt;ul&gt;
&lt;li&gt;트랜잭션의 범위를 최소화 하는 것이 중요하다.&lt;/li&gt;
&lt;li&gt;데이터베이스의 커넥션의 수는 한정적이기 때문에 커넥션을 보유하는 시간을 최소화해야할 필요가 있다.&lt;/li&gt;
&lt;li&gt;그렇지 않으면, 다른 서비스들은 해당 커넥션 사용을 위해 대기해야 할 상황이 발생한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;transaction-isolation-level의-종류-및-특징은-무엇인가&#34;&gt;Transaction isolation level의 종류 및 특징은 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED
&lt;ul&gt;
&lt;li&gt;SELECT 쿼리 실행시에 다른 트랜잭션에서 COMMIT 되지 않은 데이터를 읽어올 수 있다.&lt;/li&gt;
&lt;li&gt;COMMIT 되지 않은 데이터를 읽는 현상을 Dirty read라고 말한다.&lt;/li&gt;
&lt;li&gt;INSERT만 진행되고 ROLLBACK 될 수 있는, 즉 COMMIT이 되지 않은 데이터를 읽을 수 있어 유의해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;READ COMMITTED
&lt;ul&gt;
&lt;li&gt;COMMITTED에서는 COMMIT이 완료된 데이터만 SELECT시에 보이는 수준을 보장하는 Level이며, 대부분 DBMS에서 Read Committed를 기본으로 설정한다.&lt;/li&gt;
&lt;li&gt;Read Committed에서는 Read Uncommitted에서 발생하는 Dirty read가 발생하지 않도록 보장해 준다.&lt;/li&gt;
&lt;li&gt;트랜잭션에서 COMMIT을 수행하지 않더라도 DB에 이미 값이 반영이 되어있는 상태인데 COMMIT 이전의 데이터를 보장 받기 위해서는 COMMIT 되지 않은 쿼리를 복구하는 과정이 필요하게 된다. 즉, 이 시점에서는 Consistent Read를 수행해야 함을 의미한다.&lt;/li&gt;
&lt;li&gt;Read Committed의 문제는 하나의 트랜잭션 안에서 SELECT를 수행 할 때마다 데이터가 동일하다는 보장을 해주지 않는다. 그 이유는 다른 트랜젝션에서 해당 데이터를 COMMIT 했을 경우에는 COMMIT된 데이터를 반환해 주는게 Read Committed의 특징이기 때문이다.&lt;/li&gt;
&lt;li&gt;위와 같은 이유로 Read Committed를 Non-repeatable Read라고도 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;REPEATABLE READ
&lt;ul&gt;
&lt;li&gt;Read Committed와는 다르게 Repeatable Read는 한 트랜잭션 안에서 반복해서 SELECT를 수행하더라도 읽어 들이는 값이 변하지 않음을 보장한다.&lt;/li&gt;
&lt;li&gt;Repeatable Read 트랙잭션은 처음 SELECT를 수행한 시간을 기록한 뒤 그 이후에는 모든 SELECT마다 해당 시점을 기분으로 Consistent Read를 수행하여 준다.&lt;/li&gt;
&lt;li&gt;그러므로 트랜잭션 도중 다른 트랜잭션이 COMMIT되더라도 새로이 COMMIT된 데이터는 보이지 않게 된다.&lt;/li&gt;
&lt;li&gt;그 이유는 첫 SELECT 시에 생성된 SNAPSHOT을 읽기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SERIALIZABLE
&lt;ul&gt;
&lt;li&gt;Serializable은 모든 작업을 하나의 트랜잭션에서 처리하는 것과 같은 가장 높은 고립수준을 제공한다.&lt;/li&gt;
&lt;li&gt;Read Committed, Repeatable Read 두개의 공통적인 이슈는 Phantom Read가 발생한다는 점이다.
&lt;ul&gt;
&lt;li&gt;Phantom Read란?
&lt;ul&gt;
&lt;li&gt;하나의 트랜잭션에서 UPDATE 명령이 유실되거나 덮어써질수 있는 즉, UPDATE후 COMMIT하고 다시 조회를 했을때 예상과는 다른 값이 보이거나 데이터가 유실된 경우를 Phantom Read라고 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그와 다르게 SERIALIZABLE에서는 SELECT 쿼리가 전부 SELECT &amp;hellip; FOR SHARE로 자동으로 변경되어 Repeatable Read에서 막을 수 없는 몇 가지 상황을 방지할 수 있게됩니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;commit과-rollback&#34;&gt;Commit과 Rollback&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Commit
&lt;ul&gt;
&lt;li&gt;하나의 트랜잭션이 끝났을 때, 완료된 것을 트랙잭션 관리자에게 알려준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rollback
&lt;ul&gt;
&lt;li&gt;하나의 트랜잭션 처리가 비정상적으로 종료되어 DB의 일괄성을 깨트렸을 때, 모든 연산을 취소시키는 것을 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Database</category>
      
      <category>RDBMS</category>
      
      <category>Transaction</category>
      
    </item>
    
  </channel>
</rss>
