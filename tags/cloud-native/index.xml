<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>devkuma – Cloud Native</title>
    <link>https://www.devkuma.com/tags/cloud-native/</link>
    <image>
      <url>https://www.devkuma.com/tags/cloud-native/logo/180x180.jpg</url>
      <title>Cloud Native</title>
      <link>https://www.devkuma.com/tags/cloud-native/</link>
    </image>
    <description>Recent content in Cloud Native on devkuma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <managingEditor>redfreek2c@gmail.com (kimkc)</managingEditor>
    <webMaster>redfreek2c@gmail.com (kimkc)</webMaster>
    <copyright>The devkuma</copyright>
    
	  <atom:link href="https://www.devkuma.com/tags/cloud-native/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>클라우드 네이티브(Cloud Native)</title>
      <link>https://www.devkuma.com/docs/cloud-native/</link>
      <pubDate>Thu, 15 Sep 2022 16:53:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/cloud-native/</guid>
      <description>
        
        
        &lt;p&gt;&lt;img src=&#34;./cncf-color.png&#34; alt=&#34;클라우드 네이티브&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;클라우드-네이티브란&#34;&gt;클라우드 네이티브란?&lt;/h2&gt;
&lt;p&gt;넓은 의미로 정의해 본다면 클라우드의 이점을 최대로 활용할 수 있도록 애플리케이션을 구축하고 실행하는 방식을 말한다.&lt;/p&gt;
&lt;p&gt;기존 시스템에서의 애플리케이션은 클라우드의 이점을 100% 활용하지 못했다면, 마이크로서비스 아키텍처를 채택하고 컨테이너, 쿠버네티스와 같은 기술과 도구, DevOps, 애자일 방법론 등을 도입하여 개발자 생산성, 비즈니스 민첩성, 확장성, 가용성 및 비용 절감 효과를 크게 높일 수 있다.&lt;/p&gt;
&lt;p&gt;그러기 위해서는 애플리케이션, 아키텍처, 인프라 및 개발 프로세스 등 전방위적 측면에서 변화가 필요한데, 변화의 방향은 무엇이며 클라우드를 네이티브하게 사용한다는 뜻은 무엇인지 알아보겠다.&lt;/p&gt;
&lt;h2 id=&#34;서비스-서버의-변화&#34;&gt;서비스 서버의 변화&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;~ 2000년 : 물리서버
&lt;ul&gt;
&lt;li&gt;모놀리스(Monolith) 애플리케이션 운영&lt;/li&gt;
&lt;li&gt;물리 서버가 대수가 많지 않고, 서버를 1:1 관리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2001 ~ 2009년 : 가상화 기술 1세대
&lt;ul&gt;
&lt;li&gt;실제 시스템을 가상 머신으로 대체&lt;/li&gt;
&lt;li&gt;통합 비율을 올리고 고효율화 하는 것이 목적이고, 서버의 멀티 코어화와 가상화 기술의 보급&lt;/li&gt;
&lt;li&gt;가상화 기술에 대한 대안으로 컨테이너 기술이 나옴&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2010 ~ 2015년 : 가상화 기술 2세대. Cloud 시대
&lt;ul&gt;
&lt;li&gt;클라우드가 대규모 서비스에 적합하고 확장 가능성을 입증&lt;/li&gt;
&lt;li&gt;안정적으로 대규모 인프라를 관리하기 위한 기술도 보급&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2010 ~ 2015년 : Cloud Native 세대
&lt;ul&gt;
&lt;li&gt;2016년 1월에 정식 출범 한 Cloud Native Computing Foundation(이하 CNCF)는 진짜 클라우드 기술을 오픈소스로 해결하는 것을 목표&lt;/li&gt;
&lt;li&gt;애클리케이션을 실행하는 데 필요한 최적의 인프라 제공
&lt;ul&gt;
&lt;li&gt;개발한 것을 &amp;ldquo;즉시&amp;rdquo;, &amp;ldquo;안정적&amp;quot;으로 제공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cncf이란&#34;&gt;CNCF이란?&lt;/h2&gt;
&lt;p&gt;2015년 처음 Cloud Native라는 용어를 사용한 리눅스는 CNCF(Cloud Native Computing Foundation)재단을 만들어 클라우드 네이티브로 전환할 수 있는 오픈소스 기술들을 추진하고 관리한다. 이 재단에는 550개가 넘는 여러 클라우드 공급자와 기술 기업들이 참여하여 운영되고 있는데 클라우드 네이티브에 대한 정의를 아래와 같이 하고 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;퍼블릭, 프라이빗, 하이브리드 클라우드 환경에서 확장성 있는 애플리케이션을 만들고 운영할 수 있다.&lt;/li&gt;
&lt;li&gt;컨테이너, 서비스 메시, 마이크로서비스, 불변의 인프라스트럭처, 그리고 선언적 API가 전형적인 접근 방식에 해당한다.&lt;/li&gt;
&lt;li&gt;회복성이 있고, 관리 편의성을 제공하며, 가시성을 갖는 느슨하게 결합된 시스템을 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;견고한 자동화와 함께 사용하면, 엔지니어는 최소한의 수고로 영향력이 크고 예측 가능한 변경을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CNCF 클라우드 네이티브 정의 참고 :  &lt;a href=&#34;https://github.com/cncf/toc/blob/master/DEFINITION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/cncf/toc/blob/master/DEFINITION.md&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;클라우드 네이티브를 위한 주요 4가지 요소
위의 정의를 정리해 보면, 클라우드 네이티브로 가기 위한 주요 요소는 아래 4가지로 요약할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/cloud-native/1_8tS36qcyZ2c-kYF3zSrbfA.png&#34; alt=&#34;Cloud Native&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;lt;그림 참고 : &lt;a href=&#34;https://medium.com/velotio-perspectives/cloud-native-applications-the-why-the-what-the-how-9b2d31897496&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chirag Jog’s Blog&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DevOps&lt;/strong&gt;&lt;br&gt;
애플리케이션 개발-운영 간의 협업 프로세스를 자동화하는 것을 말하며 결과적으로 애플리케이션의 개발과 개선 속도를 빠르게 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CI/CD&lt;/strong&gt;&lt;br&gt;
지속적인 통합(Continous Intergration)은 개발자가 작업한 코드를 자동으로 테스트하고 테스트에 통과하면 코드를 통합하여 저장한다.&lt;br&gt;
지속적인 배포(Continuos Deployment)는 작업한 코드 및 변경사항들은 테스트를 거쳐 리포지토리에 업로드되고 실 서비스 배포로 릴리즈까지 자동화하는 것을 말한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Containers 기반 인프라&lt;/strong&gt;&lt;br&gt;
가상화 기술 중 하나로, 시스템을 가상화하는 것이 아니라 애플리케이션을 구동할 수 있는 컴퓨팅 작업을 패키징하여 가상화한 것이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Micro-services&lt;/strong&gt;&lt;br&gt;
애플리케이션을 구성하는 서비스들을 독립적인 작은 단위로 분해하여 구축하고 각 구성 요소들을 네트워크로 통신하는 아키텍처로 서비스 안정성과 확장성(scaling)을 지원한다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;클라우드-네이티브의-애플리케이션-가치&#34;&gt;클라우드 네이티브의 애플리케이션 가치&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;빠른 반복&lt;br&gt;
클라우드 네이티브 애플리케이션 개발을 활용한다는 것은 Kubernetes로 대표되는 컨테이너와 같은 민첩하고 확장 가능한 구성 요소를 사용하여 멀티 클라우드와 같은 기술 경계를 넘어 잘 설명된 방식으로 통합되는 개별적이고 재사용 가능한 기능을 제공하는 것을 의미한다. 반복적인 자동화 및 오케스트레이션을 사용하여 빠르게 반복한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;자동 배포
클라우드 네이티브 접근 방식은 소프트웨어 제공 프로세스에서 개발 환경과 다른 이질적인 환경을 구축하는 데 상당한 노력이 필요한 기존의 가상화 지향 비즈니스 프로세스보다 훨씬 우수하다. 반면에 클라우드 네이티브 아키텍처는 자동화 및 구성을 특징으로 하며 신뢰할 수 있고 검증되고 감사된 알려진 양호한 프로세스의 기반에 의존하여 반복적인 인간 개입 없이 민첩한 전달을 제공한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;독립적이고 효율적인
클라우드 네이티브는 마이크로 서비스 기반 아키텍처를 가져온다. 마이크로 서비스는 기본적으로 독립적으로 릴리스될 수 있는 애플리케이션 서비스이므로 업그레이드, 회색조 또는 독립 구성 요소로 재사용할 수 있으며 전체 대규모 애플리케이션에 미치는 영향이 적다. 입력 포트와 출력 포트가 결정되기만 하면 신뢰 당사자가 충분히 발전할 수 있으며 전체 팀의 조직 구조가 더욱 간소화되어 통신 비용이 저렴하고 효율성이 높다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/velotio-perspectives/cloud-native-applications-the-why-the-what-the-how-9b2d31897496&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cloud Native Applications — The Why, The What &amp;amp; The How. | Chirag Jog’s Blog&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloudmt.co.kr/?p=3927&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;클라우드 네이티브란? | CLOUDMATE&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.openmaru.io/wp-content/uploads/2022/07/325.Cloud_Native_v3_Publish.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;openmaru&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Cloud Native</category>
      
    </item>
    
    <item>
      <title>Harbor에 대한 설명</title>
      <link>https://www.devkuma.com/docs/harbor/</link>
      <pubDate>Mon, 24 Oct 2022 11:19:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/harbor/</guid>
      <description>
        
        
        &lt;h2 id=&#34;harbor-개요&#34;&gt;Harbor 개요&lt;/h2&gt;
&lt;p&gt;Harbor는 VMware가 개발한 오픈 소스 프라이빗 컨테이너 레지스트리로 Docker Registry와 같이 컨테이너 이미지를 관리하는 기능을 구현한 레지스트리이다.&lt;br&gt;
Docker Hub 처럼 이미지를 저장할 수 있는 저장소로써, Registry의 장점을 포함하여 직관적인 Web 기반 User Interface를 제공하기 때문에 효율적인 이미지 관리가 가능하다.&lt;/p&gt;
&lt;p&gt;일반적으로 Docker를 사용하는 경우 docker 명령을 사용하여 Nginx 및 busybox와 같은 컨테이너 이미지를 배포한다. 이 이미지의 취득처가 레지스트리로, 디폴트에서는 Docker hub로부터 받아오고 오고 있다.&lt;br&gt;
그러나, Docker hub는 공용 레지스트리이므로 보안 액세스가 불가능하거나 회사 프로젝트에서 만드는 것과 같은 자체 컨테이너 이미지를 업로드하는 데 적합하지 않을 수 있다.&lt;br&gt;
Harbor는 이러한 문제를 해결하기 위해 폐쇄 환경에서 사용된다고 가정하는 개인 레지스트리로 다양한 기능을 제공한다.&lt;/p&gt;
&lt;p&gt;원래 Harbor는 2014년에 VMware가 이미지 사용에 있어서 보안 체제의 강화나 컴플라이언스의 준수를 목적으로 개발이 시작되었다.&lt;br&gt;
2016년에 오픈 소스화되었으며 2018년에는 Kubernetes와 같은 개발을 호스팅하는 Cloud Native Computing Foundation(CNCF) 프로젝트 중 하나로 채택되었으며 2020년에 프로젝트를 종료하였다.&lt;/p&gt;
&lt;h2 id=&#34;harbor의-주요-특징&#34;&gt;Harbor의 주요 특징&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker Image 개인 저장소 제공&lt;/li&gt;
&lt;li&gt;Cloud-Native 기반 오픈 소스 레지스트리
&lt;ul&gt;
&lt;li&gt;Harbor는 컨테이너 이미지와 Helm 차트를 모두 지원하며, 컨테이너 런타임 및 오케스트레이션 플랫폼과 같은 클라우드 네이티브 환경의 레지스트리 역할을 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;역할 기반 액세스 제어 관리(RBAC)
&lt;ul&gt;
&lt;li&gt;사용자나 프로젝트마다, 공개하는 컨테이너 이미지나 조작을 제어하는 ​​것이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;정책 기반 복제
&lt;ul&gt;
&lt;li&gt;필터(리포지토리, 태그, 레이블)를 사용하는 정책을 기반으로 서버를 가로지르는 여러 레지스트리 인스턴스 간에 이미지를 복제하여 부하 분산 및 고가용성을 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LDAP/AD 지원
&lt;ul&gt;
&lt;li&gt;AD 및 LDAP와 같은 사용자 관리 시스템을 사용하는 경우 시스템을 Harbor에 통합하여 RBAC에 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;취약성 스캔
&lt;ul&gt;
&lt;li&gt;리포지토리의 컨테이너 이미지에 대해 주기적으로 취약점을 검사하여 취약한 이미지가 배포되는 것을 방지한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OIDC 지원
&lt;ul&gt;
&lt;li&gt;Harbor는 OpenID Connect(OIDC)를 이용하여 Keycloak 등의 외부 인증 서버에서 Harbor 포털로의 싱글 사인온(SSO)을 실현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;그래픽 사용자 포털
&lt;ul&gt;
&lt;li&gt;Web UI 제공한다.&lt;/li&gt;
&lt;li&gt;사용자는 Harbor 포털(WebUI)을 통해 리포지토리를 찾아보고, 검색하고, 프로젝트를 관리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;감사
&lt;ul&gt;
&lt;li&gt;리포지토리에 대한 모든 작업은 WebUI나 로그를 통해 감사, 추적할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;harbor의-운영-환경&#34;&gt;Harbor의 운영 환경&lt;/h2&gt;
&lt;h3 id=&#34;운영-체제와-docker&#34;&gt;운영 체제와 Docker&lt;/h3&gt;
&lt;p&gt;Harbor는 여러 Docker 컨테이너로 배포됩니다. 따라서 Docker를 지원하는 모든 Linux 배포판에 배포할 수 있다. 호스트에는 Docker 및 Docker Compose 설치가 필요하다.&lt;/p&gt;
&lt;h3 id=&#34;하드웨어&#34;&gt;하드웨어&lt;/h3&gt;
&lt;p&gt;다음 표는 Harbor를 배치하기 위한 최소 구성과 권장 구성이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;자원&lt;/th&gt;
&lt;th&gt;최소 구성&lt;/th&gt;
&lt;th&gt;권장 구성&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU&lt;/td&gt;
&lt;td&gt;2CPU&lt;/td&gt;
&lt;td&gt;4CPU&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;메모리&lt;/td&gt;
&lt;td&gt;4GB&lt;/td&gt;
&lt;td&gt;8GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;디스크 크기&lt;/td&gt;
&lt;td&gt;40GB&lt;/td&gt;
&lt;td&gt;160GB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;소프트웨어&#34;&gt;소프트웨어&lt;/h3&gt;
&lt;p&gt;다음 표는 호스트에 설치해야 하는 소프트웨어 및 해당 버전이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;소프트웨어&lt;/th&gt;
&lt;th&gt;버전&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;도커 엔진&lt;/td&gt;
&lt;td&gt;Version 17.06.0-ce+ 이상&lt;/td&gt;
&lt;td&gt;설치 방법에 대한 자세한 내용은 &lt;a href=&#34;https://docs.docker.com/engine/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Engine 설명서&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;를 참조하여라.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Compose&lt;/td&gt;
&lt;td&gt;버전 1.18.0 이상&lt;/td&gt;
&lt;td&gt;설치 방법에 대한 자세한 내용은 &lt;a href=&#34;https://docs.docker.com/compose/install/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Compose 설명서&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;를 참조하여라.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Openssl&lt;/td&gt;
&lt;td&gt;Latest&lt;/td&gt;
&lt;td&gt;Harbor의 인증서와 키를 생성하는 데 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;네트워크-포트&#34;&gt;네트워크 포트&lt;/h3&gt;
&lt;p&gt;Harbor를 사용하려면 호스트에서 다음 포트가 열려 있어야 한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;포트&lt;/th&gt;
&lt;th&gt;프로토콜&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;443&lt;/td&gt;
&lt;td&gt;HTTPS&lt;/td&gt;
&lt;td&gt;Harbor 포털과 코어 API는 이 포트에서 HTTPS 요청을 수락한다.&lt;br&gt;이 포트는 구성 파일에서 변경할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4443&lt;/td&gt;
&lt;td&gt;HTTPS&lt;/td&gt;
&lt;td&gt;Harbor의 Docker Content Trust 서비스에 연결하는데 사용된다.&lt;br&gt;Notary가 활성화된 경우에만 필요하다.&lt;br&gt;이 포트는 구성 파일에서 변경할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;Harbor 포털과 코어 API는 이 포트에서 HTTP 요청을 수락한다.&lt;br&gt;이 포트는 구성 파일에서 변경할 수 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;harbor-라이센스&#34;&gt;Harbor 라이센스&lt;/h2&gt;
&lt;p&gt;Harbor의 라이센스는 &amp;lsquo;Apache 라이센스 버전 2&amp;rsquo;(Apache License version2)라는 라이센스에 근거하여 공개되며, 영리, 비영리를 불문하고 누구나 자유롭고 무료로 이용, 변경, 재배포할 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://goharbor.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Harbor 공식 사이트&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://demo.goharbor.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Harbor 최신판 LiveDemo&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/goharbor/harbor/wiki/Video-demos-for-Harbor&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Harbor 기능 VideoDemos&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://velog.io/@tkfrn4799/harbor-private-docker-registry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Harbor를 이용한 Private Docker Registry 구축&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wookiist.dev/126&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;[DevOps] Docker-Compose를 이용해 Harbor 배포하기(HTTPS 지원)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>Harbor</category>
      
      <category>Cloud-Native</category>
      
      <category>Docker</category>
      
    </item>
    
  </channel>
</rss>
