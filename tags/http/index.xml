<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>devkuma – HTTP</title>
    <link>https://www.devkuma.com/tags/http/</link>
    <image>
      <url>https://www.devkuma.com/tags/http/logo/180x180.jpg</url>
      <title>HTTP</title>
      <link>https://www.devkuma.com/tags/http/</link>
    </image>
    <description>Recent content in HTTP on devkuma</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <managingEditor>redfreek2c@gmail.com (kimkc)</managingEditor>
    <webMaster>redfreek2c@gmail.com (kimkc)</webMaster>
    <copyright>The devkuma</copyright>
    
	  <atom:link href="https://www.devkuma.com/tags/http/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>HTTP 소개</title>
      <link>https://www.devkuma.com/docs/http/overview/</link>
      <pubDate>Tue, 06 Nov 2018 01:34:33 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/overview/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http-개요&#34;&gt;HTTP 개요&lt;/h2&gt;
&lt;p&gt;HTTP(HyperText Transfer Protocol)는 WWW에서 웹 서버와 클라이언트(브라우저)간에 데이터(웹페이지 등)를 송수신하기 위한 프로토콜이다.
기본적으로 텍스트 메시지 리소스를 교환하고, 그 밖에 다양한 리소스(.jpeg 등)도 교환 가능하다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP로 구성된 프로토콜이다.&lt;/li&gt;
&lt;li&gt;HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이다.&lt;/li&gt;
&lt;li&gt;Method, Path, Version, Headers, Body 등으로 구성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP 버전에 따라에 아래의 사양서가 공개되어 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ietf.org/rfc/rfc1945.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC1945 (HTTP/1.0)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/rfc/rfc2616.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC2616 (HTTP/1.1)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/rfc/rfc7540.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC7540 (HTTP/2)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http-messages&#34;&gt;HTTP Messages&lt;/h2&gt;
&lt;p&gt;HTTP 메시지에는 두 가지 유형이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 요청 메시지: 클라이언트가 서버에 리소스를 요청한다.&lt;/li&gt;
&lt;li&gt;HTTP 응답 메시지: 서버가 클라이언트에 HTTP 요청의 결과를 응답한다.&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTP Request (요청)</title>
      <link>https://www.devkuma.com/docs/http/request/</link>
      <pubDate>Tue, 06 Nov 2018 01:34:33 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/request/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http-requset-messages-요청-메시지&#34;&gt;HTTP Requset messages (요청 메시지)&lt;/h2&gt;
&lt;p&gt;브라우저에서 웹 페이지를 열게 되면, 브라우저는 서버에 다음과 같은 요청 메시지를 보낸다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Accept&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;image/gif, image/jpeg, */*&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Accept-Language&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ko&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Accept-Encoding&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;gzip, deflate&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;User-Agent&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Mozilla/4.0 (Compatible; MSIE 6.0; Windows NT 5.1;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Host&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;www.xxx.zzz&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Connection&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Keep-Alive&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;요청 메시지는 다음과 같은 구문으로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP Request line(요청 라인)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET / HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTTP Request Header(요청 헤더)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept: image/gif, image/jpeg, */*
Accept-Language: ko
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (Compatible; MSIE 6.0; Windows NT 5.1;)
Host: www.xxx.zzz
Connection: Keep-Alive
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTTP Body(본문)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;메세지 본문(POST 메소드 등을 사용)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;start-line-요청-시작-라인&#34;&gt;Start line (요청 시작 라인)&lt;/h2&gt;
&lt;p&gt;HTTP 요청의 시작 줄에는 다음 세 가지 요소가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 메소드&lt;/li&gt;
&lt;li&gt;요청 대상(경로 이름)&lt;/li&gt;
&lt;li&gt;HTTP 프로토콜 버전&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;요청 라인은 다음 형식으로 표시된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;요청 라인&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[HTTP 메소드] [요청 대상] [HTTP 프로토콜 버전]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;경로명은 보통 &amp;ldquo;/aaa/bbb/ccc.html&amp;quot;와 같고, 슬래시로 시작되는 패스명이나, &amp;ldquo;http://&amp;ldquo;으로 시작되는 URL가 지정된다. 버전은 현재 1.1이 보통 사용된다.&lt;/p&gt;
&lt;h3 id=&#34;http-method-메소드&#34;&gt;HTTP Method (메소드)&lt;/h3&gt;
&lt;p&gt;HTTP/1.0, HTTP/1.1에서 지원되는 메소드는 아래와 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;메소드&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP/1.0&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;HTTP/1.1&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;◎&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;◎&lt;/td&gt;
&lt;td&gt;가장 일반적으로 사용되는 메소드이다. 브라우저는 서버에 페이지를 검색하도록 요청한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;◎&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;◎&lt;/td&gt;
&lt;td&gt;헤더 전용 정보를 요청한다. 서버는 GET 메소드와 HEAD 메소드는 반드시 지원해야 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;&lt;code&gt;method=&amp;quot;POST&amp;quot;&lt;/code&gt;를 지정한 폼에 입력한 데이터를 서버에 전송할 때 사용된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PUT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;지정된 자원을 삭제할 것을 서버에 요구한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CONNECT&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;프록시 서버를 경유해 SSL 통신할 때 등에 사용한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OPTIONS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;서버가 서포트하고 있는 메소드나 옵션을 조회할 때에 이용한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRACE&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;HTTP 요청이 어느 프록시 서버를 경유해 송신되는지 등, HTTP의 동작을 추적할 때에 이용한다. 이 메시지를 받은 마지막 서버는 요청 메시지에 포함된 엔티티(일반적으로 헤더 + 메시지 본문)를 그대로 반환한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LINK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td&gt;지정한 URL과 리소스에 링크 관계를 연결한다. HTTP/1.1에서는 더 이상 사용되지 않는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UNLINK&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td&gt;지정된 URL과 자원 간의 링크 관계를 해제한다. HTTP/1.1에서는 더 이상 사용되지 않는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;(◎: 필수, ○: 서포트, ×: 미지원)&lt;/p&gt;
&lt;p&gt;Apache는 위 이외에도 PATCH, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK 등의 메소드를 지원하고 있다.&lt;/p&gt;
&lt;h4 id=&#34;get&#34;&gt;GET&lt;/h4&gt;
&lt;p&gt;GET 요청 방식은 URI(URL)가 가진 정보를 검색하기 위해 서버 측에 요청하는 형태이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET [request-uri]?query_string  
HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n   
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;post&#34;&gt;POST&lt;/h4&gt;
&lt;p&gt;POST 요청 방식은 요청 URI(URL)에 폼 입력을 처리하기 위해 구성한 서버 측 스크립트(ASP, PHP, JSP 등) 혹은 CGI 프로그램으로 구성되고 Form Action과 함께 전송되는데, 이때 헤더 정보에 포함되지 않고 데이터 부분에 요청 정보가 들어가게 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;POST [request-uri]?query_string  
HTTP/1.1\r\n  
HOST:[Hostname] 혹은 [IP] \r\n  
Content-Lenght:[Lenght in Bytes] \r\n  
\r\n  
[query-string] 혹은 [데이터]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;head&#34;&gt;HEAD&lt;/h4&gt;
&lt;p&gt;HEAD 요청 방식은 GET과 유사한 방식이나 웹 서버에서 헤더 정보 이외에는 어떤 데이터도 보내지 않는다.&lt;br&gt;
웹 서버의 다운 여부 점검(Health Check)이나 웹 서버 정보(버전 등)등을 얻기 위해 사용될 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HEAD [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;options&#34;&gt;OPTIONS&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc2616#section-9.2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rfc2616&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;br&gt;
해당 메소드를 통해 시스템에서 지원되는 메소드 종류를 확인할 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;OPTIONS [request-ri]  
HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;put&#34;&gt;PUT&lt;/h4&gt;
&lt;p&gt;POST와 유사한 전송 구조를 가지기 때문에 헤더 이외에 메시지(데이터)가 함께 전송된다.&lt;br&gt;
원격지 서버에 지정한 콘텐츠를 저장하기 위해 사용되며 홈페이지 변조에 많이 악용되고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PUT [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n  
Content-Lenght:[Length in Bytes] \r\n  
Content-Type:[Content Type] \r\n  
\r\n  
[데이터] 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;patch&#34;&gt;PATCH&lt;/h4&gt;
&lt;p&gt;PUT과 유사하게 요청된 자원을 수정(UPDATE)할 때 사용한다.&lt;br&gt;
PUT의 경우 자원 전체를 갱신하는 의미지만, PATCH는 해당자원의 일부를 교체하는 의미로 사용된다. 즉, 리소스를 부분적으로 변경한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PATCH [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP]\r\n  
Content-Lenght:[Length in Bytes]\r\n  
Content-Type:[Content Type]\r\n  
\r\n  
[데이터] 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;delete&#34;&gt;DELETE&lt;/h4&gt;
&lt;p&gt;원격지 웹 서버에 파일을 삭제하기 위해 사용되며 PUT과는 반대 개념의 메소드이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DELETE [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n  
\r\n 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;trace&#34;&gt;TRACE&lt;/h4&gt;
&lt;p&gt;원격지 서버에 Loopback(루프백) 메시지를 호출하기 위해 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TRACE [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n  
\r\n 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;connect&#34;&gt;CONNECT&lt;/h4&gt;
&lt;p&gt;웹 서버에 프락시 기능을 요청할 때 사용된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;전송 형태&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CONNECT [request-uri] HTTP/1.1\r\n  
Host: [Hostname] 혹은 [IP] \r\n  
\r\n 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;요청-대상경로-이름&#34;&gt;요청 대상(경로 이름)&lt;/h3&gt;
&lt;p&gt;요청 대상은 URL, 경로, 쿼리 문자열 등을 포함한다.&lt;/p&gt;
&lt;p&gt;이하의 굵은 문장이 &amp;ldquo;요청 대상&amp;quot;에 해당한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;요청 대상 형식&lt;/th&gt;
&lt;th&gt;형식 예&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;origin form&lt;/td&gt;
&lt;td&gt;- POST / HTTP/1.1&lt;br&gt;- GET /background.png HTTP/1.0&lt;br&gt;- HEAD /test.html?query=alibaba HTTP/1.1&lt;br&gt;- OPTIONS /anypage.html HTTP/1.0&lt;/td&gt;
&lt;td&gt;일반적인 형식&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;absolute form&lt;/td&gt;
&lt;td&gt;GET &lt;a href=&#34;http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; HTTP/1.1&lt;/td&gt;
&lt;td&gt;프록시로 GET 할 때 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;authority form&lt;/td&gt;
&lt;td&gt;CONNECT developer.mozilla.org:80 HTTP/1.1&lt;/td&gt;
&lt;td&gt;CONNECT에서 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asterisk form&lt;/td&gt;
&lt;td&gt;OPTIONS * HTTP/1.1&lt;/td&gt;
&lt;td&gt;OPTIONS에서 사용&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;http-프로토콜-버전&#34;&gt;HTTP 프로토콜 버전&lt;/h3&gt;
&lt;p&gt;HTTP 버전을 나타낸다. 일반적으로 HTTP/1.1 or 2.0 이다.&lt;/p&gt;
&lt;h2 id=&#34;http-header-요청-헤더&#34;&gt;HTTP Header (요청 헤더)&lt;/h2&gt;
&lt;p&gt;요청 헤더에는 세 가지 유형이 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;헤더 유형&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;예&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;응답 헤더&lt;/td&gt;
&lt;td&gt;요청 본문의 데이터와 관련이 없는 헤더&lt;/td&gt;
&lt;td&gt;- Host&lt;br&gt;- User-Agent&lt;br&gt;- Accept -&lt;em&gt;&lt;br&gt;- If-&lt;/em&gt;&lt;br&gt;- Referer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반 헤더&lt;/td&gt;
&lt;td&gt;검색할 리소스&lt;/td&gt;
&lt;td&gt;- Date&lt;br&gt;- Cache-Control&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;엔티티 헤더&lt;/td&gt;
&lt;td&gt;요청 본문에 적용&lt;/td&gt;
&lt;td&gt;- Content-Type&lt;br&gt;- Content-Length&lt;br&gt;- Expires&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;http-body-요청-본문&#34;&gt;HTTP Body (요청 본문)&lt;/h2&gt;
&lt;p&gt;HTTP 요청 본문은 요청에서 보낼 데이터이다.&lt;br&gt;
일반적으로 &amp;lsquo;GET&amp;rsquo;, &amp;lsquo;HEAD&amp;rsquo;, &amp;lsquo;DELETE&amp;rsquo;, &amp;lsquo;OPTIONS&amp;rsquo;에는 요청 본문이 없다. (리소스를 조회하거나 삭제하는 경우에만 사용한다.)&lt;br&gt;
요청 본문은 POST, PUT 등으로 리소스에 데이터를 전송하는 경우에 이용한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;요청 본문 확인&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% curl --trace-ascii - http://www.devkuma.com/ -XPOST -d &amp;#39;user=kimkc,password=1234&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;=&amp;gt; Send data, 24 bytes (0x18)
0000: user=kimkc,password=1234
&lt;/code&gt;&lt;/pre&gt;
      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTP Response (응답)</title>
      <link>https://www.devkuma.com/docs/http/response/</link>
      <pubDate>Tue, 06 Nov 2018 01:34:33 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/response/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http-response-messages-응답-메시지&#34;&gt;HTTP Response messages (응답 메시지)&lt;/h2&gt;
&lt;p&gt;서버는 요청이 들어오면 다음과 같은 응답 메시지를 반환한다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#0000cf;font-weight:bold&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#c00;font-weight:bold&#34;&gt;OK&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Date&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Sun, 11 Jan 2014 16:06:23 GMT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Server&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Apache/1.3.22 (Unix) (Red-Hat/Linux)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Last-Modified&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Sun, 07 Dec 2013 12:34:18 GMT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;ETag&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;&amp;#34;1dba6-131b-3fd31e4a&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Accept-Ranges&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;bytes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Content-Length&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4891&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Keep-Alive&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;timeout=15, max=100&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Connection&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;Keep-Alive&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000&#34;&gt;Content-Type&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;text/html&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;html&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;html&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;응답 메시지는 다음 구문으로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;응답 행(Response line) 또는 상태 행(Status line)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTTP 응답 헤더 (HTTP Response Header)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Date: Sun, 11 Jan 2014 16:06:23 GMT
Server: Apache/1.3.22 (Unix) (Red-Hat/Linux)
Last-Modified: Sun, 07 Dec 2013 12:34:18 GMT
ETag: &amp;#34;1dba6-131b-3fd31e4a&amp;#34;
Accept-Ranges: bytes
Content-Length: 4891
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;빈 라인(blank line) : (헤더의 끝을 의미함)&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CR LF
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;HTTP 본문 (HTTP Body)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;html&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;html&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;줄 바꿈 코드는 Windows 형식의&lt;code&gt;CR LF(&amp;quot;\r\n&amp;quot;)&lt;/code&gt;이다. 첫 번째 라인에는 요청 행 또는 응답 행이 있고, 헤더는 여러 라인이 있고, 빈 라인은 한 라인이 있고, 메시지 바디는 여러 라인이다.&lt;/p&gt;
&lt;h2 id=&#34;start-line-응답-시작-라인&#34;&gt;Start line (응답 시작 라인)&lt;/h2&gt;
&lt;p&gt;HTTP 응답의 시작 라인(상태 라인)에는 다음 세 가지 요소가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 프로토콜 버전 (HTTP 요청 메시지와 동일)&lt;/li&gt;
&lt;li&gt;Response Status Code (응답 상태 코드)&lt;/li&gt;
&lt;li&gt;상태 문자열&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후에는 특히 중요한 &amp;ldquo;HTTP 응답 상태 코드&amp;quot;와 &amp;ldquo;상태 문자열&amp;quot;에 대해 설명한다.&lt;/p&gt;
&lt;p&gt;응답 시작 라인은 다음 형식으로 표시된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시작 라인:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[HTTP 프로토콜 버전] [응답 상태 코드] [상태 문자열]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;상태 문자열는 OK 및 Not Found와 같은 상태 번호의 의미와 세부 정보를 보완하는 메시지를 반환한다.&lt;/p&gt;
&lt;p&gt;실제 예제로 시작 라인을 확인해 보자.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시작 라인 확인:&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% curl http://google.com/ --head
HTTP/1.1 301 Moved Permanently
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;HTTP 프로토콜 버전 : HTTP/1.1&lt;/li&gt;
&lt;li&gt;응답 상태 코드 : 301&lt;/li&gt;
&lt;li&gt;상태 문자열 : Moved Permanently&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-프로토콜-버전&#34;&gt;HTTP 프로토콜 버전&lt;/h3&gt;
&lt;p&gt;HTTP 요청 메시지와 동일하게 HTTP 버전을 나타낸다. 일반적으로 HTTP/1.1 or 2.0 이다.&lt;/p&gt;
&lt;h3 id=&#34;response-status-code응답-상태-코드와-상태-문자열&#34;&gt;Response Status Code(응답 상태 코드)와 상태 문자열&lt;/h3&gt;
&lt;p&gt;HTTP/1.1 상태 코드 정의는 &lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc2616&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 2616&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;에 규정되어 있는데 간단히 정리하면 다음과 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;응답 코드&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1xx&lt;/td&gt;
&lt;td&gt;Informational&lt;/td&gt;
&lt;td&gt;정보 제공&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2xx&lt;/td&gt;
&lt;td&gt;Successful&lt;/td&gt;
&lt;td&gt;성공 응답&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3xx&lt;/td&gt;
&lt;td&gt;Rediection&lt;/td&gt;
&lt;td&gt;추가작업(리디렉션)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4xx&lt;/td&gt;
&lt;td&gt;Client Error&lt;/td&gt;
&lt;td&gt;클라이언트측 오류&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5xx&lt;/td&gt;
&lt;td&gt;Server Error&lt;/td&gt;
&lt;td&gt;서버측 오류&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1xx, 2xx, 3xx 코드는 서버와 User Agent간의 상태를 표시한 것이기 때문에 일반 사용자가 그 내용을 볼 수 없지만,
4xx, 5xx 코드는 일반 사용자도 흔히 볼 수 있는 내용이다.&lt;/p&gt;
&lt;p&gt;어떤 이유로든 웹 페이지가 브라우저 상에 정상적으로 뜨지 않는다면 이는 3xx, 4xx 오류에 해당한다. 때문에 오류의 원인을 이해하고 이를 복구하기 위해서는 오류코드가 의미하는 바를 잘 대충이라도 알아야 한다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;응답 코드&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;클라이언트로 부터 일부 요청을 받았으며 나머지 정보를 계속 요청한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;101&lt;/td&gt;
&lt;td&gt;Switching protocols&lt;/td&gt;
&lt;td&gt;프로토콜 전환. 요청자가 서버에 프로토콜 전환을 요청했으며 서버는 이를 승인하는 중이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;요청이 성공적으로 수행되었다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;성공적으로 요청되었으며, 서버가 새 리소스를 작성하였다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;202&lt;/td&gt;
&lt;td&gt;Accepted&lt;/td&gt;
&lt;td&gt;웹 서버가 요청을 접수했지만 아직 처리하지 않았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;203&lt;/td&gt;
&lt;td&gt;Non-authoritative information&lt;/td&gt;
&lt;td&gt;신뢰할 수 없는 정보, 서버가 요청을 성공적으로 처리되었지만 다른 소스에서 수신된 정보를 제공하고 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;204&lt;/td&gt;
&lt;td&gt;No content&lt;/td&gt;
&lt;td&gt;콘텐츠 없음. 서버가 요청을 성공적으로 처리했지만 콘텐츠를 제공하지 않았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;205&lt;/td&gt;
&lt;td&gt;Reset Content&lt;/td&gt;
&lt;td&gt;콘텐츠 재설정. 서버가 요청을 성공적으로 처리했지만 콘텐츠를 제공하지 않았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial content&lt;/td&gt;
&lt;td&gt;일부 콘텐츠. 서버가 GET요청의 일부만 성공적으로 처리했다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;300&lt;/td&gt;
&lt;td&gt;Multiple Choices&lt;/td&gt;
&lt;td&gt;컨텐츠를 얻는 방법에 대한 여러 가지 옵션이 있다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved permanently&lt;/td&gt;
&lt;td&gt;요구한 데이터를 변경된 타 URL에 요청하였다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Not temporarily&lt;/td&gt;
&lt;td&gt;요구한 데이터를 변경된 임시 URL에서 찾았음&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;Not modified&lt;/td&gt;
&lt;td&gt;업데이트되지 않았고, 컴퓨터 로컬의 캐시 정보를 이용하였다. 보통 gif 등은 웹 서버에 요청하지 않았다. If-Modified-Since 헤더를 사용했을 경우에 반환된다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;305&lt;/td&gt;
&lt;td&gt;Use Proxy&lt;/td&gt;
&lt;td&gt;Location&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;306&lt;/td&gt;
&lt;td&gt;(Unused)&lt;/td&gt;
&lt;td&gt;미사용.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;307&lt;/td&gt;
&lt;td&gt;Temporary Redirect&lt;/td&gt;
&lt;td&gt;다른 위치로 일시적으로 이동 중이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad request&lt;/td&gt;
&lt;td&gt;요청이 잘못되었다. 사용자의 잘못된 요청을 처리할 수 없다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;인증되지 않았다. 인증이 필요한 페이지를 요청한 경우에 발생한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;402&lt;/td&gt;
&lt;td&gt;Payment required&lt;/td&gt;
&lt;td&gt;예약됨. 지불이 필요하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;액세스가 허용되지 않는다. 접근 금지(디렉터리 리스팅 요청 및 관리자 페이지 접근 등을 차단).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not found&lt;/td&gt;
&lt;td&gt;요청한 페이지가 없다. 찾을 수 없다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method not allowed&lt;/td&gt;
&lt;td&gt;허용되지 않는 HTTP Method 사용하였다. 지정한 메소드는 지원되지 않는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;407&lt;/td&gt;
&lt;td&gt;Proxy authentication required&lt;/td&gt;
&lt;td&gt;프록시 인증이 필요하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;408&lt;/td&gt;
&lt;td&gt;Request timeout&lt;/td&gt;
&lt;td&gt;요청이 시간 초과 되었다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;410&lt;/td&gt;
&lt;td&gt;Gone&lt;/td&gt;
&lt;td&gt;영구적으로 사용 금지. 요청한 콘텐츠가 사라졌다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;411&lt;/td&gt;
&lt;td&gt;Length Required&lt;/td&gt;
&lt;td&gt;Content-Length 헤더를 추가하여 요청해라.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;412&lt;/td&gt;
&lt;td&gt;Precondition failed&lt;/td&gt;
&lt;td&gt;전체 조건 실패. If-&amp;hellip; 헤더에 지정된 조건에 부합하지 않았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;414&lt;/td&gt;
&lt;td&gt;Request-URI too long&lt;/td&gt;
&lt;td&gt;요청 URL 길이가 긴 경우임&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;415&lt;/td&gt;
&lt;td&gt;Unsupported Media Type&lt;/td&gt;
&lt;td&gt;지원되지 않는 미디어 유형이다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;416&lt;/td&gt;
&lt;td&gt;Requested Range Not Satisfiable&lt;/td&gt;
&lt;td&gt;요청한 범위가 잘못되었다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;417&lt;/td&gt;
&lt;td&gt;Expectation Failed&lt;/td&gt;
&lt;td&gt;Expect 헤더에 지정된 확장 요청이 실패했다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal server error&lt;/td&gt;
&lt;td&gt;내부 서버 오류. 서버에서 예기치 않은 오류가 발생하였다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;501&lt;/td&gt;
&lt;td&gt;Not implemented&lt;/td&gt;
&lt;td&gt;웹 서버가 처리할 수 없다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;게이트웨이가 잘못되었다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;503&lt;/td&gt;
&lt;td&gt;Service unnailable&lt;/td&gt;
&lt;td&gt;서비스 제공 불가. 서비스는 사용할 수 없다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;504&lt;/td&gt;
&lt;td&gt;Gateway timeout&lt;/td&gt;
&lt;td&gt;게이트웨이가 시간 초과되었다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;505&lt;/td&gt;
&lt;td&gt;HTTP version not supported&lt;/td&gt;
&lt;td&gt;해당 HTTP 버전 지원되지 않는다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;http-header-응답-헤더&#34;&gt;HTTP Header (응답 헤더)&lt;/h2&gt;
&lt;p&gt;응답 헤더에는 다음 세 가지 유형이 있다&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;헤더 유형&lt;/th&gt;
&lt;th&gt;설명&lt;/th&gt;
&lt;th&gt;예&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;응답 헤더&lt;/td&gt;
&lt;td&gt;응답 본문의 데이터와 관련이 없는 헤더&lt;/td&gt;
&lt;td&gt;- Location&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;일반 헤더&lt;/td&gt;
&lt;td&gt;검색할 리소스&lt;/td&gt;
&lt;td&gt;- Date&lt;br&gt;- Cache-Control&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;엔티티 헤더&lt;/td&gt;
&lt;td&gt;응답 본문에 적용&lt;/td&gt;
&lt;td&gt;- Content-Type&lt;br&gt;- Content-Length&lt;br&gt;- Expires&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;http-body-응답-본문&#34;&gt;HTTP Body (응답 본문)&lt;/h2&gt;
&lt;p&gt;리소스(파일)의 내용을 포함한다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;% curl http://www.devkuma.com
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;html &lt;span style=&#34;color:#000&#34;&gt;lang&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;ko&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;head&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTP Header (헤더)</title>
      <link>https://www.devkuma.com/docs/http/header/</link>
      <pubDate>Tue, 06 Nov 2018 01:34:33 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/header/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http-header-헤더&#34;&gt;HTTP Header (헤더)&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;카테고리&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;요청&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;응답&lt;/th&gt;
&lt;th&gt;헤더&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;일반 헤더&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;Cache-Control, Connection, Date, Pragma, Trailer,Transfer-Encoding, Upgrade, Via, Warning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;요청 헤더&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td&gt;Accept, Accept-Charset, Accept-Encoding, Accept-Language, Authorization, Expect, From, Host, If-Match,&lt;br&gt;If-Modified-Since, If-None-Match, If-Range, If-Unmodified-Since, Max Forwards, Proxy-Authorization, Range,&lt;br&gt;Referer, TE, User-Agent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;응답 헤더&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;×&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;Accept-Ranges, Age, ETag, Location, Proxy-Authenticate, Retry-After, Server, Vary, WWW-Authenticate&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;요소 헤더&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;○&lt;/td&gt;
&lt;td&gt;Allow, Content-Encoding, Content-Language, Content-Length, Content-Location, Content-MD5, Content-Range,&lt;br&gt;Content-Type, Expires, Last-Modified, extension-header&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;accept-요청&#34;&gt;Accept (요청)&lt;/h3&gt;
&lt;p&gt;브라우저가 수신할 수 있는 데이터 형식(MIME 타입)을 서버에 전달한다. 별표(*)는 &amp;ldquo;모두&amp;quot;를 의미한다. 다음은 브라우저가 GIF, JPEG 및 기타 모든 형식의 데이터를 수신할 수 있음을 보여준다. (→ &lt;a href=&#34;#content-type-%ec%9a%94%ec%b2%ad%ec%9d%91%eb%8b%b5&#34;&gt;Content-Type&lt;/a&gt;)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept: image/gif, image/jpeg, */*
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;accept-charset-요청&#34;&gt;Accept-Charset (요청)&lt;/h3&gt;
&lt;p&gt;브라우저가 수신 가능한 문자 세트를 서버에 전달한다. 다음은 브라우저가 iso-8859-5, euc-kr만 수신할 수 있다를 뜻한다. (→ &lt;a href=&#34;#content-type-%ec%9a%94%ec%b2%ad%ec%9d%91%eb%8b%b5&#34;&gt;Content-Type&lt;/a&gt;)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept-Charset: iso-8859-5, euc-kr
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;accept-encoding-요청&#34;&gt;Accept-Encoding (요청)&lt;/h3&gt;
&lt;p&gt;브라우저가 수신 가능한 인코딩 방식을 서버에 전달한다. 예를 들어, 브라우저가 gzip 형식을 서포트하고 있는 것을 서버에 전하면, 서버는 메세지 본문을 자동적으로 gzip 압축해 브라우저에 보내서 브라우저에 이를 자동적으로 해제하여 화면에 표시한다. 이러한 기능으로 의해, 통신 부하를 저감하는 것이 가능하다. (→ Content-Encoding )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept-Encoding: gzip, deflate
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;accept-language-요청&#34;&gt;Accept-Language (요청)&lt;/h3&gt;
&lt;p&gt;브라우저가 수신 가능한 언어를 서버에 전달한다. 아래는 브라우저가 한국어만 수신할 수 있음을 의미한다. (→ Content-Language )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept-Language: ko
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;accept-ranges-응답&#34;&gt;Accept-Ranges (응답)&lt;/h3&gt;
&lt;p&gt;Range 요청에서 사용 가능한 단위를 클라이언트에 전달한다. 현재 정의되어 있는 것은 bytes 뿐이다. (→ Range, Content-Range )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Accept-Ranges: bytes
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;age-응답&#34;&gt;Age (응답)&lt;/h3&gt;
&lt;p&gt;엔티티가 생성된 이후의 예상 경과 시간(초)을 나타낸다. 아래의 예에서는, 이 엔티티가 아마, 프록시 서버로 30초간 유지된 것, 즉, 30초 정도 오래된 데이터인 것을 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Age: 30
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;allow-요청응답&#34;&gt;Allow (요청/응답)&lt;/h3&gt;
&lt;p&gt;요청 URL에 표시된 리소스에 사용할 수 있는 메서드 목록을 제공한다. 다음 예제에서는 이 리소스에 대해 GET, HEAD, PUT 메서드를 사용할 수 있음을 보여 준다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Allow: GET, HEAD, PUT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;authorization-요청&#34;&gt;Authorization (요청)&lt;/h3&gt;
&lt;p&gt;인증이 필요한 자원에 대한 인증 정보를 전달한다. 예를 들어, BASIC 인증의 경우는, Basic 의 문자와, 유저명과 패스워드를 콜론(:)으로 연결한 것을 BASE64 형식에 encode 한 것을 전송한다. (→ WWW-Authenticate )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Authorization: Basic dGFuYWthOmhpbWl0c3U=
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cache-control-요청응답&#34;&gt;Cache-Control (요청/응답)&lt;/h3&gt;
&lt;p&gt;캐시에 관한 지시를 나타낸다. 다음 예제는 프록시 서버와 클라이언트가 이 리소스를 캐시해서는 안 됨을 보여준다. HTTP/1.0에서는 Pragma: no-cache가 사용된다. (→ Pragma )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Cache-Control: no-cache
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;connection-요청응답&#34;&gt;Connection (요청/응답)&lt;/h3&gt;
&lt;p&gt;HTTP/1.1에서 지원되는 지속 연결 기능을 브라우저가 지원하는 경우, 그 취지를 상대에게 알린다. 지속적인 연결을 사용하면 단일 연결에서 여러 요청/응답을 발행할 수 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Connection: Keep-Alive
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;지속 연결을 완료하면 서버는 close를 반환한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Connection: close
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그 외에도 서버 프록시 간, 프록시 클라이언트 간과 같은 직접 연결에만 유효한 헤더 목록을 표시하는데 사용된다. 프록시 서버는 이 헤더로 지정된 헤더 정보를 삭제해, 전송하지 않으면 안된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Connection: Upgrade
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-encoding-요청응답&#34;&gt;Content-Encoding (요청/응답)&lt;/h3&gt;
&lt;p&gt;콘텐츠 인코딩 방법을 나타낸다. 다음은 콘텐츠가 gzip 형식으로 압축되었음을 나타낸다. (→ Accept-Encoding )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-language-요청응답&#34;&gt;Content-Language (요청/응답)&lt;/h3&gt;
&lt;p&gt;컨텐츠의 언어를 en(영어), ko(한국어) 등으로 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Language: ko
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-length-요청응답&#34;&gt;Content-Length (요청/응답)&lt;/h3&gt;
&lt;p&gt;컨텐츠(=메시지 본체)의 길이를 바이트 단위로 나타낸다. 헤더와 메시지 본문 사이의 줄 바꿈 바이트 수는 제외한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Length: 4891
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-location-요청응답&#34;&gt;Content-Location (요청/응답)&lt;/h3&gt;
&lt;p&gt;컨텐츠가 다른 URL에서도 액세스 가능할 때, 그 엔티티의 URL를 절대 URL 또는 상대 URL 로 나타낸다. (→ Location )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Location: http://xxx.yyy.zzz/index.htm
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-md5-요청응답&#34;&gt;Content-MD5 (요청/응답)&lt;/h3&gt;
&lt;p&gt;콘텐츠가 통신 도중에 변경되지 않았는지 확인하기 위해 콘텐츠에 대한 체크 데이터(128비트 MD5 다이제스트를 BASE64로 인코딩)를 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-MD5: GitH4qFa4GasgWxJs8ha5Q==
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-range-요청응답&#34;&gt;Content-Range (요청/응답)&lt;/h3&gt;
&lt;p&gt;상대에게 보낼 콘텐츠의 범위를 나타낸다. 아래 예에서는 전체 콘텐츠가 12345바이트이고 그 안의 0바이트부터 999바이트까지의 부분을 전송하고 있음을 보여준다. (→ Range , Accept-Ranges )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Range: bytes 0-999/12345
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;content-type-요청응답&#34;&gt;Content-Type (요청/응답)&lt;/h3&gt;
&lt;p&gt;Content-Type 를 MIME 타입으로 나타낸다. MIME 타입은 리소스(파일) 유형을 말한다.&lt;/p&gt;
&lt;p&gt;다음은 콘텐츠의 내용이 텍스트(HTML) 형식임을 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Type: text/html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;또한 문자 코드 (euc-kr, ISO-2022-KR, UTF-8 등)를 나타낼 수도 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Content-Type: text/html; charset=euc-kr
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;응답 헤더을 실제 확인해 보도록 하자.&lt;br&gt;
&lt;strong&gt;Content-Type 응답 헤더&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ curl http://google.com/ --head
...
Content-Type: text/html; charset=UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;문자 코드가 UTF-8인 HTML을 응답했다는 것을 의믜한다.&lt;/p&gt;
&lt;h3 id=&#34;date-요청응답&#34;&gt;Date (요청/응답)&lt;/h3&gt;
&lt;p&gt;응답을 반환하는 시간을 나타낸다. 요일(Sun,)은 선택 사항이다. 날짜는 1 또는 01일 수 있다. 연도는 2자리 또는 4자리일 수 있지만 4자리가 권장된다. 초(:23)는 선택 사항이다. 시간대는 GMT(그리니치 표준시)를 이용하는 경우가 많다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Date: Sun, 04 Jan 2004 16:06:23 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;etag-응답&#34;&gt;ETag (응답)&lt;/h3&gt;
&lt;p&gt;엔티티와 그 버전을 고유하게 식별하는 식별자를 나타낸다. 식별자는 파일 식별자, 크기, 갱신 시간 등의 정보로부터 계산된다. (→ If-Match , If-None-Match , If-Range )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ETag: &amp;#34;1dba6-131b-3fd31e4a&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;expect-요청&#34;&gt;Expect (요청)&lt;/h3&gt;
&lt;p&gt;다양한 목적으로 사용된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Expect: 100-continue
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;expires-요청응답&#34;&gt;Expires (요청/응답)&lt;/h3&gt;
&lt;p&gt;엔티티의 만료 날짜를 표시한다. 만료일이 지난 엔티티는 캐시에서 삭제된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Expires: Thu, 01 Dec 2021 16:00:00 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;from-요청&#34;&gt;From (요청)&lt;/h3&gt;
&lt;p&gt;이 요청을 한 사람의 이메일 주소를 지정한다. 검색 엔진이 로봇으로 탐색하는 경우에, 검색에 관한 문의처의 메일 주소를 통지할 때 등에 이용된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;From: aaa@xxx.yyy.zzz
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;host-요청&#34;&gt;Host (요청)&lt;/h3&gt;
&lt;p&gt;Host 요청 헤더는 요청이 전송되는 서버의 호스트 이름과 포트 번호를 지정한다.&lt;/p&gt;
&lt;p&gt;HTTP/1.1에서 유일한 필수 헤더이다. 브라우저에서 서버로 서버 이름을 보낸다. 서버가 이름 베이스의 가상 호스트를 지원하고 있다면 그 이름으로 어느 서버로서 동작할지 결정된다.&lt;br&gt;
예를 들어, &lt;a href=&#34;http://aaa.devkuma.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://aaa.devkuma.com&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 와 &lt;a href=&#34;http://bbb.devkuma.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://bbb.devkuma.com&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 는 실은 같은 서버(IP 주소: 183.111.100.230)이지만, Host 헤더로 호스트명을 지정하는 것으로, 가상 두 개의 서버로 작동 할 수 있다.&lt;/p&gt;
&lt;p&gt;Host 요청 확인&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% curl www.devkuma.com -v
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt; Host: www.devkuma.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;포트 번호를 지정하지 않으면 요청한 서비스의 기본 포트(예: HTTPS URL이면 443, HTTP URL인 경우 80)로 간주된다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Host&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Host - HTTP | MDN&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;if-match-요청&#34;&gt;If-Match (요청)&lt;/h3&gt;
&lt;p&gt;지정된 ETag와 일치하는 경우에만 메소드를 실행하도록 서버에 요청한다. (→ ETag , If-None-Match)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;If-Match: &amp;#34;1dba6-131b-3fd31e4a&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if-modified-since-요청&#34;&gt;If-Modified-Since (요청)&lt;/h3&gt;
&lt;p&gt;클라이언트측이 벌써 캐쉬를 가지고 있는 경우, 캐쉬의 일자를 서버에 통지해, 「이 일자보다 새로운 것이 있으면 전송해 주세요」라고 요구한다. 업데이트되지 않은 경우 서버는 304 (not modified) 상태를 반환하고 브라우저는 캐시 된 데이터를 표시한다. (→ If-Unmodified-Since)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if-none-match-요청&#34;&gt;If-None-Match (요청)&lt;/h3&gt;
&lt;p&gt;지정한 ETag와 일치하지 않는 경우에만 메소드를 실행할 것을 서버에 의뢰한다. (→ ETag , If-Match)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;If-None-Match: &amp;#34;1dba6-131b-3fd31e4a&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if-range-요청&#34;&gt;If-Range (요청)&lt;/h3&gt;
&lt;p&gt;클라이언트가 엔티티의 일부를 이미 보유하고있는 경우, &amp;ldquo;이 ETag에 지정된 엔티티의 일부가 최신이면 나머지 모든 것을, 그렇지 않으면 전체를 보낸다. &amp;lsquo;의 의미로 요구한다. Range 헤더와 함께 사용한다. (→ ETag , Range)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Range: bytes=0-1023
If-Range: &amp;#34;1dba6-131b-3fd31e4a&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;if-unmodified-since-요청&#34;&gt;If-Unmodified-Since (요청)&lt;/h3&gt;
&lt;p&gt;엔티티가, 지정된 일자보다 나중에 갱신되어 있지 않은 경우, 요구를 처리한다. 업데이트된 경우 서버는 412(Precondition Failed) 상태를 반환한다. (→ If-Modified-Since)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;last-modified-요청응답&#34;&gt;Last-Modified (요청/응답)&lt;/h3&gt;
&lt;p&gt;엔티티가 마지막으로 업데이트된 시간을 나타낸다. (→ If-Modified-Since )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Last-Modified: Sun, 07 Dec 2003 12:34:18 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;location-응답&#34;&gt;Location (응답)&lt;/h3&gt;
&lt;p&gt;Location 응답 헤더는 리디렉션 대상 URL을 나타낸다.&lt;/p&gt;
&lt;p&gt;엔티티 위치가 이동 했을 때, 브라우저가 요구한 URL 과는 다른 URL로 이동시키고 싶은 경우에 사용한다.&lt;br&gt;
URL은 &lt;code&gt;http://&lt;/code&gt; 또는 &lt;code&gt;https://&lt;/code&gt;로 시작하는 절대 URL을 지정한다. (→ Content-Location )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Location: [URL]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Location 응답 헤더&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% curl http://google.com/ --head
...
Location: http://www.google.com/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;위에 예제는 &amp;lsquo;&lt;a href=&#34;http://google.com/%27&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://google.com/&#39;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 대신에 &amp;lsquo;&lt;a href=&#34;http://www.google.com/%27&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.google.com/&#39;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;을 접근해 달라는 것을 뜻한다.&lt;/p&gt;
&lt;h3 id=&#34;max-forwards-요청&#34;&gt;Max-Forwards (요청)&lt;/h3&gt;
&lt;p&gt;OPTIONS 및 TRACE 메소드으로 프록시 서버의 통신 상대에게 도달할 때까지 경유하는 전송·중계 설비의 최대 수를 지정한다. 프록시 서버는 이 값을 하나씩 빼가면서, 다음의 프록시 서버에 전송 한다. 이 값이 0이 되면, 프록시 서버는 마지막 수신자로서 응답을 돌려준다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Max-Forwards: 16
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;pragma-요청응답&#34;&gt;Pragma (요청/응답)&lt;/h3&gt;
&lt;p&gt;다양한 목적으로 사용된다. 예를 들어, 다음은 캐시를 사용하지 않겠다고 프록시 서버나 클라이언트에 전달한다. (→ Cache-Control )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Pragma: no-cache
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;proxy-authenticate-응답&#34;&gt;Proxy-Authenticate (응답)&lt;/h3&gt;
&lt;p&gt;프록시 서버와 클라이언트 간에 인증이 필요함을 나타낸다. (→ Proxy-Authorization , WWW-Authenticate )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Proxy-Authenticate: Basic realm=&amp;#34;XXXXXX&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;proxy-authorization-요청&#34;&gt;Proxy-Authorization (요청)&lt;/h3&gt;
&lt;p&gt;프록시 서버와 클라이언트 사이의 자격 증명을 전달한다. (→ Proxy-Authenticate , Authorization)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Proxy-Authorization: Basic dGFuYWthOmhpbWl0c3U=
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;range-요청&#34;&gt;Range (요청)&lt;/h3&gt;
&lt;p&gt;클라이언트에서 서버로 엔티티의 일부만 요청한다. 아래 예제에서는 페이지의 처음 1000바이트(0바이트에서 999바이트째)만 요청한다. (→ Accept-Ranges , Content-Range , If-Range)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Range: bytes=0-999
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;referer-요청&#34;&gt;Referer (요청)&lt;/h4&gt;
&lt;p&gt;이 요청의 원본이 된 페이지의 URL(일반적으로 링크 소스 URL)을 전달한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Referer: http://xxx.yyy.zzz/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;retry-after-응답&#34;&gt;Retry-After (응답)&lt;/h3&gt;
&lt;p&gt;몇 초 후에 다시 요청해 준다는 의미에서 503(Service Unavailable)이나 3xx(Redirection) 상태와 함께 반환된다. 아래는 120초 후에 다시 요청해 주는 의미를 가진다. Date: 형식의 절대 시간을 반환할 수도 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Retry-After: 120
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;server-응답&#34;&gt;Server (응답)&lt;/h3&gt;
&lt;p&gt;서버로부터 브라우저에 서버 정보를 돌려즌다. 형식은 특별히 규정되지 않는다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Server: Apache/1.3.22 (Unix) (Red-Hat/Linux)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;te-요청&#34;&gt;TE (요청)&lt;/h3&gt;
&lt;p&gt;브라우저가 처리 가능한 확장 전송 코딩 방식 (chunked 등)이나 청크 전송시의 trailer 필드를 해석 가능한가 어떤가를 서버에 전달한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TE: trailers
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;trailer-요청응답&#34;&gt;Trailer (요청/응답)&lt;/h3&gt;
&lt;p&gt;헤더 정보를 컨텐츠의 선두가 아니고, 청크 형식으로 분할 송신된 컨텐츠의 뒤에 부가하는 경우, 거기에 부가된 헤더의 일람을 나타낸다. 이는 CGI가 데이터를 전송한 후 Content-Length 헤더를 추가하려는 경우에 유용한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Trailer: Content-Length
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;transfer-encoding-요청응답&#34;&gt;Transfer-Encoding (요청/응답)&lt;/h3&gt;
&lt;p&gt;전송에 사용되는 인코딩 형식을 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Transfer-Encoding: chunked
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;upgrade-요청응답&#34;&gt;Upgrade (요청/응답)&lt;/h3&gt;
&lt;p&gt;다른 프로토콜을 사용할 것을 권장한다는 것을 상대에게 알린다. 클라이언트 프록시 간과 같은 직접 연결에만 유효한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Upgrade: HTTP/2.0, SHTTP/1.3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;user-agent-요청&#34;&gt;User-Agent (요청)&lt;/h3&gt;
&lt;p&gt;User-Agent는 클라이언트의 응용 프로그램 이름, OS 이름 등을 나타낸다.&lt;br&gt;
브라우저(=사용자 에이전트)의 정보를 서버에 전달한다. 형식은 특별히 규정되지 않는다. 브라우저 유형, 버전, 플랫폼 등의 정보가 포함된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;% curl www.devkuma.com -v
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;gt; User-Agent: curl/7.77.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mac OS에 Chrome으로 요청을 하면 아래와 같이 표시된다. (→ 서버 )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vary-응답&#34;&gt;Vary (응답)&lt;/h3&gt;
&lt;p&gt;Accept , Accept-Charset , Accept-Language 등, 서버 주도형 네고시에이션으로 사용된 헤더 정보를 나타낸다. 이것은 캐시의 유효성을 결정하는 데 유용한다. 예를 들어, 다음 예제에는 Accept-Language가 포함다. 이는 브라우저가 &lt;code&gt;Accept-Language : ko&lt;/code&gt;를 전송했기 때문에 서버가 일본어 콘텐츠를 반환했을 수 있으며 &lt;code&gt;Accept-Language : en&lt;/code&gt;에서 요청하면 다른 콘텐츠가 반환 될 수 있다. 있음을 나타낸다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Vary: Accept-Charset, Accept-Language
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;via-요청응답&#34;&gt;Via (요청/응답)&lt;/h3&gt;
&lt;p&gt;메시지의 전달 경로를 나타낸다. 다음 예는 메시지가 aaa → bbb → ccc라는 프록시를 라우트하여 전달되었음을 보여준다. 1.1은 프로토콜 버전이다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Via: 1.1 aaa, 1.1 bbb, 1.1 ccc
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;warning-요청응답&#34;&gt;Warning (요청/응답)&lt;/h3&gt;
&lt;p&gt;상태 행에 추가되는 경고 코드와 메시지를 전달한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Warning: 110 xxxsv &amp;#34;Response is stale&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;www-authenticate-응답&#34;&gt;WWW-Authenticate (응답)&lt;/h3&gt;
&lt;p&gt;인증이 필요함을 나타낸다. 다음 예제는 이 리소스가 BASIC 인증이라는 HTTP에서 가장 기본적인 방식으로 보호됨을 보여준다. XXXXXX 부분에는 이 인증에 대한 설명문이 들어 있다. (→ Authorization )&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;WWW-Authenticate: Basic realm=&amp;#34;XXXXXX&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;extension-header-요청응답&#34;&gt;extension-header (요청/응답)&lt;/h3&gt;
&lt;p&gt;이외에도, 서버의 구현에 의해 다양한 헤더가 구현되고 있다.&lt;/p&gt;
&lt;h2 id=&#34;가상-호스트&#34;&gt;가상 호스트&lt;/h2&gt;
&lt;p&gt;HTTP/1.1에서는 가상 호스트가 지원된다. HTTP/1.1 의 클라이언트는 Host 헤더로 호스트명을 송신하지 않으면 안된다. 서버는 가상 호스트에 해당하는 컨텐츠를 응답한다. 이를 통해 한 서버에서 여러 웹 사이트를 지원할 수 있다.&lt;/p&gt;
&lt;p&gt;요청&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET / HTTP/1.1
Host: www.devkuma.com
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;지속적인-연결-keep-alive&#34;&gt;지속적인 연결 (Keep-Alive)&lt;/h2&gt;
&lt;p&gt;초기의 HTTP는 HTTP 요청을 보낼 때 마다 새로운 소켓 연결이 맺어졌었다. 이 방법은 효율적이지 못하다.&lt;/p&gt;
&lt;p&gt;지속성 있는 연결(Persistent Connections)은 이렇게 같은 서버에 여러 개의 소켓 연결을 맺는 비효율 문제를 해결하기 위해 HTTP/1.0의 Keep-Alive가 나와 표준이 되었다.&lt;/p&gt;
&lt;p&gt;즉, 하나의 연결 안에 여러 개의 요청을 보내는 것이다. 클라이언트는 아래와 같이 1회의 TCP 접속으로 복수의 컨텐츠를 요구하는 것으로, 통신 퍼포먼스를 향상시킬 수 있다. 지속 접속을 계속하는 경우에는 통상 Connection 헤더로 Keep-Alive 를, 마지막의 요구에는 close 를 지정한다.&lt;/p&gt;
&lt;p&gt;브라우저와 서버는 헤더의 Connetion 속성에 Keep-alive 값을 지정할 수 있다. HTTP/1.1에서는 필요하지 않지만 대부분의 브라우저와 서버는 이 값을 계속 포함하고 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;요청&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET /aaa.html HTTP/1.1
Host: www.devkuma.com.com
Connection: Keep-Alive

GET /bbb.html HTTP/1.1
Host: www.devkuma.com.com
Connection: close
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이에 대해 서버는 Content-Length나 청크(후술)등으로 복수의 컨텐츠의 경계가 명시된 컨텐츠를 돌려준다. timeout 에는 다음의 요구가 오지 않는 경우에 타임 아웃을 발생시키는 시간(초), max 에는 이 지속 접속으로 요구 가능한 요구의 남은 횟수가 지정된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;응답&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234
Keep-Alive: timeout=5, max=100 
Connection: Keep-Alive

(aaa.html 콘텐츠)
HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 1234
Keep-Alive: timeout=5, max=99 
Connection: close

(bbb.html 콘텐츠)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;청크-chunked&#34;&gt;청크 (chunked)&lt;/h2&gt;
&lt;p&gt;CGI 결과 반환에서 콘텐츠를 생성할 때 콘텐츠의 길이를 모르는 경우와 같이 서버는 청크 형식의 데이터를 반환할 수 있다. 청크 형식의 데이터에서 연속 데이터의 바이트 수는 16진수로 표시된다. 0은 데이터의 끝을 의미한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;응답&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/html
Transfer-Encoding: chunked

1234년
(16진수로 1234바이트 데이터)
9ab
(16진수로 9ab 바이트의 데이터)
0
(콘텐츠 종료)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;basic-인증&#34;&gt;BASIC 인증&lt;/h2&gt;
&lt;p&gt;HTTP 베이직 인증을 사용하면 서버는 클라이언트의 요청에 대해 WWW-Authenticate 헤더를 반환한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;응답&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
WWW-Authenticate: Basic realm=&amp;#34;HIMITSU No PAGE&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;클라이언트는 WWW-Authenticate 헤더를 받으면 로그인명과 패스워드의 입력을 촉구하는 다이얼로그를 표시해, 유저가 입력한 로그인명과 패스워드를 encode 하여 다시 컨텐츠 요청을 한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;요청&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Host: www.devkuma.com
Authorization: Basic abcdEFGhiJklM==
&lt;/code&gt;&lt;/pre&gt;
      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTP Cookie (쿠키)</title>
      <link>https://www.devkuma.com/docs/http/cookie/</link>
      <pubDate>Mon, 27 Dec 2021 18:02:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/cookie/</guid>
      <description>
        
        
        &lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;Cookie(쿠키)는 다음과 같은 기능을 만들기 위해 사용한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;방문자가 그 페이지에 몇 번 방문했는지 기록해 표시한다.&lt;/li&gt;
&lt;li&gt;웹서비스에서 방문자의 최근에 방문한 페이지를 기록해 두고, 다음 번 방문시에 그 해당 페이지를 보여주기 위한 용도로 사용한다.&lt;/li&gt;
&lt;li&gt;게시판이나 채팅으로 입력한 사용자명을 기록해 두고, 다음 번 방문시에 사용자명의 입력을 생략한다.&lt;/li&gt;
&lt;li&gt;로그인으로 세션을 유지한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;아래의 사양서가 공개되어 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2109&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC2109&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; (1997년 2월)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc2965&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC2965&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; (2000년 10월)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tools.ietf.org/html/rfc6265&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC6265&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; (2011년 4월)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위와 같은 데이터는 CGI 등을 이용하여 서버 측에 기록하기 도 하지만, 쿠키를 이용함으로써 클라이언트측(브라우저를 기동하는 측)의 하드 디스크에 쿠키 정보 데이터를 기록을 하기도 한다.&lt;/p&gt;
&lt;h2 id=&#34;cookie-정보가-저장되는-폴더-및-파일&#34;&gt;Cookie 정보가 저장되는 폴더 및 파일&lt;/h2&gt;
&lt;p&gt;쿠키 정보가 저장되는 파일은 OS나 브라우저의 버전에 따라 다르다.&lt;/p&gt;
&lt;p&gt;예를 들면, Windows와 같은 경우는 다음과 같은 폴더나 파일에 기록된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- C:\Document and Settings\(UserName)\Cookies
- C:\Program Files\Netscape\Users\(UserName]\cookies.txt
- C:\Program Files\Netscape\Navigator\cookies.txt
- C:\Windows\Cookies\~.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Mac OS에 Chrome인 경우에는 아래 저장된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;- ~/Library/Application Support/Google/Chrome/Default/Cookies
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;cookie-쓰기&#34;&gt;Cookie 쓰기&lt;/h2&gt;
&lt;p&gt;JavaScript를 사용하여 쿠키를 설정할 때는 다음을 수행한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;자바스크립트&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#204a87&#34;&gt;document&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;cookie&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;HTML로 지정하려면 다음을 수행한다. 이 방법은 추천하지 않는 방식이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;meta&lt;/span&gt; &lt;span style=&#34;color:#c4a000&#34;&gt;http-equiv&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;Set-Cookie&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#c4a000&#34;&gt;content&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;~&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;~&lt;/code&gt; 부분에는 다음과 같은 문자열을 지정한다.&lt;/p&gt;
&lt;p&gt;형식&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NAME=값; expires=값; domain=값; path=값; secure
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;NAME=값;&lt;/code&gt; 이외는 선택 사항이다. 각각 다음과 같은 의미가 있다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;매개변수&lt;/th&gt;
&lt;th&gt;의미&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;NAME=값&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;원하는 이름에 원하는 값을 지정한다. 세미콜론(;), 쉼표(,), 공백 문자( ) 또는 한글을 사용할 때는 각각 어떤 형식으로 인코딩해야 한다. 인코딩에는 &lt;code&gt;%3B&lt;/code&gt;, &lt;code&gt;%2C&lt;/code&gt;, &lt;code&gt;%20&lt;/code&gt; 등의 URL 형식의 인코딩이 자주 사용된다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expires=값&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;클라이언트 측에 기록되는 쿠키의 만료일을 &lt;code&gt;Thu, 1-Jan-2030 00:00:00 GMT&lt;/code&gt;와 같은 형식으로 지정한다. 표준 시간대는 항상 GMT로 지정된다. 생략하면 브라우저를 종료 할 때까지 만료된다. 과거 값을 지정하면 쿠키가 삭제된다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;domain=값&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;쿠키를 게시할 웹 서버의 이름을 지정한다. 생략하면 웹서버 이름(예 : &lt;a href=&#34;https://www.devkuma.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.devkuma.com&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;)으로 된다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;path=값&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;여기에서 지정한 경로 이름과 일치하는 페이지를 탐색할 때 브라우저는 저장된 쿠키 정보를 서버로 보낸다. 예를 들어, &lt;code&gt;path=/docs&lt;/code&gt;를 지정하면 &lt;code&gt;/docs&lt;/code&gt;와 일치하는 모든 페이지에 쿠키 정보가 전송된다. 기본적으로 쿠키가 설정된 페이지의 경로 이름 부분이다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;secure&lt;/td&gt;
&lt;td&gt;이 변수를 넣으면, 서버와의 연결이 안전한 경우에만 쿠키 정보가 전송된다.&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;cookie-쓰기-예제&#34;&gt;Cookie 쓰기 예제&lt;/h3&gt;
&lt;p&gt;가장 간단한 쓰기의 예는 다음과 같다. 이것은 브라우저가 끝날 때까지 유효하며, 설정한 페이지와 같은 폴더에 있는(혹은 하위층에 있는) 페이지에 송신된다.
&lt;strong&gt;HTTP Header&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Set-Cookie: NAME=devkuma;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;만료일을 지정은 다음과 같이 한다. 브라우저를 종료하든 OS를 다시 시작하든, 만료일까지 디스크에 계속 저장된다.
&lt;strong&gt;HTTP Header&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Set-Cookie: NAME=devkuma; Tue, 31-Dec-2030 23:59:59;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;cookie-읽기&#34;&gt;Cookie 읽기&lt;/h2&gt;
&lt;p&gt;JavaScript를 사용하여 쿠키 값을 읽으려면 &lt;code&gt;document.cookie&lt;/code&gt; 값을 참조한다. 값에 대한 설명은 위를 참조하여라.&lt;/p&gt;
&lt;p&gt;자바스크립트&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;alert(document.cookie);
&lt;/code&gt;&lt;/pre&gt;
      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTPS</title>
      <link>https://www.devkuma.com/docs/http/https/</link>
      <pubDate>Thu, 18 Aug 2022 18:04:25 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/https/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http와-https&#34;&gt;HTTP와 HTTPS&lt;/h2&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP는 텍스트 교환이고 HTML 페이지도 텍스트이다.&lt;/li&gt;
&lt;li&gt;바이너리 테이터로 되어 있는 것도 아니고, 단순 텍스트를 주고 받기 때문에 누군가 네트워크에서 신호를 가로채어 본다면 내용이 노출된다. 이런 보안상의 문제를 해결해주기 위해 생긴 것이 HTTPS이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;https&#34;&gt;HTTPS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS는 인터넷 상에 정보를 암호화하는 SSL(Secure Soket Layer) 프로토콜을 이용하여 클라이언트와 서버가 데이터를 주고 받는 통신규약이다.&lt;/li&gt;
&lt;li&gt;HTTPS는  HTTP 텍스트를 암호화 하는 것이다.&lt;/li&gt;
&lt;li&gt;HTTPS의 S는 Secure Socket, 보안 통신망을 의마한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;https-암호화-원리&#34;&gt;HTTPS 암호화 원리&lt;/h2&gt;
&lt;p&gt;HTTP의 암호화 원리의 핵심은 공개키 암호화 방식이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;인증서를 발급하여 보내는 메세지를 공개키로 암호화하도록 하고 있다.&lt;/li&gt;
&lt;li&gt;암호화된 메세지는 개인키를 가지고 있어야만 가능하기 때문에, 중간에 누구도 원본 데이터를 얻을 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;https의-특징&#34;&gt;HTTPS의 특징&lt;/h2&gt;
&lt;p&gt;HTTPS는 SSL/TLS 위에서 HTTP 구현되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/https-layer.jpeg&#34; alt=&#34;HTTP,HTTPS Layer&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;주요 기능&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;암호화(Encryption)&lt;/li&gt;
&lt;li&gt;인증(Authentication)&lt;/li&gt;
&lt;li&gt;변경감지 등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;URI Scheme 접두사&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;사용 포트&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URL이 &lt;code&gt;http&lt;/code&gt;가 아닌 &lt;code&gt;https&lt;/code&gt; URI Scheme 접두사를 갖으면, 통상적인 HTTP 80번이 아닌, HTTPS 443번 포트 번호를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;표준&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ietf.org/rfc/rfc2818.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RFC 2818&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ssltls&#34;&gt;SSL/TLS&lt;/h3&gt;
&lt;p&gt;HTTP 통신에서 암호화 방식인 SSL(Secure Sockets Layer)이나 TLS(Transport Layer Security)를 이용함으로써 웹사이트를 안전하게 사용할 수 있다.&lt;/p&gt;
&lt;p&gt;SSL와 TLS은 같은 것이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다.
TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.&lt;/p&gt;
&lt;h2 id=&#34;https-안전-확보의-구조&#34;&gt;HTTPS 안전 확보의 구조&lt;/h2&gt;
&lt;p&gt;SSL/TLS에서는 이하의 3개의 구조에 의해 Web 사이트의 안전성을 확보한다.&lt;/p&gt;
&lt;h3 id=&#34;도청-방지암호화-통신&#34;&gt;도청 방지(암호화 통신)&lt;/h3&gt;
&lt;p&gt;웹사이트 열람에는 몇 대의 서버를 경유하기 때문에, 제3자는 비교적 간단하게 통신 내용을 가로챌 수 있다.&lt;br&gt;
만일 가로채어도 내용을 해독되지 않도록 데이터를 암호화하여 전송함으로써 제3자로부터의 도청을 방지한다.&lt;/p&gt;
&lt;h3 id=&#34;변조-방지&#34;&gt;변조 방지&lt;/h3&gt;
&lt;p&gt;인터넷 쇼핑에서 상품의 개수를 재기록하는 등의 데이터 변조 대책으로서 &amp;ldquo;메시지 다이제스트&amp;quot;가 이용된다.&lt;br&gt;
메시지 다이제스트는 특정 데이터에서 고유한 짧은 데이터(해시 값)를 검색하는 계산입니다. 따라서, 데이터를 송수신 할 때 해시 값을 비교하여 변조를 검출 할 수 있다.&lt;/p&gt;
&lt;h3 id=&#34;스푸핑-방지&#34;&gt;스푸핑 방지&lt;/h3&gt;
&lt;p&gt;Web 서버에 &amp;ldquo;SSL 서버 인증서&amp;quot;라고 하는 전자 인증서를 배치해 두고, 접속시에 검증하는 것으로 Web 사이트 운영자의 신원을 확인할 수 있다.&lt;br&gt;
또, 이 인증서는 발행을 인정된 &amp;ldquo;인증 기간&amp;quot;에 의한 운영자의 인증 작업을 거쳐야 한다. 신뢰할 수 없는 발행원의 인증서가 이용되고 있다면 웹 브라우저상에 경고 화면이 표시된다.&lt;/p&gt;
&lt;h2 id=&#34;https의-보안-작동-방식&#34;&gt;HTTPS의 보안 작동 방식&lt;/h2&gt;
&lt;p&gt;클라이언트(웹브라우저)에서 일반 http가 아닌 https Scheme을 갖는 URL 주소를 입력 받으면, 웹서버에 80번이 아닌 443번 포트번호로 TCP 연결을 하여 바이너리 포멧으로 된 몇몇 보안 매개변수를 교환(핸드세이크, 키 교환)한다. 그러고, 그와 관련된 HTTPS 명령들이 실행하게 된다.&lt;/p&gt;
&lt;h3 id=&#34;https-교환&#34;&gt;HTTPS 교환&lt;/h3&gt;
&lt;p&gt;HTTPS에서의 통신을 시작하기 위해서는 크게 나누어 아래의 4개의 페이즈의 교환을 하게 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;암호화 방식 결정&lt;br&gt;
암호화 방식은 여러가지가 있어서 웹 브라우저와 웹 서버가 모두 이용 가능한 암호화 방식을 결정해야 한다. TLS 버전이나 메시지 다이제스트 방식도 동시에 결정한다.&lt;/li&gt;
&lt;li&gt;통신 상대의 증명&lt;br&gt;
웹 브라우저가 통신하는 웹 서버가 올바른 대상인지 SSL 서버 인증서로 확인한다. 확인할 수 없으면 웹 브라우저에 경고가 표시된다.&lt;/li&gt;
&lt;li&gt;키 교환&lt;br&gt;
데이터 전송시에 이용하는 &amp;ldquo;키&amp;quot;를 교환한다. 키는 데이터를 전송할 때의 암호화, 해독시의 복호화에 이용된다.&lt;/li&gt;
&lt;li&gt;암호화 방식 확인&lt;br&gt;
실제로 이용하는 암호화 방식의 최종 확인 작업을 실행한다. 이 단계가 완료되면 암호화 통신이 시작된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTPS에서 이러한 네 단계의 상호 작용을 &amp;ldquo;SSL/TLS 핸드셰이크&amp;quot;라고 한다.&lt;/p&gt;
&lt;h2 id=&#34;https의-서버-인증서&#34;&gt;HTTPS의 서버 인증서&lt;/h2&gt;
&lt;p&gt;서버 인증서는 서버와 클라이언트 간에 암호화된 통신을 수행하는 전자 인증서로 인증 기관에서 발급한다.&lt;/p&gt;
&lt;p&gt;X.509에 기반한 인증서로써, 인증서에 &lt;code&gt;웹 사이트 정보&lt;/code&gt;가 추가된다.&lt;/p&gt;
&lt;h3 id=&#34;서버-인증서에-포함된-주요-필드들&#34;&gt;서버 인증서에 포함된 주요 필드들&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;인증서 일련번호 및 유효기간&lt;/li&gt;
&lt;li&gt;웹 사이트의 이름&lt;/li&gt;
&lt;li&gt;웹 사이트의 DNS 호스트명 (FQDN)&lt;/li&gt;
&lt;li&gt;웹 사이트의 공개키&lt;/li&gt;
&lt;li&gt;서명 기관(인증기관)의 이름&lt;/li&gt;
&lt;li&gt;서명 기관(인증기관)의 디지털서명 등&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;웹-사이트-정보에-대한-인증서-주요-검사-웹브라우저가-수행함&#34;&gt;웹 사이트 정보에 대한 인증서 주요 검사 (웹브라우저가 수행함)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;날짜 검사
&lt;ul&gt;
&lt;li&gt;인증서 유효기간 검사 (만료,활성화 여부 등)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서명자 유효성 검사
&lt;ul&gt;
&lt;li&gt;올바른 인증기관에서 파생된 인증서인지를 검사 (신뢰 사슬)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서명 검사
&lt;ul&gt;
&lt;li&gt;인증서 무결성 검사&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;사이트 신원 검사
&lt;ul&gt;
&lt;li&gt;인증서에 명시된 도메인명과 실제 도메인명이 부합되는가를 검사&lt;/li&gt;
&lt;li&gt;통상, 단일 도메인명이지만, 서버 팜(서버 클러스터)을 위해, 와일드카드(&lt;code&gt;*&lt;/code&gt;) 표현 허용&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;가상 호스팅 검사
&lt;ul&gt;
&lt;li&gt;하나의 서버에 여러 사이트/호스트를 운용하는 경우로써, 다소 비 보안적이고 부가적인 관리/절차 등이 필요&lt;/li&gt;
&lt;li&gt;원칙적으로, (IP주소):(포트번호 443)에 단 하나의 인증서 만을 매핑시켜 암호화하나,&lt;/li&gt;
&lt;li&gt;단일 서버에 여러 호스트가 운영되면, 각각을 식별 보안화하기에는 비용적으로 불리하여,&lt;/li&gt;
&lt;li&gt;단순 텍스트(Server Name Indication)로 서버명을 노출(평문)시킬 수 있도록 보안성 완화
&lt;ul&gt;
&lt;li&gt;RFC 4366 (Transport Layer Security (TLS) Extensions)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참고&#34;&gt;참고&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ktword.co.kr/test/view/view.php?m_temp1=3132&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTPS Secure Hypertext Transfer Protocol HTTP 보안계층 구현&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://opentutorials.org/course/228/4894&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTPS와 SSL 인증서 | 생활코딩&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>HTTP 2.0</title>
      <link>https://www.devkuma.com/docs/http/2_0/</link>
      <pubDate>Fri, 12 Aug 2022 07:47:00 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/2_0/</guid>
      <description>
        
        
        &lt;h2 id=&#34;http-20&#34;&gt;HTTP 2.0&lt;/h2&gt;
&lt;p&gt;HTTP 2.0 이라고도 불리는 HTTP/2는 Hypertext Transfer Protocol Version 2의 약자로서, 2015년 IETF에 의해 공식적으로 발표된 HTTP/1.1(기존 표준)의 차기 버전이다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;(IETF: Internet Engineering Task Force)&lt;/strong&gt;:  국제 인터넷 표준화 기구를 의미하며, 인터넷의 운영, 관리, 개발에 대해 협의하고 프로토콜과 구조적인 사안들을 분석하는 인터넷 표준화 작업기구이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTP/2은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP 커넥션을 초기화하는 것은 클라이언트이다. HTTP/2 요청과 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담긴다. 프레임들에 담긴 요청과 응답은 스트림을 통해 보내지는데, 한 개의 스트림이 한 쌍의 요청과 응답을 처리한다. 하나의 커넥션 위에 여러개의 스트림이 동시에 만들어질 수 있으므로 여러 개의 요청과 응답을 동시에 처리하는 것이 가능하다. 또한 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다. 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 그에 대한 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에게 보내줄 수 있다.&lt;/p&gt;
&lt;h2 id=&#34;spdy스피디speedy&#34;&gt;SPDY(스피디/speedy)&lt;/h2&gt;
&lt;p&gt;SPDY(스피디/speedy)는 Google이 개발한 비표준 네트워크 프로토콜로 웹 환경이 계속해서 변해(리소스 증가, 다수의 도메인, 동적 웹 서비스, 보안의 중요성 대두 등) 오면서 패킷 압축, Multiplexing 을 기반으로 인터넷에서의 전송 지연(latency) 문제의 해결을 집중하며 HTTP를 고속화하기 위해 새로 고안된 프로토콜이다. 초창기 크롬 브라우저에 탑재되어 높은 로딩 속도를 자랑하게 했던 구글의 자체 프로토콜이다.
SPDY는 &amp;lsquo;speedy&amp;rsquo;라는 단어를 기반으로 Google이 만든 조어로, Google이 자신들의 &amp;lsquo;Make the Web Faster&amp;rsquo; 노력의 하나로 제안한 새로운 프로토콜이다.&lt;/p&gt;
&lt;p&gt;HTTP/2는 바로 이 SPDY 에 기반을 둔 HTTP 프로토콜 Layer 하위의 TCP 통신 레이어에 새로운 Binary 계층을 도입하여 HTTP 의 기반이 되는 TCP 연결의 호율성을 추구하였다.&lt;/p&gt;
&lt;p&gt;SPDY는 실제로 HTTP/1.1에 비해 상당한 성능 향상과 효율성을 보여줬고 이는 HTTP/2 초안의 참고 규격이 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-spdy-layer.png&#34; alt=&#34;SPDY&#34;&gt;&lt;/p&gt;
&lt;p&gt;SPDY의 특징을 정리하면 아래와 같은데, 개념적인 설명은 HTTP/2와 겹치는 부분이 많으니 HTTP/2에서 더 자세하게 설명하도록 하겠다.
 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;항상 TLS 위에서 동작
&lt;ul&gt;
&lt;li&gt;HTTPS로 작성된 웹 사이트만 적용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP 헤더 압축
&lt;ul&gt;
&lt;li&gt;요청이 많아질 수록 압축률은 커지고, 대역폭이 작은 모바일 환경에서 효과가 크게 보인다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;텍스트가 아닌 바이너리 프로토콜
&lt;ul&gt;
&lt;li&gt;파싱이 더 빠르고, 오류 발생 가능성이 낮다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multiplexing
&lt;ul&gt;
&lt;li&gt;하나의 커넥션 안에서 다수의 독립적인 스트림을 동시에 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Full-duplex interleaving &amp;amp; Prioritization
&lt;ul&gt;
&lt;li&gt;다른 스트림이 끼어드는(interleaving) 것을 허용한다. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Server Push
 
결국, SPDY는 HTTP의 데이터 전송 포맷과 커넥션 관리 부분을 고쳐서 TCP 커넥션을 보다 효율적으로 쓰도록 만든 것이라고 볼 수 있다.
 
다시 한 번 언급하지만, SPDY은 HTTP/2의 참고 규격이 되었다. 그 만큼 비슷한 구조가 많은데, 위의 특징들의 대부분이 HTTP/2에서도 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;주요-특징&#34;&gt;주요 특징&lt;/h2&gt;
&lt;p&gt;주요 특징들은 성능 향상을 목적으로 아래와 같은 특징을 가진다.&lt;/p&gt;
&lt;h3 id=&#34;packet-capsulation---패킷-캡슐화&#34;&gt;Packet Capsulation - 패킷 캡슐화&lt;/h3&gt;
&lt;p&gt;HTTP/2 의 패킷들은 더 작은 단위로 캡슐화(Capsulation)가 되면서 Frame과 Message, Stream 이라는 개념이 도입된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-frame-stream-messages.png&#34; alt=&#34;Request multiplexing&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Frame
&lt;ul&gt;
&lt;li&gt;HTTP/2 의 통신 최소 단위로 모든 패킷에는 하나의 Frame Header가 포함된다.&lt;/li&gt;
&lt;li&gt;이 Frame Header는 최소한으로 Frame이 속하는 스트림을 식별한다.&lt;/li&gt;
&lt;li&gt;HEADERS Type Frame, DATA Type Frame이 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Message
&lt;ul&gt;
&lt;li&gt;논리적 요청 또는 응답 메시지에 매핑되는 프레임의 전체 시퀀스 데이터를 말한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Stream
&lt;ul&gt;
&lt;li&gt;연결의 흐름을 의미하며 구성된 연결 내에서 전달되는 바이트의 양방향 흐름, 하나 이상의 메시지가 전달 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP/2 의 모든 연결은 TCP 기반의 Stream 이며 양방향으로 Frame Header 를 지닌 Message 들을 통신한다.&lt;/p&gt;
&lt;p&gt;데이터는 Binary 인코딩된 데이터들이며 Multiplexing 과 성능 최적화 알고리즘들이 적용된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-stream.png&#34; alt=&#34;Request multiplexing&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;request-multiplexing---병렬-요청&#34;&gt;Request multiplexing - 병렬 요청&lt;/h3&gt;
&lt;p&gt;HTTP/2는 하나의 TCP 연결을 통해 병렬로 여러 데이터 요청을 전송 받을 수 있다.&lt;/p&gt;
&lt;p&gt;스트림은 HTTP/2 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스이다. 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다. 클라이언트는 새 스트림을 만들어 HTTP 요청을 보내고, 이 요청을 받은 서버가 그 요청과 같은 스트림으로 응답을 보내고 나면 스트림이 닫히게 된다.&lt;/p&gt;
&lt;p&gt;기존 HTTP/1.x에서는 한 TCP 커넥션을 통해 요청을 보냈을때 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 요청을 보낼 수 있었다. 그러나, HTTP/2에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있게 되어 여러개의 요청이 동시에 보내질 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;이는 한 서버에서 비동기적으로 웹 파일을 다운로드할 수 있게 해주기 때문에 HTTP/2 프로토콜의 가장 진보된 기능이다. 대부분의 최신 브라우저는 TCP 연결을 하나의 서버로 제한한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-request-multiplexing.png&#34; alt=&#34;Request multiplexing&#34;&gt;&lt;/p&gt;
&lt;p&gt;이는 추가 RTT(왕복 시간)를 줄여 최적화 없이 웹사이트를 더 빠르게 로드하고 도메인 샤딩을 불필요하게 만든다.&lt;/p&gt;
&lt;h3 id=&#34;header-compression---헤더-압축&#34;&gt;Header Compression - 헤더 압축&lt;/h3&gt;
&lt;p&gt;기존 HTTP/1.1 까지의 HTTP 헤더는 아무런 압축 없이 그대로 전송되었다. 과거에는 웹 페이지 하나를 방문했을 때의 요청이 지금처럼 많지 않았지만, 최근 웹들을 무수히 많은 요청을 보내는 형태로 변화했고 그만큼 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 영향을 끼치게 되었다.&lt;/p&gt;
&lt;p&gt;그래서 HTTP/2에서는 HTTP 메시지의 헤더를 압축 및 중복되는 필드를 재전송하지 않도록 변경되었다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존에 HTTP Header가 Plain Text(평문)이었지만, HTTP/2에서는 허프만 코딩(Huffman coding)을 사용하는 HPACK이라는 Header 압축방식을 이용하여 데이터 전송 효율을 높였다.&lt;/li&gt;
&lt;li&gt;‘헤더 블록 조각’들로 쪼개져서 전송하여, 수신 측에서 이 조각들을 이은뒤 압축을 풀어 원래의 헤더 집합으로 복원한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;허프만 코딩(Huffman coding)&lt;/strong&gt;: 데이터 문자의 빈도 수에 따라서 다른 길이의 부호를 사용하는 알고리즘이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-headder-data-compression.png&#34; alt=&#34;HTTP Header Data Compression&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;binary-protocol---바이너리-프로토콜&#34;&gt;Binary protocol - 바이너리 프로토콜&lt;/h3&gt;
&lt;p&gt;최신 HTTP 버전은 텍스트 프로토콜에서 바이너리 프로토콜으로의 변환로 기능 및 속성 측면에서 크게 발전하였다. HTTP/1.x는 요청-응답 주기를 완료하기 위해 텍스트 명령을 처리하는데 사용되었지만, HTTP/2는 바이너리 명령(1과 0)을 사용하여 동일한 작업을 실행한다. 이 속성은 frame과 관련된 복잡성을 완화하고, 텍스트 및 선택적 공백이 포함된 명령으로 인해 혼란스럽게 혼합된 명령의 구현을 단순화 하였다.&lt;/p&gt;
&lt;p&gt;HTTP/2 구현을 사용하는 브라우저는 네트워크를 통해 전송하기 전에 동일한 텍스트 명령을 바이너리로 변환한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-binary-protocol.png&#34; alt=&#34;Binary protocol&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;바이너리-프로토콜의-이점&#34;&gt;바이너리 프로토콜의 이점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;데이터의 파싱이 더 빠르고, 오류 발생 가능성이 낮다.&lt;/li&gt;
&lt;li&gt;네트워크 리소스의 효과적 사용할 수 있다.
&lt;ul&gt;
&lt;li&gt;네트워크 지연 시간을 줄이고 처리량을 개선된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;텍스트 특성과 관련된 보안 문제를 해결된다.
&lt;ul&gt;
&lt;li&gt;예) Response Splitting Attacks &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP/2의 다른 기능을 활성화 수 있다.
&lt;ul&gt;
&lt;li&gt;압축, 멀티플렉싱, 우선 순위 지정, 흐름 제어 및 TLS의 효과적인 처리 등&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server-push---서버-푸시&#34;&gt;Server Push - 서버 푸시&lt;/h3&gt;
&lt;p&gt;HTTP/2은 서버가 하나의 요청에 대해 클라이언트가 요청 하지 않은 JavaScript, CSS, Font, 이미지 파일 등과 같이 필요하게 될 특정 파일들을 서버에서 단일 HTTP 요청 응답 시 함께 전송할 수 있다.&lt;/p&gt;
&lt;p&gt;이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다. HTML 문서를 요청받은 서버가 그 HTML 문서가 링크하고 있는 이미지, CSS 파일 등의 리소스를 클라이언트에게 푸시할 수 있다. 이는 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하게 되는 트래픽과 회전 지연을 줄여준다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.devkuma.com/docs/http/http-server-push.png&#34; alt=&#34;Server Push&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;서버-푸시의-이점&#34;&gt;서버 푸시의 이점&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트는 푸시된 리소스를 캐시에 저장한다.
&lt;ul&gt;
&lt;li&gt;캐시된 리소스를 여러 페이지에 걸쳐 재사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서버는 멀티플렉싱으로 요청한 정보와 함께 푸시된 리소스를 전송 가능하다.&lt;/li&gt;
&lt;li&gt;서버는 푸시되는 리소스의 우선 순위를 지정할 수 있다.&lt;/li&gt;
&lt;li&gt;클라이언트의 선택적 리소스 관리할 수 이다.
&lt;ul&gt;
&lt;li&gt;푸시된 리소스를 거부하거나 서버 푸시를 비활성화할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;클라이언트가 멀티플렉싱되는 푸시 스트림 수 제한 가능하다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stream-prioritization---스트림-우선순위&#34;&gt;Stream Prioritization - 스트림 우선순위&lt;/h3&gt;
&lt;p&gt;스트림은 우선순위를 가질 수 있다. 즉, 클라이언트가 선호하는 응답 수신 방식을 지정해서 응답을 받을 수 있다.&lt;/p&gt;
&lt;p&gt;문서 내에 CSS 파일 1개와 이미지 파일 2개가 존재하고 이를 클라이언트가 요청한다고 가정해 보자. 이미지 파일보다 CSS 파일의 수신이 늦어진다면 브라우저 렌더링에 문제가 생기게 될 수 있는데, HTTP/2에서는 이러한 상황을 고려하여 리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결할 수 있다.&lt;/p&gt;
&lt;p&gt;그리고 모든 스트림은 고유한 식별자를 갖는다. 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://http2.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP2 | Github&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://web.dev/performance-http2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to HTTP/2&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://factory.dev/blog/http2-difference-from-http1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;HTTP/2: the difference between HTTP/1.1, benefits and how to use it&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>HTTP</category>
      
    </item>
    
    <item>
      <title>CORS</title>
      <link>https://www.devkuma.com/docs/http/cors/</link>
      <pubDate>Thu, 27 May 2021 10:59:45 +0900</pubDate>
      <author>redfreek2c@gmail.com (kimkc)</author>
      <guid>https://www.devkuma.com/docs/http/cors/</guid>
      <description>
        
        
        &lt;h2 id=&#34;개요&#34;&gt;개요&lt;/h2&gt;
&lt;p&gt;현재의 Web 브라우저에서는 하나의 Web 사이트가 가진 정보가 다른 악의적인 Web 사이트에 악용되는 것을 방지하기 위해 &lt;a href=&#34;https://www.rfc-editor.org/info/rfc6454&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Same-Origin Policy(동일 출처 정책)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;이 적용된다.&lt;/p&gt;
&lt;p&gt;예를 들어, 각각 다른 도메인으로 된 백 엔드 API와 프런트 엔드 간에 통신하여 자원을 요청하게 되면 Origin(도메인, 프로토콜, 포트 번호)이 다르므로 에러가 발생한다는 것이다. 즉, Web 사이트 &lt;a href=&#34;https://api.devkuma.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://api.devkuma.com/&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 를 브라우저에서 표시 할 때, 이 Web 페이지에서 XMLHttpRequest(이하 XHR)와 Fetch API에서 다른 Web 사이트 &lt;a href=&#34;https://www.devkuma.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.devkuma.com/&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; 에서 HTTP(S)에서 데이터를 읽으려고 하면 오류가 발생한다.&lt;/p&gt;
&lt;p&gt;그런데, 사용자가 액세스한 악의적인 Web 사이트라면 몰라도 데이터 연계를 하는 상대로서 신뢰 관계 수있는 Web 사이트까지 제한을 걸어 버리면 불편하므로 데이터 액세스를 허용 할 수 있는 Web 사이트에 대해서는 Origin이 달라도 액세스를 가능하게 하기 위해 CORS(Cross-Origin Resource Sharing) 라는 것이 필요하다.&lt;/p&gt;
&lt;h2 id=&#34;cors는&#34;&gt;CORS는?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cross-Origin Resource Sharing 약자로 오리진 간의 자원 공유의 의미한다.&lt;/li&gt;
&lt;li&gt;브라우저는 서로 다른 출처간에 통신을 원칙적으로 금지하고 있다. 그러나 Cors 설정을 하여 다른 오리진 간에도 통신할 수 있게 된다.&lt;/li&gt;
&lt;li&gt;브라우저에서 보고있는 페이지와는 다른 도메인에서 데이터의 받아오는 것을 허가하는 방식이다.&lt;/li&gt;
&lt;li&gt;브라우저는 보안 크로스 사이트 스크립팅을 방지하기 위해 사용된다.&lt;/li&gt;
&lt;li&gt;오리진 도메인의 서버와만 통신 할 수 없는 제약이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;origin오리진&#34;&gt;Origin(오리진)?&lt;/h3&gt;
&lt;p&gt;CORS에 대해서 좀 더 정확하게 이해하려면 오리진에 대해 이해하고 있어야 한다. 웹 콘텐츠의 오리진(Origin)은 웹 콘텐츠에 액세스 하는데 사용되는 URL의 스키마(프로토콜), 호스트(도메인), 포트에 의해 정의된다. 스키마, 호스트, 포트가 모두 일치하는 경우에만 두 개체는 같은 오리진이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;Web에서는 같은 오리진 콘텐츠 작업에만 한정되며 (동일 출처 정책)이 제약은 CORS를 사용하여 완화 할 수 있다.&lt;/p&gt;
&lt;h4 id=&#34;동일한-오리진-예&#34;&gt;동일한 오리진 예&lt;/h4&gt;
&lt;p&gt;스키마(http) 및 호스트(&lt;a href=&#34;https://www.devkuma.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;www.devkuma.com&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;)이 동일하므로 동일한 오리진&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://www.devkuma.com/app1/index.html
http://www.devkuma.com/app2/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서버는 기본적으로 80번 포트이고, HTTP 콘텐츠를 제공하므로 동일한 오리진&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://www.devkuma.com:80
http://www.Devkuma.com
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;다른-오리진-예&#34;&gt;다른 오리진 예&lt;/h4&gt;
&lt;p&gt;스키마가 다르다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://devkuma.com/app1
https://devkuma.com/app2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;호스트가 다르다. (서브 도메인이 다르다.)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://devkuma.com
http://www.devkuma.com
http://blog.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;포트가 다르다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://www.devkuma.com
http://www.devkuma.com:8080
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;왜-cors가-필요한가&#34;&gt;왜 CORS가 필요한가?&lt;/h2&gt;
&lt;p&gt;브라우저는 보안상의 이유로 동일한 오리진 정책을 채택하고 있다. 다른 출처에서 내 자원에 마음대로 접근 할 수 없도록 하기 위해 사용한다.&lt;/p&gt;
&lt;p&gt;만약 내가 서비스하지 않는 사이트에서 세션의 요청이 얻을 수 있다면 그 사이트는 내 세션 탈취되면 해당 세션에서 나쁜 짓을 할지도 모른다.
그래서 브라우저는 이러한 요청을 막아주고 있다.&lt;/p&gt;
&lt;p&gt;피싱 사이트가 대표적인 공격의 사례에서 이런 공격은 멈추고 내가시켰다 오리진 만 요청할 수 있도록하기 위해 필요한다.&lt;/p&gt;
&lt;h2 id=&#34;cors는-어떻게-작동-하는가&#34;&gt;CORS는 어떻게 작동 하는가&lt;/h2&gt;
&lt;p&gt;브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담는다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송한다. 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보낸다. 브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킨다.&lt;/p&gt;
&lt;h2 id=&#34;cors-preflight-요청&#34;&gt;CORS preflight 요청&lt;/h2&gt;
&lt;p&gt;HTTP 헤더의 전송로 구성된 시스템이며, 브라우저가 오리진을 넘은 요구에 대한 응답에 프런트 엔드 JavaScript 코드가 접근하는 것을 차단할지 여부를 결정한다.&lt;/p&gt;
&lt;h3 id=&#34;request-header-목록&#34;&gt;Request Header 목록&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Origin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 오리진에서 접근하고 있는지를 보여준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Request-Method&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preflight 요청을 할 때 실제 요청에서 어떤 메서드를 사용할 것인지 서버에게 알리기 위해 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Request-Headers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preflight 요청을 할 때 실제 요청에서 어떤 header를 사용할 것인지 서버에게 알리기 위해 사용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;response-header-목록&#34;&gt;Response Header 목록&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Allow-Origin&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저가 해당 origin이 자원에 접근할 수 있도록 허용한다. 혹은 &lt;code&gt;*&lt;/code&gt;은 credentials이 없는 요청에 한해서 모든 origin에서 접근이 가능하도록 허용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Expose-Headers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;응답의 일부로 어떤 헤더를 공개해도 좋은지를 헤더 이름을 열거하여 보여준다.&lt;/li&gt;
&lt;li&gt;브라우저가 액세스할 수있는 서버 화이트리스트 헤더를 허용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Max-Age&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preflight 요청 결과를 캐시 할 수있는 시간을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Allow-Credentials&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Credentials가 true 일 때 요청에 대한 응답이 노출될 수 있는지를 나타낸다.&lt;/li&gt;
&lt;li&gt;preflight요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지를 나타낸다.&lt;/li&gt;
&lt;li&gt;간단한 GET 요청은 preflight 되지 않으므로 자격 증명이 있는 리소스를 요청하면 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Allow-Methods&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preflight 요청에 대한 대한 응답으로 허용되는 메서드들을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access-Control-Allow-Headers&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;preflight 요청에 대한 응답으로 사용되어 실제 요청을 할 때 사용할 수있다 HTTP 헤더를 나타낸다.요청에 대한 대한 응답으로 실제 요청 시 사용할 수 있는 HTTP 헤더를 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cors-사용-예제&#34;&gt;CORS 사용 예제&lt;/h2&gt;
&lt;p&gt;여기에 하나의 Web 사이트 &lt;code&gt;https://api.devkuma.com&lt;/code&gt; 대해 다른 Web 사이트 &lt;code&gt;https://www.devkuma.com&lt;/code&gt; 에 대한 HTTP(S)에 대한 액세스를 허용할 경우를 예제로 설명한다.&lt;/p&gt;
&lt;h3 id=&#34;간단하게-데이터로드를-허용할-경우&#34;&gt;간단하게 데이터로드를 허용할 경우&lt;/h3&gt;
&lt;p&gt;단순히 XHR 나 Fetch API에서 GET과 POST를 허용하려면 다음과 같이한다. 먼저 클라이언트 측에서 XHR의 경우는 특별한 연구가 필요 없이 Fetch API의 경우 옵션에 따라 CORS를 사용하는 것을 선언한다.&lt;/p&gt;
&lt;p&gt;클라이언트 JavaScript (XHR)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;https://api.devkuma.com&amp;#39;);
xhr.addEventListener(&amp;#39;load&amp;#39;, onLoadFunc, false);
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;클라이언트 JavaScript (Fetch)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fetch(&amp;#39;https://api.devkuma.com&amp;#39;, {
  mode: &amp;#39;cors&amp;#39;
}).then(onLoadFunc);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;그리고, Web 서버 쪽에서는 Origin이 달라도 액세스를 허용하도록 브라우저에 명시적으로 알리기 위해 HTTP 응답 헤더에 적절한 정보를 추가한다.&lt;/p&gt;
&lt;p&gt;먼저 브라우저에서 서버로 전송되는 HTTP 요청 헤더는 다른 Origin 액세스인 경우에 Origin는 필드가 포함된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;GET /api HTTP/1.1
Origin: https://www.devkuma.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;만약 Origin 내용이 신뢰할 수 있는 Web 사이트 Origin 경우 HTTP 응답 헤더에&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;와 같은 내용을 추가하면 브라우저로 액세스가 허용되는 것이다. 또한, 이러한 간단한 예제에만 어떤 Web 사이트에 다른 Origin 액세스를 허용하도록 와일드 카드로 지정할 수 있다 (하위 도메인 등의 부분 지정은 할 수 없다).&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;cookie를-허용하려면&#34;&gt;Cookie를 허용하려면&lt;/h3&gt;
&lt;p&gt;HTTP(S) 통신시에 Cookie의 송수신을 허용하려면 브라우저와 서버 모두에서 조금만 조작해야 한다. 먼저 브라우저의 JavaScript에서는 다음과 같이 작성한다. 아래 예제에서는 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;에 와일드 카드 지정이 허용되지 않기에 주의가 필요하다.&lt;/p&gt;
&lt;p&gt;클라이언트 JavaScript (XHR)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;https://api.devkuma.com&amp;#39;);
xhr.withCredentials = true;
xhr.addEventListener(&amp;#39;load&amp;#39;, onLoadFunc, false);
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;클라이언트 JavaScript (Fetch)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fetch(&amp;#39;https://api.devkuma.com&amp;#39;, {
  mode: &amp;#39;cors&amp;#39;,
  credentials: &amp;#39;include&amp;#39;
}).then(onLoadFunc);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이에 서버 측에서 HTTP 응답 헤더에 다음과 같은 내용을 추가한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
Access-Control-Allow-Credentials: true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;정교한-http-통신을-사용하려면&#34;&gt;정교한 HTTP 통신을 사용하려면&lt;/h3&gt;
&lt;p&gt;CORS 사양 은 다음 조건에 하나라도 해당하는 경우 실제 HTTP 요청 (GET과 POST)를 수행하기 전에 Preflight request 로 OPTIONS 요청을 할 정해져 있다. 이 경우 서버 측에서 GET 및 POST 이외에 OPTIONS에서도 같은 CORS 대응이 필요하게 되므로 주의가 필요하다.&lt;/p&gt;
&lt;p&gt;HTTP 요청 메소드가 GET, POST, HEAD 이외이다.
HTTP 요청 헤더에 &lt;code&gt;Accept&lt;/code&gt;, &lt;code&gt;Accept-Language&lt;/code&gt;, &lt;code&gt;Content-Language &lt;/code&gt;이외의 필드가 포함되어 있거나, Content-Type 필드에 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, &lt;code&gt;text/plain&lt;/code&gt; 이외의 내용이 지정되어 있다.
Preflight request 다음과 같은 HTTP 요청 헤더가 포함되어 있다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;OPTIONS /api HTTP/1.1
Access-Control-Request-Method: {요청 HTTP 메소드 (GET, POST 등)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 Preflight request에 대한 응답으로 예를 들어, 적어도 다음과 같은 요령으로 Origin을 넘는 액세스로 허용하는 HTTP 요청 메소드를 지정해야 한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
Access-Control-Allow-Methods: GET,POST,HEAD,OPTIONS
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;요청에-자신의-http-요청-헤더를-추가하려면&#34;&gt;요청에 자신의 HTTP 요청 헤더를 추가하려면&lt;/h4&gt;
&lt;p&gt;예를 들어, 브라우저 측에서 &lt;code&gt;X-MyRequest&lt;/code&gt;와 &lt;code&gt;X-MyOption&lt;/code&gt;라는 헤더를 추가했다고 하자.&lt;/p&gt;
&lt;p&gt;클라이언트 JavaScript (XHR)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;https://api.devkuma.com&amp;#39;);
xhr.withCredentials = true;
xhr.setRequestHeader(&amp;#39;X-MyRequest&amp;#39;, &amp;#39;this-is-cors-test&amp;#39;);
xhr.setRequestHeader(&amp;#39;X-MyOption&amp;#39;, &amp;#39;my-option&amp;#39;);
xhr.addEventListener(&amp;#39;load&amp;#39;, onLoadFunc, false);
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;클라이언트 JavaScript (Fetch)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fetch(&amp;#39;https://api.devkuma.com&amp;#39;, {
  method: &amp;#39;GET&amp;#39;,
  mode: &amp;#39;cors&amp;#39;,
  credentials: &amp;#39;include&amp;#39;,
  headers: {
    &amp;#39;X-MyRequest&amp;#39;: &amp;#39;this-is-cors-test&amp;#39;,
    &amp;#39;X-MyOption&amp;#39;: &amp;#39;my-option&amp;#39;
  }
}).then(onLoadFunc);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이 경우 먼저 다음과 같은 HTTP 요청 헤더를 포함하여 Preflight request가 브라우저에서 서버로 전송된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;OPTIONS /api HTTP/1.1
Origin: https://www.devkuma.com
Access-Control-Request-Method: GET
Access-Control-Request-Headers: X-MyRequest,X-MyOption
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;서버 측에서는 이러한 요청 헤더에 표시된 메소드와 헤더를 허용할지 여부를 판단하여 응답 헤더를 반환한다. &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;로 지정된 메소드와 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;에서 지정된 헤더가 이 후에는 브라우저에서 전송하는 HTTP 요청이 허용된다. (해당 헤더는 preflight과 실제 요청을 모두 필요하다.)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET,POST,HEAD,OPTIONS
Access-Control-Allow-Headers: X-MyRequest,X-MyOption
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;응답에-자신의-http-응답-헤더를-추가하고-브라우저에서-읽어-내려면&#34;&gt;응답에 자신의 HTTP 응답 헤더를 추가하고 브라우저에서 읽어 내려면&lt;/h4&gt;
&lt;p&gt;다른 Origin에 액세스하는 경우, 예를 들어, 브라우저 측의 코드는 아래와 같다.&lt;/p&gt;
&lt;p&gt;클라이언트 JavaScript (XHR)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var xhr = new XMLHttpRequest();
xhr.open(&amp;#39;GET&amp;#39;, &amp;#39;https://api.devkuma.com&amp;#39;);
xhr.withCredentials = true;
xhr.setRequestHeader(&amp;#39;X-MyRequest&amp;#39;, &amp;#39;this-is-cors-test&amp;#39;);
xhr.setRequestHeader(&amp;#39;X-MyOption&amp;#39;, &amp;#39;my-option&amp;#39;);
xhr.addEventListener(&amp;#39;load&amp;#39;, onLoadFunc, false);
xhr.send(null);

function onLoadFunc() {
  var myResponse = xhr.getResponseHeader(&amp;#39;X-MyResponse&amp;#39;);
  var myOption = xhr.getResponseHeader(&amp;#39;X-MyOption&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;클라이언트 JavaScript (Fetch)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fetch(&amp;#39;https://api.devkuma.com&amp;#39;, {
  method: &amp;#39;GET&amp;#39;,
  mode: &amp;#39;cors&amp;#39;,
  credentials: &amp;#39;include&amp;#39;,
  headers: {
    &amp;#39;X-MyRequest&amp;#39;: &amp;#39;this-is-cors-test&amp;#39;,
    &amp;#39;X-MyOption&amp;#39;: &amp;#39;my-option&amp;#39;
  }
}).then(onLoadFunc);

function onLoadFunc(response) {
  var myResponse = response.headers.get(&amp;#39;X-MyResponse&amp;#39;);
  var myOption = response.headers.get(&amp;#39;X-MyOption&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;이에 대해 서버 측에서 아래와 같이 응답한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
X-MyResponse: this-is-successful-response
X-MyOptions: good-result
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;같은 고유 응답 헤더를 브라우저에 반환하려고 하는 경우, 브라우저는 이러한 응답 헤더의 내용을 받으려고 하면 비보안 헤더에 액세스하려고 한 것으로 간주되어 액세스가 허용되지 않도록 되어 있다. (액세스가 허용되는 응답 헤더는 &lt;code&gt;Cache-Control&lt;/code&gt;, &lt;code&gt;Content-Language&lt;/code&gt;, &lt;code&gt;Content-Type&lt;/code&gt;, &lt;code&gt;Expires Last-Modified&lt;/code&gt;, &lt;code&gt;Pragma&lt;/code&gt;인거 같다.)&lt;/p&gt;
&lt;p&gt;이러한 고유 응답 헤더에 액세스 브라우저 허용하려면 허용할 응답 헤더를 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;로 지정한다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET,POST,HEAD,OPTIONS
Access-Control-Allow-Headers: X-MyRequest,X-MyOption
Access-Control-Expose-Headers: X-MyResponse,X-MyOption
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;또한 당연히 &lt;code&gt;Set-Cookie&lt;/code&gt;와 &lt;code&gt;Set-Cookie2&lt;/code&gt;는 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;로 지정해도 XHR나 Fetch API으로 읽을 수 없다.&lt;/p&gt;
&lt;h3 id=&#34;그런데-preflight-request는-매번-진행-되는가&#34;&gt;그런데 Preflight request는 매번 진행 되는가?&lt;/h3&gt;
&lt;p&gt;Preflight request는 서버 측에서 브라우저 캐시하는 유효 기간을 지정할 수 있다. 이  기간이 있으면 첫 번째 Preflight request가 이 후에는 같은 URL에 대한 HTTP 요청에도 적용이 된다.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://www.devkuma.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET,POST,HEAD,OPTIONS
Access-Control-Allow-Headers: X-MyRequest,X-MyOption
Access-Control-Expose-Headers: X-MyResponse,X-MyOption
Access-Control-Max-Age: 864000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;에는 유효 기간을 초 단위로 지정한다. 위의 예에서는 10일(10(일) x 24(시간) x 60(분) x 60(초) = 864,000 (초))으로 되어 있다.&lt;/p&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ko/docs/Web/HTTP/CORS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;교차 출처 리소스 공유 (CORS)&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[CORS란 무엇인가? - Yunseok&amp;rsquo;s Dev Blog][https://hannut91.github.io/blogs/infra/cors]&lt;/li&gt;
&lt;/ul&gt;

      </description>
      
      <category>HTTP</category>
      
      <category>CORS</category>
      
    </item>
    
  </channel>
</rss>
